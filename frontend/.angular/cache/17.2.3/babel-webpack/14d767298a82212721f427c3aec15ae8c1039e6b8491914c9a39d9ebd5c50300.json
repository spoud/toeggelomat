{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, inject, ElementRef, NgZone, EventEmitter, Directive, Input, Output, ViewContainerRef, TemplateRef, ContentChild, ChangeDetectorRef, DestroyRef, ContentChildren, NgModule, Component, ChangeDetectionStrategy, ViewEncapsulation, PLATFORM_ID, LOCALE_ID, ViewChild, Injector, forwardRef, ApplicationRef, EnvironmentInjector, createComponent, Attribute, ViewChildren, HostBinding, InjectionToken } from '@angular/core';\nimport { takeUntilDestroyed } from '@angular/core/rxjs-interop';\nimport { Observable, EMPTY, of, Subject, fromEvent, timer, race, BehaviorSubject, combineLatest, NEVER, zip, merge } from 'rxjs';\nimport { endWith, takeUntil, filter, map, distinctUntilChanged, startWith, switchMap, take, tap, withLatestFrom, delay, mergeMap, skip, finalize } from 'rxjs/operators';\nimport { isPlatformBrowser, NgTemplateOutlet, FormStyle, TranslationWidth, getLocaleMonthNames, getLocaleDayNames, formatDate, DOCUMENT, PercentPipe, getLocaleDayPeriods } from '@angular/common';\nimport { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';\nimport { flip, preventOverflow, arrow, createPopperLite, offset } from '@popperjs/core';\nfunction NgbAlert_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r2 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 1);\n    i0.ɵɵlistener(\"click\", function NgbAlert_Conditional_1_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r2);\n      const ctx_r1 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r1.close());\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c0 = [\"*\"];\nfunction NgbCarousel_For_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 2);\n    i0.ɵɵlistener(\"click\", function NgbCarousel_For_2_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r9);\n      const slide_r3 = restoredCtx.$implicit;\n      const ctx_r8 = i0.ɵɵnextContext();\n      ctx_r8.focus();\n      return i0.ɵɵresetView(ctx_r8.select(slide_r3.id, ctx_r8.NgbSlideEventSource.INDICATOR));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r3 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"active\", slide_r3.id === ctx_r0.activeId);\n    i0.ɵɵattribute(\"aria-labelledby\", \"slide-\" + slide_r3.id)(\"aria-controls\", \"slide-\" + slide_r3.id)(\"aria-selected\", slide_r3.id === ctx_r0.activeId);\n  }\n}\nfunction NgbCarousel_For_5_ng_template_3_Template(rf, ctx) {}\nfunction NgbCarousel_For_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3)(1, \"span\", 4);\n    i0.ɵɵi18n(2, 5);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, NgbCarousel_For_5_ng_template_3_Template, 0, 0, \"ng-template\", 6);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const slide_r10 = ctx.$implicit;\n    const i_r11 = ctx.$index;\n    const c_r13 = ctx.$count;\n    i0.ɵɵproperty(\"id\", \"slide-\" + slide_r10.id);\n    i0.ɵɵadvance(2);\n    i0.ɵɵi18nExp(i_r11 + 1)(c_r13);\n    i0.ɵɵi18nApply(2);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", slide_r10.templateRef);\n  }\n}\nfunction NgbCarousel_Conditional_6_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 7);\n    i0.ɵɵlistener(\"click\", function NgbCarousel_Conditional_6_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.arrowLeft());\n    });\n    i0.ɵɵelement(1, \"span\", 8);\n    i0.ɵɵelementStart(2, \"span\", 9);\n    i0.ɵɵi18n(3, 10);\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(4, \"button\", 11);\n    i0.ɵɵlistener(\"click\", function NgbCarousel_Conditional_6_Template_button_click_4_listener() {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r18 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r18.arrowRight());\n    });\n    i0.ɵɵelement(5, \"span\", 12);\n    i0.ɵɵelementStart(6, \"span\", 9);\n    i0.ɵɵi18n(7, 13);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-labelledby\", ctx_r2.id + \"-previous\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"id\", ctx_r2.id + \"-previous\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵattribute(\"aria-labelledby\", ctx_r2.id + \"-next\");\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"id\", ctx_r2.id + \"-next\");\n  }\n}\nconst _c1 = [\"ngbDatepickerDayView\", \"\"];\nconst _c2 = [\"month\"];\nconst _c3 = [\"year\"];\nfunction NgbDatepickerNavigationSelect_For_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"option\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const m_r4 = ctx.$implicit;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", m_r4);\n    i0.ɵɵattribute(\"aria-label\", ctx_r1.i18n.getMonthFullName(m_r4, ctx_r1.date.year));\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r1.i18n.getMonthShortName(m_r4, ctx_r1.date.year));\n  }\n}\nfunction NgbDatepickerNavigationSelect_For_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"option\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const y_r9 = ctx.$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"value\", y_r9);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r3.i18n.getYearNumerals(y_r9));\n  }\n}\nfunction NgbDatepickerNavigation_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"ngb-datepicker-navigation-select\", 6);\n    i0.ɵɵlistener(\"select\", function NgbDatepickerNavigation_Conditional_3_Template_ngb_datepicker_navigation_select_select_0_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r2.select.emit($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"date\", ctx_r0.date)(\"disabled\", ctx_r0.disabled)(\"months\", ctx_r0.selectBoxes.months)(\"years\", ctx_r0.selectBoxes.years);\n  }\n}\nfunction NgbDatepickerNavigation_Conditional_4_For_1_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 9);\n  }\n}\nfunction NgbDatepickerNavigation_Conditional_4_For_1_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 9);\n  }\n}\nfunction NgbDatepickerNavigation_Conditional_4_For_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NgbDatepickerNavigation_Conditional_4_For_1_Conditional_0_Template, 1, 0, \"div\", 7);\n    i0.ɵɵelementStart(1, \"div\", 8);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(3, NgbDatepickerNavigation_Conditional_4_For_1_Conditional_3_Template, 1, 0, \"div\", 7);\n  }\n  if (rf & 2) {\n    const month_r5 = ctx.$implicit;\n    const i_r6 = ctx.$index;\n    const ctx_r4 = i0.ɵɵnextContext(2);\n    i0.ɵɵconditional(0, i_r6 > 0 ? 0 : -1);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r4.i18n.getMonthLabel(month_r5.firstDate), \" \");\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(3, i_r6 !== ctx_r4.months.length - 1 ? 3 : -1);\n  }\n}\nfunction NgbDatepickerNavigation_Conditional_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵrepeaterCreate(0, NgbDatepickerNavigation_Conditional_4_For_1_Template, 4, 3, null, null, i0.ɵɵrepeaterTrackByIdentity);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵrepeater(ctx_r1.months);\n  }\n}\nfunction NgbDatepickerMonth_Conditional_0_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r2.i18n.getWeekLabel());\n  }\n}\nfunction NgbDatepickerMonth_Conditional_0_For_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const weekday_r4 = ctx.$implicit;\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(weekday_r4);\n  }\n}\nfunction NgbDatepickerMonth_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 1);\n    i0.ɵɵtemplate(1, NgbDatepickerMonth_Conditional_0_Conditional_1_Template, 2, 1, \"div\", 2);\n    i0.ɵɵrepeaterCreate(2, NgbDatepickerMonth_Conditional_0_For_3_Template, 2, 1, \"div\", 5, i0.ɵɵrepeaterTrackByIdentity);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(1, ctx_r0.datepicker.showWeekNumbers ? 1 : -1);\n    i0.ɵɵadvance();\n    i0.ɵɵrepeater(ctx_r0.viewModel.weekdays);\n  }\n}\nfunction NgbDatepickerMonth_For_2_Conditional_0_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const week_r9 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r15 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r15.i18n.getWeekNumerals(week_r9.number));\n  }\n}\nfunction NgbDatepickerMonth_For_2_Conditional_0_For_3_Conditional_1_ng_template_0_Template(rf, ctx) {}\nfunction NgbDatepickerMonth_For_2_Conditional_0_For_3_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NgbDatepickerMonth_For_2_Conditional_0_For_3_Conditional_1_ng_template_0_Template, 0, 0, \"ng-template\", 11);\n  }\n  if (rf & 2) {\n    const day_r18 = i0.ɵɵnextContext().$implicit;\n    const ctx_r23 = i0.ɵɵnextContext(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r23.datepicker.dayTemplate)(\"ngTemplateOutletContext\", day_r18.context);\n  }\n}\nfunction NgbDatepickerMonth_For_2_Conditional_0_For_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 10);\n    i0.ɵɵlistener(\"click\", function NgbDatepickerMonth_For_2_Conditional_0_For_3_Template_div_click_0_listener($event) {\n      const restoredCtx = i0.ɵɵrestoreView(_r27);\n      const day_r18 = restoredCtx.$implicit;\n      const ctx_r26 = i0.ɵɵnextContext(3);\n      ctx_r26.doSelect(day_r18);\n      return i0.ɵɵresetView($event.preventDefault());\n    });\n    i0.ɵɵtemplate(1, NgbDatepickerMonth_For_2_Conditional_0_For_3_Conditional_1_Template, 1, 2, null, 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const day_r18 = ctx.$implicit;\n    i0.ɵɵclassProp(\"disabled\", day_r18.context.disabled)(\"hidden\", day_r18.hidden)(\"ngb-dp-today\", day_r18.context.today);\n    i0.ɵɵproperty(\"tabindex\", day_r18.tabindex);\n    i0.ɵɵattribute(\"aria-label\", day_r18.ariaLabel);\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(1, !day_r18.hidden ? 1 : -1);\n  }\n}\nfunction NgbDatepickerMonth_For_2_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7);\n    i0.ɵɵtemplate(1, NgbDatepickerMonth_For_2_Conditional_0_Conditional_1_Template, 2, 1, \"div\", 8);\n    i0.ɵɵrepeaterCreate(2, NgbDatepickerMonth_For_2_Conditional_0_For_3_Template, 2, 9, \"div\", 12, i0.ɵɵrepeaterTrackByIdentity);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const week_r9 = i0.ɵɵnextContext().$implicit;\n    const ctx_r14 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(1, ctx_r14.datepicker.showWeekNumbers ? 1 : -1);\n    i0.ɵɵadvance();\n    i0.ɵɵrepeater(week_r9.days);\n  }\n}\nfunction NgbDatepickerMonth_For_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NgbDatepickerMonth_For_2_Conditional_0_Template, 4, 1, \"div\", 6);\n  }\n  if (rf & 2) {\n    const week_r9 = ctx.$implicit;\n    i0.ɵɵconditional(0, !week_r9.collapsed ? 0 : -1);\n  }\n}\nconst _c4 = [\"defaultDayTemplate\"];\nconst _c5 = [\"content\"];\nfunction NgbDatepicker_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"div\", 8);\n  }\n  if (rf & 2) {\n    const date_r8 = ctx.date;\n    const currentMonth_r9 = ctx.currentMonth;\n    const selected_r10 = ctx.selected;\n    const disabled_r11 = ctx.disabled;\n    const focused_r12 = ctx.focused;\n    i0.ɵɵproperty(\"date\", date_r8)(\"currentMonth\", currentMonth_r9)(\"selected\", selected_r10)(\"disabled\", disabled_r11)(\"focused\", focused_r12);\n  }\n}\nfunction NgbDatepicker_ng_template_2_For_1_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const month_r14 = i0.ɵɵnextContext().$implicit;\n    const ctx_r19 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\" \", ctx_r19.i18n.getMonthLabel(month_r14.firstDate), \" \");\n  }\n}\nfunction NgbDatepicker_ng_template_2_For_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 9);\n    i0.ɵɵtemplate(1, NgbDatepicker_ng_template_2_For_1_Conditional_1_Template, 2, 1, \"div\", 10);\n    i0.ɵɵelement(2, \"ngb-datepicker-month\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const month_r14 = ctx.$implicit;\n    const ctx_r13 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(1, ctx_r13.navigation === \"none\" || ctx_r13.displayMonths > 1 && ctx_r13.navigation === \"select\" ? 1 : -1);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"month\", month_r14.firstDate);\n  }\n}\nfunction NgbDatepicker_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵrepeaterCreate(0, NgbDatepicker_ng_template_2_For_1_Template, 3, 2, \"div\", 13, i0.ɵɵrepeaterTrackByIdentity);\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵrepeater(ctx_r2.model.months);\n  }\n}\nfunction NgbDatepicker_Conditional_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r22 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"ngb-datepicker-navigation\", 14);\n    i0.ɵɵlistener(\"navigate\", function NgbDatepicker_Conditional_5_Template_ngb_datepicker_navigation_navigate_0_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r21 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r21.onNavigateEvent($event));\n    })(\"select\", function NgbDatepicker_Conditional_5_Template_ngb_datepicker_navigation_select_0_listener($event) {\n      i0.ɵɵrestoreView(_r22);\n      const ctx_r23 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r23.onNavigateDateSelect($event));\n    });\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"date\", ctx_r4.model.firstDate)(\"months\", ctx_r4.model.months)(\"disabled\", ctx_r4.model.disabled)(\"showSelect\", ctx_r4.model.navigation === \"select\")(\"prevDisabled\", ctx_r4.model.prevDisabled)(\"nextDisabled\", ctx_r4.model.nextDisabled)(\"selectBoxes\", ctx_r4.model.selectBoxes);\n  }\n}\nfunction NgbDatepicker_ng_template_8_Template(rf, ctx) {}\nfunction NgbDatepicker_ng_template_9_Template(rf, ctx) {}\nconst _c6 = a0 => ({\n  $implicit: a0\n});\nconst _c7 = [\"dialog\"];\nconst _c8 = [\"ngbNavOutlet\", \"\"];\nfunction NgbNavOutlet_For_1_Conditional_0_ng_template_1_Template(rf, ctx) {}\nfunction NgbNavOutlet_For_1_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 0);\n    i0.ɵɵtemplate(1, NgbNavOutlet_For_1_Conditional_0_ng_template_1_Template, 0, 0, \"ng-template\", 1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"item\", item_r1)(\"nav\", ctx_r6.nav)(\"role\", ctx_r6.paneRole);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (item_r1.contentTpl == null ? null : item_r1.contentTpl.templateRef) || null)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(5, _c6, item_r1.active || ctx_r6.isPanelTransitioning(item_r1)));\n  }\n}\nfunction NgbNavOutlet_For_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NgbNavOutlet_For_1_Conditional_0_Template, 2, 7, \"div\", 0);\n  }\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵconditional(0, item_r1.isPanelInDom() || ctx_r0.isPanelTransitioning(item_r1) ? 0 : -1);\n  }\n}\nfunction NgbPagination_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵi18n(1, 10);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgbPagination_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵi18n(1, 11);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgbPagination_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵi18n(1, 12);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgbPagination_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9);\n    i0.ɵɵi18n(1, 13);\n    i0.ɵɵelementEnd();\n  }\n}\nfunction NgbPagination_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0, \"...\");\n  }\n}\nfunction NgbPagination_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const page_r19 = ctx.$implicit;\n    i0.ɵɵtextInterpolate(page_r19);\n  }\n}\nfunction NgbPagination_ng_template_12_For_1_Conditional_1_ng_template_1_Template(rf, ctx) {}\nconst _c9 = a1 => ({\n  disabled: true,\n  currentPage: a1\n});\nfunction NgbPagination_ng_template_12_For_1_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"a\", 16);\n    i0.ɵɵtemplate(1, NgbPagination_ng_template_12_For_1_Conditional_1_ng_template_1_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const page_r21 = i0.ɵɵnextContext(2).$implicit;\n    const ctx_r30 = i0.ɵɵnextContext();\n    const _r9 = i0.ɵɵreference(9);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r30.tplEllipsis == null ? null : ctx_r30.tplEllipsis.templateRef) || _r9)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c9, page_r21));\n  }\n}\nfunction NgbPagination_ng_template_12_For_1_Conditional_2_ng_template_1_Template(rf, ctx) {}\nconst _c10 = (a0, a1, a2) => ({\n  disabled: a0,\n  $implicit: a1,\n  currentPage: a2\n});\nfunction NgbPagination_ng_template_12_For_1_Conditional_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r37 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 17);\n    i0.ɵɵlistener(\"click\", function NgbPagination_ng_template_12_For_1_Conditional_2_Template_a_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r37);\n      const pageNumber_r25 = i0.ɵɵnextContext().$implicit;\n      const ctx_r35 = i0.ɵɵnextContext(2);\n      ctx_r35.selectPage(pageNumber_r25);\n      return i0.ɵɵresetView($event.preventDefault());\n    });\n    i0.ɵɵtemplate(1, NgbPagination_ng_template_12_For_1_Conditional_2_ng_template_1_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const pageNumber_r25 = i0.ɵɵnextContext().$implicit;\n    const ctx_r38 = i0.ɵɵnextContext();\n    const disabled_r23 = ctx_r38.disabled;\n    const page_r21 = ctx_r38.$implicit;\n    const ctx_r31 = i0.ɵɵnextContext();\n    const _r11 = i0.ɵɵreference(11);\n    i0.ɵɵattribute(\"tabindex\", disabled_r23 ? \"-1\" : null)(\"aria-disabled\", disabled_r23 ? \"true\" : null);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r31.tplNumber == null ? null : ctx_r31.tplNumber.templateRef) || _r11)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(4, _c10, disabled_r23, pageNumber_r25, page_r21));\n  }\n}\nfunction NgbPagination_ng_template_12_For_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 14);\n    i0.ɵɵtemplate(1, NgbPagination_ng_template_12_For_1_Conditional_1_Template, 2, 4, \"a\", 15)(2, NgbPagination_ng_template_12_For_1_Conditional_2_Template, 2, 8);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const pageNumber_r25 = ctx.$implicit;\n    const ctx_r40 = i0.ɵɵnextContext();\n    const page_r21 = ctx_r40.$implicit;\n    const disabled_r23 = ctx_r40.disabled;\n    const ctx_r24 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"active\", pageNumber_r25 === page_r21)(\"disabled\", ctx_r24.isEllipsis(pageNumber_r25) || disabled_r23);\n    i0.ɵɵattribute(\"aria-current\", pageNumber_r25 === page_r21 ? \"page\" : null);\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(1, ctx_r24.isEllipsis(pageNumber_r25) ? 1 : 2);\n  }\n}\nfunction NgbPagination_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵrepeaterCreate(0, NgbPagination_ng_template_12_For_1_Template, 3, 6, \"li\", 18, i0.ɵɵrepeaterTrackByIdentity);\n  }\n  if (rf & 2) {\n    const pages_r22 = ctx.pages;\n    i0.ɵɵrepeater(pages_r22);\n  }\n}\nfunction NgbPagination_Conditional_15_ng_template_2_Template(rf, ctx) {}\nconst _c11 = (a0, a1) => ({\n  disabled: a0,\n  currentPage: a1\n});\nfunction NgbPagination_Conditional_15_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r43 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 14)(1, \"a\", 19);\n    i0.ɵɵlistener(\"click\", function NgbPagination_Conditional_15_Template_a_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r43);\n      const ctx_r42 = i0.ɵɵnextContext();\n      ctx_r42.selectPage(1);\n      return i0.ɵɵresetView($event.preventDefault());\n    });\n    i0.ɵɵtemplate(2, NgbPagination_Conditional_15_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext();\n    const _r1 = i0.ɵɵreference(1);\n    i0.ɵɵclassProp(\"disabled\", ctx_r14.previousDisabled());\n    i0.ɵɵadvance();\n    i0.ɵɵattribute(\"tabindex\", ctx_r14.previousDisabled() ? \"-1\" : null)(\"aria-disabled\", ctx_r14.previousDisabled() ? \"true\" : null);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r14.tplFirst == null ? null : ctx_r14.tplFirst.templateRef) || _r1)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(6, _c11, ctx_r14.previousDisabled(), ctx_r14.page));\n  }\n}\nfunction NgbPagination_Conditional_16_ng_template_2_Template(rf, ctx) {}\nconst _c12 = a0 => ({\n  disabled: a0\n});\nfunction NgbPagination_Conditional_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r46 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 14)(1, \"a\", 20);\n    i0.ɵɵlistener(\"click\", function NgbPagination_Conditional_16_Template_a_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r46);\n      const ctx_r45 = i0.ɵɵnextContext();\n      ctx_r45.selectPage(ctx_r45.page - 1);\n      return i0.ɵɵresetView($event.preventDefault());\n    });\n    i0.ɵɵtemplate(2, NgbPagination_Conditional_16_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(3);\n    i0.ɵɵclassProp(\"disabled\", ctx_r15.previousDisabled());\n    i0.ɵɵadvance();\n    i0.ɵɵattribute(\"tabindex\", ctx_r15.previousDisabled() ? \"-1\" : null)(\"aria-disabled\", ctx_r15.previousDisabled() ? \"true\" : null);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r15.tplPrevious == null ? null : ctx_r15.tplPrevious.templateRef) || _r3)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(6, _c12, ctx_r15.previousDisabled()));\n  }\n}\nfunction NgbPagination_ng_template_17_Template(rf, ctx) {}\nfunction NgbPagination_Conditional_18_ng_template_2_Template(rf, ctx) {}\nfunction NgbPagination_Conditional_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r49 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 14)(1, \"a\", 21);\n    i0.ɵɵlistener(\"click\", function NgbPagination_Conditional_18_Template_a_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r49);\n      const ctx_r48 = i0.ɵɵnextContext();\n      ctx_r48.selectPage(ctx_r48.page + 1);\n      return i0.ɵɵresetView($event.preventDefault());\n    });\n    i0.ɵɵtemplate(2, NgbPagination_Conditional_18_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r17 = i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(5);\n    i0.ɵɵclassProp(\"disabled\", ctx_r17.nextDisabled());\n    i0.ɵɵadvance();\n    i0.ɵɵattribute(\"tabindex\", ctx_r17.nextDisabled() ? \"-1\" : null)(\"aria-disabled\", ctx_r17.nextDisabled() ? \"true\" : null);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r17.tplNext == null ? null : ctx_r17.tplNext.templateRef) || _r5)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(6, _c11, ctx_r17.nextDisabled(), ctx_r17.page));\n  }\n}\nfunction NgbPagination_Conditional_19_ng_template_2_Template(rf, ctx) {}\nfunction NgbPagination_Conditional_19_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r52 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 14)(1, \"a\", 22);\n    i0.ɵɵlistener(\"click\", function NgbPagination_Conditional_19_Template_a_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r52);\n      const ctx_r51 = i0.ɵɵnextContext();\n      ctx_r51.selectPage(ctx_r51.pageCount);\n      return i0.ɵɵresetView($event.preventDefault());\n    });\n    i0.ɵɵtemplate(2, NgbPagination_Conditional_19_ng_template_2_Template, 0, 0, \"ng-template\", 8);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext();\n    const _r7 = i0.ɵɵreference(7);\n    i0.ɵɵclassProp(\"disabled\", ctx_r18.nextDisabled());\n    i0.ɵɵadvance();\n    i0.ɵɵattribute(\"tabindex\", ctx_r18.nextDisabled() ? \"-1\" : null)(\"aria-disabled\", ctx_r18.nextDisabled() ? \"true\" : null);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r18.tplLast == null ? null : ctx_r18.tplLast.templateRef) || _r7)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction2(6, _c11, ctx_r18.nextDisabled(), ctx_r18.page));\n  }\n}\nconst _c13 = (a0, a1, a2) => ({\n  $implicit: a0,\n  pages: a1,\n  disabled: a2\n});\nfunction NgbPopoverWindow_Conditional_1_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext(2);\n    i0.ɵɵtextInterpolate(ctx_r1.title);\n  }\n}\nfunction NgbPopoverWindow_Conditional_1_ng_template_3_Template(rf, ctx) {}\nfunction NgbPopoverWindow_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"h3\", 3);\n    i0.ɵɵtemplate(1, NgbPopoverWindow_Conditional_1_ng_template_1_Template, 1, 1, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor)(3, NgbPopoverWindow_Conditional_1_ng_template_3_Template, 0, 0, \"ng-template\", 5);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const _r2 = i0.ɵɵreference(2);\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.isTitleTemplate() ? ctx_r0.title : _r2)(\"ngTemplateOutletContext\", ctx_r0.context);\n  }\n}\nfunction NgbProgressbar_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵi18n(1, 0);\n    i0.ɵɵpipe(2, \"percent\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵi18nExp(i0.ɵɵpipeBind1(2, 1, ctx_r0.getValue() / ctx_r0.max));\n    i0.ɵɵi18nApply(1);\n  }\n}\nfunction NgbRating_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtext(0);\n  }\n  if (rf & 2) {\n    const fill_r3 = ctx.fill;\n    i0.ɵɵtextInterpolate(fill_r3 === 100 ? \"\\u2605\" : \"\\u2606\");\n  }\n}\nfunction NgbRating_For_3_ng_template_3_Template(rf, ctx) {}\nfunction NgbRating_For_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 1);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"span\", 2);\n    i0.ɵɵlistener(\"mouseenter\", function NgbRating_For_3_Template_span_mouseenter_2_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r11);\n      const index_r5 = restoredCtx.$index;\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.enter(index_r5 + 1));\n    })(\"click\", function NgbRating_For_3_Template_span_click_2_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r11);\n      const index_r5 = restoredCtx.$index;\n      const ctx_r12 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r12.handleClick(index_r5 + 1));\n    });\n    i0.ɵɵtemplate(3, NgbRating_For_3_ng_template_3_Template, 0, 0, \"ng-template\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const index_r5 = ctx.$index;\n    const ctx_r2 = i0.ɵɵnextContext();\n    const _r1 = i0.ɵɵreference(1);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate1(\"(\", index_r5 < ctx_r2.nextRate ? \"*\" : \" \", \")\");\n    i0.ɵɵadvance();\n    i0.ɵɵstyleProp(\"cursor\", ctx_r2.isInteractive() ? \"pointer\" : \"default\");\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.starTemplate || ctx_r2.starTemplateFromContent || _r1)(\"ngTemplateOutletContext\", ctx_r2.contexts[index_r5]);\n  }\n}\nfunction NgbTimepicker_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r7 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function NgbTimepicker_Conditional_3_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r7);\n      const ctx_r6 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r6.changeHour(ctx_r6.hourStep));\n    });\n    i0.ɵɵelement(1, \"span\", 9);\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵi18n(3, 11);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"btn-sm\", ctx_r0.isSmallSize)(\"btn-lg\", ctx_r0.isLargeSize)(\"disabled\", ctx_r0.disabled);\n    i0.ɵɵproperty(\"disabled\", ctx_r0.disabled);\n  }\n}\nfunction NgbTimepicker_Conditional_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function NgbTimepicker_Conditional_5_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.changeHour(-ctx_r8.hourStep));\n    });\n    i0.ɵɵelement(1, \"span\", 12);\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵi18n(3, 13);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"btn-sm\", ctx_r1.isSmallSize)(\"btn-lg\", ctx_r1.isLargeSize)(\"disabled\", ctx_r1.disabled);\n    i0.ɵɵproperty(\"disabled\", ctx_r1.disabled);\n  }\n}\nfunction NgbTimepicker_Conditional_9_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function NgbTimepicker_Conditional_9_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r10.changeMinute(ctx_r10.minuteStep));\n    });\n    i0.ɵɵelement(1, \"span\", 9);\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵi18n(3, 14);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"btn-sm\", ctx_r2.isSmallSize)(\"btn-lg\", ctx_r2.isLargeSize)(\"disabled\", ctx_r2.disabled);\n    i0.ɵɵproperty(\"disabled\", ctx_r2.disabled);\n  }\n}\nfunction NgbTimepicker_Conditional_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function NgbTimepicker_Conditional_11_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r13);\n      const ctx_r12 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r12.changeMinute(-ctx_r12.minuteStep));\n    });\n    i0.ɵɵelement(1, \"span\", 12);\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵi18n(3, 15);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"btn-sm\", ctx_r3.isSmallSize)(\"btn-lg\", ctx_r3.isLargeSize)(\"disabled\", ctx_r3.disabled);\n    i0.ɵɵproperty(\"disabled\", ctx_r3.disabled);\n  }\n}\nfunction NgbTimepicker_Conditional_12_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function NgbTimepicker_Conditional_12_Conditional_3_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r16.changeSecond(ctx_r16.secondStep));\n    });\n    i0.ɵɵelement(1, \"span\", 9);\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵi18n(3, 18);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r14 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"btn-sm\", ctx_r14.isSmallSize)(\"btn-lg\", ctx_r14.isLargeSize)(\"disabled\", ctx_r14.disabled);\n    i0.ɵɵproperty(\"disabled\", ctx_r14.disabled);\n  }\n}\nfunction NgbTimepicker_Conditional_12_Conditional_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r19 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 8);\n    i0.ɵɵlistener(\"click\", function NgbTimepicker_Conditional_12_Conditional_5_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r19);\n      const ctx_r18 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r18.changeSecond(-ctx_r18.secondStep));\n    });\n    i0.ɵɵelement(1, \"span\", 12);\n    i0.ɵɵelementStart(2, \"span\", 10);\n    i0.ɵɵi18n(3, 19);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵclassProp(\"btn-sm\", ctx_r15.isSmallSize)(\"btn-lg\", ctx_r15.isLargeSize)(\"disabled\", ctx_r15.disabled);\n    i0.ɵɵproperty(\"disabled\", ctx_r15.disabled);\n  }\n}\nfunction NgbTimepicker_Conditional_12_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵtext(1, \":\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(2, \"div\", 16);\n    i0.ɵɵtemplate(3, NgbTimepicker_Conditional_12_Conditional_3_Template, 4, 7, \"button\", 3);\n    i0.ɵɵelementStart(4, \"input\", 17);\n    i0.ɵɵlistener(\"change\", function NgbTimepicker_Conditional_12_Template_input_change_4_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r20 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r20.updateSecond($event.target.value));\n    })(\"blur\", function NgbTimepicker_Conditional_12_Template_input_blur_4_listener() {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r22 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r22.handleBlur());\n    })(\"input\", function NgbTimepicker_Conditional_12_Template_input_input_4_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r23 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r23.formatInput($event.target));\n    })(\"keydown.ArrowUp\", function NgbTimepicker_Conditional_12_Template_input_keydown_ArrowUp_4_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r24 = i0.ɵɵnextContext();\n      ctx_r24.changeSecond(ctx_r24.secondStep);\n      return i0.ɵɵresetView($event.preventDefault());\n    })(\"keydown.ArrowDown\", function NgbTimepicker_Conditional_12_Template_input_keydown_ArrowDown_4_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r25 = i0.ɵɵnextContext();\n      ctx_r25.changeSecond(-ctx_r25.secondStep);\n      return i0.ɵɵresetView($event.preventDefault());\n    });\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, NgbTimepicker_Conditional_12_Conditional_5_Template, 4, 7, \"button\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(3);\n    i0.ɵɵconditional(3, ctx_r4.spinners ? 3 : -1);\n    i0.ɵɵadvance();\n    i0.ɵɵclassProp(\"form-control-sm\", ctx_r4.isSmallSize)(\"form-control-lg\", ctx_r4.isLargeSize);\n    i0.ɵɵproperty(\"value\", ctx_r4.formatMinSec(ctx_r4.model == null ? null : ctx_r4.model.second))(\"readOnly\", ctx_r4.readonlyInputs)(\"disabled\", ctx_r4.disabled);\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(5, ctx_r4.spinners ? 5 : -1);\n  }\n}\nfunction NgbTimepicker_Conditional_13_Conditional_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵi18n(1, 22);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance();\n    i0.ɵɵi18nExp(ctx_r26.i18n.getAfternoonPeriod());\n    i0.ɵɵi18nApply(1);\n  }\n}\nfunction NgbTimepicker_Conditional_13_Conditional_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r27 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r27.i18n.getMorningPeriod());\n  }\n}\nfunction NgbTimepicker_Conditional_13_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelement(0, \"div\", 5);\n    i0.ɵɵelementStart(1, \"div\", 20)(2, \"button\", 21);\n    i0.ɵɵlistener(\"click\", function NgbTimepicker_Conditional_13_Template_button_click_2_listener() {\n      i0.ɵɵrestoreView(_r29);\n      const ctx_r28 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r28.toggleMeridian());\n    });\n    i0.ɵɵtemplate(3, NgbTimepicker_Conditional_13_Conditional_3_Template, 2, 1, \"ng-container\")(4, NgbTimepicker_Conditional_13_Conditional_4_Template, 2, 1);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r5 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"btn-sm\", ctx_r5.isSmallSize)(\"btn-lg\", ctx_r5.isLargeSize)(\"disabled\", ctx_r5.disabled);\n    i0.ɵɵproperty(\"disabled\", ctx_r5.disabled);\n    i0.ɵɵadvance();\n    i0.ɵɵconditional(3, ctx_r5.model && ctx_r5.model.hour >= 12 ? 3 : 4);\n  }\n}\nfunction NgbToast_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"strong\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(ctx_r0.header);\n  }\n}\nfunction NgbToast_Conditional_2_ng_template_1_Template(rf, ctx) {}\nfunction NgbToast_Conditional_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 4);\n    i0.ɵɵtemplate(1, NgbToast_Conditional_2_ng_template_1_Template, 0, 0, \"ng-template\", 5);\n    i0.ɵɵelementStart(2, \"button\", 6);\n    i0.ɵɵlistener(\"click\", function NgbToast_Conditional_2_Template_button_click_2_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r4.hide());\n    });\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    const _r1 = i0.ɵɵreference(1);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.contentHeaderTpl || _r1);\n  }\n}\nfunction NgbHighlight_For_1_Conditional_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\");\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const part_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵclassMap(ctx_r6.highlightClass);\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(part_r1);\n  }\n}\nfunction NgbHighlight_For_1_Conditional_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const part_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance();\n    i0.ɵɵtextInterpolate(part_r1);\n  }\n}\nfunction NgbHighlight_For_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NgbHighlight_For_1_Conditional_0_Template, 2, 4, \"span\", 0)(1, NgbHighlight_For_1_Conditional_1_Template, 2, 1);\n  }\n  if (rf & 2) {\n    const $index_r2 = ctx.$index;\n    i0.ɵɵconditional(0, $index_r2 % 2 !== 0 ? 0 : 1);\n  }\n}\nfunction NgbTypeaheadWindow_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"ngb-highlight\", 1);\n  }\n  if (rf & 2) {\n    const result_r3 = ctx.result;\n    const term_r4 = ctx.term;\n    const formatter_r5 = ctx.formatter;\n    i0.ɵɵproperty(\"result\", formatter_r5(result_r3))(\"term\", term_r4);\n  }\n}\nfunction NgbTypeaheadWindow_For_3_ng_template_1_Template(rf, ctx) {}\nconst _c14 = (a0, a1, a2) => ({\n  result: a0,\n  term: a1,\n  formatter: a2\n});\nfunction NgbTypeaheadWindow_For_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r13 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 2);\n    i0.ɵɵlistener(\"mouseenter\", function NgbTypeaheadWindow_For_3_Template_button_mouseenter_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const idx_r7 = restoredCtx.$index;\n      const ctx_r12 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r12.markActive(idx_r7));\n    })(\"click\", function NgbTypeaheadWindow_For_3_Template_button_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r13);\n      const result_r6 = restoredCtx.$implicit;\n      const ctx_r14 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r14.select(result_r6));\n    });\n    i0.ɵɵtemplate(1, NgbTypeaheadWindow_For_3_ng_template_1_Template, 0, 0, \"ng-template\", 3);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const result_r6 = ctx.$implicit;\n    const idx_r7 = ctx.$index;\n    const ctx_r2 = i0.ɵɵnextContext();\n    const _r1 = i0.ɵɵreference(1);\n    i0.ɵɵclassProp(\"active\", idx_r7 === ctx_r2.activeIdx);\n    i0.ɵɵproperty(\"id\", ctx_r2.id + \"-\" + idx_r7);\n    i0.ɵɵadvance();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.resultTemplate || _r1)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(5, _c14, result_r6, ctx_r2.term, ctx_r2.formatter));\n  }\n}\nconst environment = {\n  animation: true,\n  transitionTimerDelayMs: 5\n};\n\n/**\n * Global ng-bootstrap config\n *\n * @since 8.0.0\n */\nlet NgbConfig = /*#__PURE__*/(() => {\n  class NgbConfig {\n    constructor() {\n      this.animation = environment.animation;\n    }\n    static #_ = this.ɵfac = function NgbConfig_Factory(t) {\n      return new (t || NgbConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbConfig,\n      factory: NgbConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbAccordionDirective`](#/components/accordion/api#NgbAccordionDirective).\n *\n * You can inject this service, typically in your root component, and customize its properties\n * to provide default values for all accordions used in the application.\n */\nlet NgbAccordionConfig = /*#__PURE__*/(() => {\n  class NgbAccordionConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.closeOthers = false;\n      this.destroyOnHide = true;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbAccordionConfig_Factory(t) {\n      return new (t || NgbAccordionConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbAccordionConfig,\n      factory: NgbAccordionConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbAccordionConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction getTransitionDurationMs(element) {\n  const {\n    transitionDelay,\n    transitionDuration\n  } = window.getComputedStyle(element);\n  const transitionDelaySec = parseFloat(transitionDelay);\n  const transitionDurationSec = parseFloat(transitionDuration);\n  return (transitionDelaySec + transitionDurationSec) * 1000;\n}\nfunction toInteger(value) {\n  return parseInt(`${value}`, 10);\n}\nfunction toString(value) {\n  return value !== undefined && value !== null ? `${value}` : '';\n}\nfunction getValueInRange(value, max, min = 0) {\n  return Math.max(Math.min(value, max), min);\n}\nfunction isString(value) {\n  return typeof value === 'string';\n}\nfunction isNumber(value) {\n  return !isNaN(toInteger(value));\n}\nfunction isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\nfunction isDefined(value) {\n  return value !== undefined && value !== null;\n}\nfunction isPromise(v) {\n  return v && v.then;\n}\nfunction padNumber(value) {\n  if (isNumber(value)) {\n    return `0${value}`.slice(-2);\n  } else {\n    return '';\n  }\n}\nfunction regExpEscape(text) {\n  return text.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n}\nfunction closest(element, selector) {\n  if (!selector) {\n    return null;\n  }\n  /*\n   * In certain browsers (e.g. Edge 44.18362.449.0) HTMLDocument does\n   * not support `Element.prototype.closest`. To emulate the correct behaviour\n   * we return null when the method is missing.\n   *\n   * Note that in evergreen browsers `closest(document.documentElement, 'html')`\n   * will return the document element whilst in Edge null will be returned. This\n   * compromise was deemed good enough.\n   */\n  if (typeof element.closest === 'undefined') {\n    return null;\n  }\n  return element.closest(selector);\n}\n/**\n * Force a browser reflow\n * @param element element where to apply the reflow\n */\nfunction reflow(element) {\n  return (element || document.body).getBoundingClientRect();\n}\n/**\n * Creates an observable where all callbacks are executed inside a given zone\n *\n * @param zone\n */\nfunction runInZone(zone) {\n  return source => {\n    return new Observable(observer => {\n      const next = value => zone.run(() => observer.next(value));\n      const error = e => zone.run(() => observer.error(e));\n      const complete = () => zone.run(() => observer.complete());\n      return source.subscribe({\n        next,\n        error,\n        complete\n      });\n    });\n  };\n}\nfunction removeAccents(str) {\n  return str.normalize('NFD').replace(/[\\u0300-\\u036f]/g, '');\n}\n/**\n * Returns the active element in the given root.\n * If the active element is inside a shadow root, it is searched recursively.\n */\nfunction getActiveElement(root = document) {\n  const activeEl = root?.activeElement;\n  if (!activeEl) {\n    return null;\n  }\n  return activeEl.shadowRoot ? getActiveElement(activeEl.shadowRoot) : activeEl;\n}\nconst noopFn = () => {};\nconst {\n  transitionTimerDelayMs\n} = environment;\nconst runningTransitions = new Map();\nconst ngbRunTransition = (zone, element, startFn, options) => {\n  // Getting initial context from options\n  let context = options.context || {};\n  // Checking if there are already running transitions on the given element.\n  const running = runningTransitions.get(element);\n  if (running) {\n    switch (options.runningTransition) {\n      // If there is one running and we want for it to 'continue' to run, we have to cancel the new one.\n      // We're not emitting any values, but simply completing the observable (EMPTY).\n      case 'continue':\n        return EMPTY;\n      // If there is one running and we want for it to 'stop', we have to complete the running one.\n      // We're simply completing the running one and not emitting any values and merging newly provided context\n      // with the one coming from currently running transition.\n      case 'stop':\n        zone.run(() => running.transition$.complete());\n        context = Object.assign(running.context, context);\n        runningTransitions.delete(element);\n    }\n  }\n  // Running the start function\n  const endFn = startFn(element, options.animation, context) || noopFn;\n  // If 'prefer-reduced-motion' is enabled, the 'transition' will be set to 'none'.\n  // If animations are disabled, we have to emit a value and complete the observable\n  // In this case we have to call the end function, but can finish immediately by emitting a value,\n  // completing the observable and executing end functions synchronously.\n  if (!options.animation || window.getComputedStyle(element).transitionProperty === 'none') {\n    zone.run(() => endFn());\n    return of(undefined).pipe(runInZone(zone));\n  }\n  // Starting a new transition\n  const transition$ = new Subject();\n  const finishTransition$ = new Subject();\n  const stop$ = transition$.pipe(endWith(true));\n  runningTransitions.set(element, {\n    transition$,\n    complete: () => {\n      finishTransition$.next();\n      finishTransition$.complete();\n    },\n    context\n  });\n  const transitionDurationMs = getTransitionDurationMs(element);\n  // 1. We have to both listen for the 'transitionend' event and have a 'just-in-case' timer,\n  // because 'transitionend' event might not be fired in some browsers, if the transitioning\n  // element becomes invisible (ex. when scrolling, making browser tab inactive, etc.). The timer\n  // guarantees, that we'll release the DOM element and complete 'ngbRunTransition'.\n  // 2. We need to filter transition end events, because they might bubble from shorter transitions\n  // on inner DOM elements. We're only interested in the transition on the 'element' itself.\n  zone.runOutsideAngular(() => {\n    const transitionEnd$ = fromEvent(element, 'transitionend').pipe(takeUntil(stop$), filter(({\n      target\n    }) => target === element));\n    const timer$ = timer(transitionDurationMs + transitionTimerDelayMs).pipe(takeUntil(stop$));\n    race(timer$, transitionEnd$, finishTransition$).pipe(takeUntil(stop$)).subscribe(() => {\n      runningTransitions.delete(element);\n      zone.run(() => {\n        endFn();\n        transition$.next();\n        transition$.complete();\n      });\n    });\n  });\n  return transition$.asObservable();\n};\nconst ngbCompleteTransition = element => {\n  runningTransitions.get(element)?.complete();\n};\nfunction measureCollapsingElementDimensionPx(element, dimension) {\n  // SSR fix for without injecting the PlatformId\n  if (typeof navigator === 'undefined') {\n    return '0px';\n  }\n  const {\n    classList\n  } = element;\n  const hasShownClass = classList.contains('show');\n  if (!hasShownClass) {\n    classList.add('show');\n  }\n  element.style[dimension] = '';\n  const dimensionSize = element.getBoundingClientRect()[dimension] + 'px';\n  if (!hasShownClass) {\n    classList.remove('show');\n  }\n  return dimensionSize;\n}\nconst ngbCollapsingTransition = (element, animation, context) => {\n  let {\n    direction,\n    maxSize,\n    dimension\n  } = context;\n  const {\n    classList\n  } = element;\n  function setInitialClasses() {\n    classList.add('collapse');\n    if (direction === 'show') {\n      classList.add('show');\n    } else {\n      classList.remove('show');\n    }\n  }\n  // without animations we just need to set initial classes\n  if (!animation) {\n    setInitialClasses();\n    return;\n  }\n  // No maxHeight -> running the transition for the first time\n  if (!maxSize) {\n    maxSize = measureCollapsingElementDimensionPx(element, dimension);\n    context.maxSize = maxSize;\n    // Fix the height before starting the animation\n    element.style[dimension] = direction !== 'show' ? maxSize : '0px';\n    classList.remove('collapse');\n    classList.remove('collapsing');\n    classList.remove('show');\n    reflow(element);\n    // Start the animation\n    classList.add('collapsing');\n  }\n  // Start or revert the animation\n  element.style[dimension] = direction === 'show' ? maxSize : '0px';\n  return () => {\n    setInitialClasses();\n    classList.remove('collapsing');\n    element.style[dimension] = '';\n  };\n};\n\n/**\n * A configuration service for the [NgbCollapse](#/components/collapse/api#NgbCollapse) component.\n *\n * You can inject this service, typically in your root component, and customize its properties\n * to provide default values for all collapses used in the application.\n */\nlet NgbCollapseConfig = /*#__PURE__*/(() => {\n  class NgbCollapseConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.horizontal = false;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbCollapseConfig_Factory(t) {\n      return new (t || NgbCollapseConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCollapseConfig,\n      factory: NgbCollapseConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbCollapseConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive to provide a simple way of hiding and showing elements on the\n * page.\n */\nlet NgbCollapse = /*#__PURE__*/(() => {\n  class NgbCollapse {\n    constructor() {\n      this._config = inject(NgbCollapseConfig);\n      this._element = inject(ElementRef);\n      this._zone = inject(NgZone);\n      /**\n       * If `true`, collapse will be animated.\n       *\n       * Animation is triggered only when clicked on triggering element\n       * or via the `.toggle()` function\n       *\n       * @since 8.0.0\n       */\n      this.animation = this._config.animation;\n      /**\n       * Flag used to track if the collapse setter is invoked during initialization\n       * or not. This distinction is made in order to avoid running the transition during initialization.\n       */\n      this._afterInit = false;\n      this._isCollapsed = false;\n      this.ngbCollapseChange = new EventEmitter();\n      /**\n       * If `true`, will collapse horizontally.\n       *\n       * @since 13.1.0\n       */\n      this.horizontal = this._config.horizontal;\n      /**\n       * An event emitted when the collapse element is shown, after the transition.\n       * It has no payload.\n       *\n       * @since 8.0.0\n       */\n      this.shown = new EventEmitter();\n      /**\n       * An event emitted when the collapse element is hidden, after the transition.\n       * It has no payload.\n       *\n       * @since 8.0.0\n       */\n      this.hidden = new EventEmitter();\n    }\n    /**\n     * If `true`, will collapse the element or show it otherwise.\n     */\n    set collapsed(isCollapsed) {\n      if (this._isCollapsed !== isCollapsed) {\n        this._isCollapsed = isCollapsed;\n        if (this._afterInit) {\n          this._runTransitionWithEvents(isCollapsed, this.animation);\n        }\n      }\n    }\n    ngOnInit() {\n      this._runTransition(this._isCollapsed, false);\n      this._afterInit = true;\n    }\n    /**\n     * Triggers collapsing programmatically.\n     *\n     * If there is a collapsing transition running already, it will be reversed.\n     * If the animations are turned off this happens synchronously.\n     *\n     * @since 8.0.0\n     */\n    toggle(open = this._isCollapsed) {\n      this.collapsed = !open;\n      this.ngbCollapseChange.next(this._isCollapsed);\n    }\n    _runTransition(collapsed, animation) {\n      return ngbRunTransition(this._zone, this._element.nativeElement, ngbCollapsingTransition, {\n        animation,\n        runningTransition: 'stop',\n        context: {\n          direction: collapsed ? 'hide' : 'show',\n          dimension: this.horizontal ? 'width' : 'height'\n        }\n      });\n    }\n    _runTransitionWithEvents(collapsed, animation) {\n      this._runTransition(collapsed, animation).subscribe(() => {\n        if (collapsed) {\n          this.hidden.emit();\n        } else {\n          this.shown.emit();\n        }\n      });\n    }\n    static #_ = this.ɵfac = function NgbCollapse_Factory(t) {\n      return new (t || NgbCollapse)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbCollapse,\n      selectors: [[\"\", \"ngbCollapse\", \"\"]],\n      hostVars: 2,\n      hostBindings: function NgbCollapse_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"collapse-horizontal\", ctx.horizontal);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        collapsed: [i0.ɵɵInputFlags.None, \"ngbCollapse\", \"collapsed\"],\n        horizontal: \"horizontal\"\n      },\n      outputs: {\n        ngbCollapseChange: \"ngbCollapseChange\",\n        shown: \"shown\",\n        hidden: \"hidden\"\n      },\n      exportAs: [\"ngbCollapse\"],\n      standalone: true\n    });\n  }\n  return NgbCollapse;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId$3 = 0;\n/**\n * A directive that wraps the content of an accordion item's collapsible body.\n *\n * The actual content is provided in a child `ng-template` element.\n * Depending on the state of the accordion, the template will be either inserted or removed from the DOM.\n *\n * @since 14.1.0\n */\nlet NgbAccordionBody = /*#__PURE__*/(() => {\n  class NgbAccordionBody {\n    constructor() {\n      this._vcr = inject(ViewContainerRef);\n      this._element = inject(ElementRef).nativeElement;\n      this._item = inject(NgbAccordionItem);\n      this._viewRef = null;\n    }\n    ngAfterContentChecked() {\n      if (this._bodyTpl) {\n        if (this._item._shouldBeInDOM) {\n          this._createViewIfNotExists();\n        } else {\n          this._destroyViewIfExists();\n        }\n      }\n    }\n    ngOnDestroy() {\n      this._destroyViewIfExists();\n    }\n    _destroyViewIfExists() {\n      if (this._viewRef) {\n        this._viewRef.destroy();\n        this._viewRef = null;\n      }\n    }\n    _createViewIfNotExists() {\n      if (!this._viewRef) {\n        this._viewRef = this._vcr.createEmbeddedView(this._bodyTpl);\n        this._viewRef.detectChanges();\n        for (const node of this._viewRef.rootNodes) {\n          this._element.appendChild(node);\n        }\n      }\n    }\n    static #_ = this.ɵfac = function NgbAccordionBody_Factory(t) {\n      return new (t || NgbAccordionBody)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbAccordionBody,\n      selectors: [[\"\", \"ngbAccordionBody\", \"\"]],\n      contentQueries: function NgbAccordionBody_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, TemplateRef, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._bodyTpl = _t.first);\n        }\n      },\n      hostVars: 2,\n      hostBindings: function NgbAccordionBody_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"accordion-body\", true);\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbAccordionBody;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that wraps the collapsible item's content of the accordion.\n *\n * Internally it reuses the [`NgbCollapse` directive](#/components/collapse)\n *\n * @since 14.1.0\n */\nlet NgbAccordionCollapse = /*#__PURE__*/(() => {\n  class NgbAccordionCollapse {\n    constructor() {\n      this.item = inject(NgbAccordionItem);\n      this.ngbCollapse = inject(NgbCollapse);\n    }\n    static #_ = this.ɵfac = function NgbAccordionCollapse_Factory(t) {\n      return new (t || NgbAccordionCollapse)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbAccordionCollapse,\n      selectors: [[\"\", \"ngbAccordionCollapse\", \"\"]],\n      hostAttrs: [\"role\", \"region\"],\n      hostVars: 4,\n      hostBindings: function NgbAccordionCollapse_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.item.collapseId);\n          i0.ɵɵattribute(\"aria-labelledby\", ctx.item.toggleId);\n          i0.ɵɵclassProp(\"accordion-collapse\", true);\n        }\n      },\n      exportAs: [\"ngbAccordionCollapse\"],\n      standalone: true,\n      features: [i0.ɵɵHostDirectivesFeature([NgbCollapse])]\n    });\n  }\n  return NgbAccordionCollapse;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to put on a toggling element inside the accordion item's header.\n * It will register click handlers that toggle the associated panel and will handle accessibility attributes.\n *\n * This directive is used internally by the [`NgbAccordionButton` directive](#/components/accordion/api#NgbAccordionButton).\n *\n * @since 14.1.0\n */\nlet NgbAccordionToggle = /*#__PURE__*/(() => {\n  class NgbAccordionToggle {\n    constructor() {\n      this.item = inject(NgbAccordionItem);\n      this.accordion = inject(NgbAccordionDirective);\n    }\n    static #_ = this.ɵfac = function NgbAccordionToggle_Factory(t) {\n      return new (t || NgbAccordionToggle)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbAccordionToggle,\n      selectors: [[\"\", \"ngbAccordionToggle\", \"\"]],\n      hostVars: 5,\n      hostBindings: function NgbAccordionToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function NgbAccordionToggle_click_HostBindingHandler() {\n            return !ctx.item.disabled && ctx.accordion.toggle(ctx.item.id);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.item.toggleId);\n          i0.ɵɵattribute(\"aria-controls\", ctx.item.collapseId)(\"aria-expanded\", !ctx.item.collapsed);\n          i0.ɵɵclassProp(\"collapsed\", ctx.item.collapsed);\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbAccordionToggle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to put on a button element inside an accordion item's header.\n *\n * If you want a custom markup for the header, you can also use the [`NgbAccordionToggle` directive](#/components/accordion/api#NgbAccordionToggle).\n *\n * @since 14.1.0\n */\nlet NgbAccordionButton = /*#__PURE__*/(() => {\n  class NgbAccordionButton {\n    constructor() {\n      this.item = inject(NgbAccordionItem);\n    }\n    static #_ = this.ɵfac = function NgbAccordionButton_Factory(t) {\n      return new (t || NgbAccordionButton)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbAccordionButton,\n      selectors: [[\"button\", \"ngbAccordionButton\", \"\"]],\n      hostAttrs: [\"type\", \"button\"],\n      hostVars: 3,\n      hostBindings: function NgbAccordionButton_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"disabled\", ctx.item.disabled);\n          i0.ɵɵclassProp(\"accordion-button\", true);\n        }\n      },\n      standalone: true,\n      features: [i0.ɵɵHostDirectivesFeature([NgbAccordionToggle])]\n    });\n  }\n  return NgbAccordionButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that wraps an accordion item's header.\n *\n * @since 14.1.0\n */\nlet NgbAccordionHeader = /*#__PURE__*/(() => {\n  class NgbAccordionHeader {\n    constructor() {\n      this.item = inject(NgbAccordionItem);\n    }\n    static #_ = this.ɵfac = function NgbAccordionHeader_Factory(t) {\n      return new (t || NgbAccordionHeader)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbAccordionHeader,\n      selectors: [[\"\", \"ngbAccordionHeader\", \"\"]],\n      hostAttrs: [\"role\", \"heading\"],\n      hostVars: 4,\n      hostBindings: function NgbAccordionHeader_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"accordion-header\", true)(\"collapsed\", ctx.item.collapsed);\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbAccordionHeader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that wraps an accordion item: a toggleable header + body that collapses.\n *\n * You can get hold of the `NgbAccordionItem` instance in the template with `#item=\"ngbAccordionItem\"`.\n * It allows to check if the item is collapsed or not, toggle the collapse state, etc.\n *\n * Every accordion item has a string ID that is automatically generated in the `ngb-accordion-item-XX` format, unless provided explicitly.\n *\n * @since 14.1.0\n */\nlet NgbAccordionItem = /*#__PURE__*/(() => {\n  class NgbAccordionItem {\n    constructor() {\n      this._accordion = inject(NgbAccordionDirective);\n      this._cd = inject(ChangeDetectorRef);\n      this._destroyRef = inject(DestroyRef);\n      this._collapsed = true;\n      this._id = `ngb-accordion-item-${nextId$3++}`;\n      this._collapseAnimationRunning = false;\n      /**\n       * If `true`, the accordion item will be disabled.\n       * It won't react to user's clicks, but still will be toggelable programmatically.\n       */\n      this.disabled = false;\n      /**\n       * Event emitted before the expanding animation starts. It has no payload.\n       *\n       * @since 15.1.0\n       */\n      this.show = new EventEmitter();\n      /**\n       * Event emitted when the expanding animation is finished. It has no payload.\n       */\n      this.shown = new EventEmitter();\n      /**\n       * Event emitted before the collapsing animation starts. It has no payload.\n       *\n       * @since 15.1.0\n       */\n      this.hide = new EventEmitter();\n      /**\n       * Event emitted when the collapsing animation is finished and before the content is removed from DOM.\n       * It has no payload.\n       */\n      this.hidden = new EventEmitter();\n    }\n    /**\n     * Sets the custom ID of the accordion item. It must be unique for the document.\n     *\n     * @param id The ID of the accordion item, must be a non-empty string\n     */\n    set id(id) {\n      if (isString(id) && id !== '') {\n        this._id = id;\n      }\n    }\n    /**\n     * If `true`, the content of the accordion item's body will be removed from the DOM. It will be just hidden otherwise.\n     *\n     * This property can also be set up on the parent [`NgbAccordion` directive](#/components/accordion/api#NgbAccordionDirective).\n     */\n    set destroyOnHide(destroyOnHide) {\n      this._destroyOnHide = destroyOnHide;\n    }\n    get destroyOnHide() {\n      return this._destroyOnHide === undefined ? this._accordion.destroyOnHide : this._destroyOnHide;\n    }\n    /**\n     *\tIf `true`, the accordion item will be collapsed. Otherwise, it will be expanded.\n     *\n     * @param collapsed New state of the accordion item.\n     */\n    set collapsed(collapsed) {\n      if (collapsed) {\n        this.collapse();\n      } else {\n        this.expand();\n      }\n    }\n    get collapsed() {\n      return this._collapsed;\n    }\n    get id() {\n      return `${this._id}`;\n    }\n    get toggleId() {\n      return `${this.id}-toggle`;\n    }\n    get collapseId() {\n      return `${this.id}-collapse`;\n    }\n    get _shouldBeInDOM() {\n      return !this.collapsed || this._collapseAnimationRunning || !this.destroyOnHide;\n    }\n    ngAfterContentInit() {\n      const {\n        ngbCollapse\n      } = this._collapse;\n      // we need to disable the animation for the first init\n      ngbCollapse.animation = false;\n      ngbCollapse.collapsed = this.collapsed;\n      // we set the animation to the default of the accordion\n      ngbCollapse.animation = this._accordion.animation;\n      // event forwarding from 'ngbCollapse' to 'ngbAccordion'\n      ngbCollapse.hidden.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(() => {\n        // when the animation finishes we can remove the template from DOM\n        this._collapseAnimationRunning = false;\n        this.hidden.emit();\n        this._accordion.hidden.emit(this.id);\n      });\n      ngbCollapse.shown.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(() => {\n        this.shown.emit();\n        this._accordion.shown.emit(this.id);\n      });\n    }\n    /**\n     * Toggles an accordion item.\n     */\n    toggle() {\n      this.collapsed = !this.collapsed;\n    }\n    /**\n     * Expands an accordion item.\n     */\n    expand() {\n      if (this.collapsed) {\n        // checking if accordion allows to expand the panel in respect to 'closeOthers' flag\n        if (!this._accordion._ensureCanExpand(this)) {\n          return;\n        }\n        this._collapsed = false;\n        // need if the accordion is used inside a component having OnPush change detection strategy\n        this._cd.markForCheck();\n        // we need force CD to get template into DOM before starting animation to calculate its height correctly\n        // this will synchronously put the item body into DOM, because `this._collapsed` was flipped to `false`\n        this._cd.detectChanges();\n        // firing events before starting animations\n        this.show.emit();\n        this._accordion.show.emit(this.id);\n        // we also need to make sure 'animation' flag is up-to- date\n        this._collapse.ngbCollapse.animation = this._accordion.animation;\n        this._collapse.ngbCollapse.collapsed = false;\n      }\n    }\n    /**\n     * Collapses an accordion item.\n     */\n    collapse() {\n      if (!this.collapsed) {\n        this._collapsed = true;\n        this._collapseAnimationRunning = true;\n        // need if the accordion is used inside a component having OnPush change detection strategy\n        this._cd.markForCheck();\n        // firing events before starting animations\n        this.hide.emit();\n        this._accordion.hide.emit(this.id);\n        // we also need to make sure 'animation' flag is up-to- date\n        this._collapse.ngbCollapse.animation = this._accordion.animation;\n        this._collapse.ngbCollapse.collapsed = true;\n      }\n    }\n    static #_ = this.ɵfac = function NgbAccordionItem_Factory(t) {\n      return new (t || NgbAccordionItem)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbAccordionItem,\n      selectors: [[\"\", \"ngbAccordionItem\", \"\"]],\n      contentQueries: function NgbAccordionItem_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbAccordionCollapse, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._collapse = _t.first);\n        }\n      },\n      hostVars: 3,\n      hostBindings: function NgbAccordionItem_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.id);\n          i0.ɵɵclassProp(\"accordion-item\", true);\n        }\n      },\n      inputs: {\n        id: [i0.ɵɵInputFlags.None, \"ngbAccordionItem\", \"id\"],\n        destroyOnHide: \"destroyOnHide\",\n        disabled: \"disabled\",\n        collapsed: \"collapsed\"\n      },\n      outputs: {\n        show: \"show\",\n        shown: \"shown\",\n        hide: \"hide\",\n        hidden: \"hidden\"\n      },\n      exportAs: [\"ngbAccordionItem\"],\n      standalone: true\n    });\n  }\n  return NgbAccordionItem;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Accordion is a stack of cards that have a header and collapsible body.\n *\n * This directive is a container for these items and provides an API to handle them.\n *\n * @since 14.1.0\n */\nlet NgbAccordionDirective = /*#__PURE__*/(() => {\n  class NgbAccordionDirective {\n    constructor() {\n      this._config = inject(NgbAccordionConfig);\n      this._anItemWasAlreadyExpandedDuringInitialisation = false;\n      /**\n       * If `true`, accordion will be animated.\n       */\n      this.animation = this._config.animation;\n      /**\n       * If `true`, only one item at the time can stay open.\n       */\n      this.closeOthers = this._config.closeOthers;\n      /**\n       * If `true`, the content of the accordion items body will be removed from the DOM. It will be just hidden otherwise.\n       *\n       * This property can be overwritten at the [`NgbAccordionItem`](#/components/accordion/api#NgbAccordionItem) level\n       */\n      this.destroyOnHide = this._config.destroyOnHide;\n      /**\n       * Event emitted before expanding animation starts. The payload is the id of shown accordion item.\n       *\n       * @since 15.1.0\n       */\n      this.show = new EventEmitter();\n      /**\n       * Event emitted when the expanding animation is finished. The payload is the id of shown accordion item.\n       */\n      this.shown = new EventEmitter();\n      /**\n       * Event emitted before the collapsing animation starts. The payload is the id of hidden accordion item.\n       *\n       * @since 15.1.0\n       */\n      this.hide = new EventEmitter();\n      /**\n       * Event emitted when the collapsing animation is finished and before the content is removed from DOM.\n       * The payload is the id of hidden accordion item.\n       */\n      this.hidden = new EventEmitter();\n    }\n    /**\n     * Toggles an item with the given id.\n     *\n     * It will toggle an item, even if it is disabled.\n     *\n     * @param itemId The id of the item to toggle.\n     */\n    toggle(itemId) {\n      this._getItem(itemId)?.toggle();\n    }\n    /**\n     * Expands an item with the given id.\n     *\n     * If `closeOthers` is `true`, it will collapse other panels.\n     *\n     * @param itemId The id of the item to expand.\n     */\n    expand(itemId) {\n      this._getItem(itemId)?.expand();\n    }\n    /**\n     * Expands all items.\n     *\n     * If `closeOthers` is `true` and all items are closed, it will open the first one. Otherwise, it will keep the opened one.\n     */\n    expandAll() {\n      if (this._items) {\n        if (this.closeOthers) {\n          // we check if there is an item open and if it is not we can expand the first item\n          // (otherwise we toggle nothing)\n          if (!this._items.find(item => !item.collapsed)) {\n            this._items.first.expand();\n          }\n        } else {\n          this._items.forEach(item => item.expand());\n        }\n      }\n    }\n    /**\n     * Collapses an item with the given id.\n     *\n     * Has no effect if the `itemId` does not correspond to any item.\n     *\n     * @param itemId The id of the item to collapse.\n     */\n    collapse(itemId) {\n      this._getItem(itemId)?.collapse();\n    }\n    /**\n     * Collapses all items.\n     */\n    collapseAll() {\n      this._items?.forEach(item => item.collapse());\n    }\n    /**\n     * Checks if an item with the given id is expanded.\n     *\n     * If the `itemId` does not correspond to any item, it returns `false`.\n     *\n     * @param itemId The id of the item to check.\n     */\n    isExpanded(itemId) {\n      const item = this._getItem(itemId);\n      return item ? !item.collapsed : false;\n    }\n    /**\n     * It checks, if the item can be expanded in the current state of the accordion.\n     * With `closeOthers` there can be only one expanded item at a time.\n     *\n     * @internal\n     */\n    _ensureCanExpand(toExpand) {\n      if (!this.closeOthers) {\n        return true;\n      }\n      // special case during the initialization of the [collapse]=\"false\" inputs\n      // `this._items` QueryList is not yet initialized, but we need to ensure only one item can be expanded at a time\n      if (!this._items) {\n        if (!this._anItemWasAlreadyExpandedDuringInitialisation) {\n          this._anItemWasAlreadyExpandedDuringInitialisation = true;\n          return true;\n        }\n        return false;\n      }\n      // if there is an expanded item, we need to collapse it first\n      this._items.find(item => !item.collapsed && toExpand !== item)?.collapse();\n      return true;\n    }\n    _getItem(itemId) {\n      return this._items?.find(item => item.id === itemId);\n    }\n    static #_ = this.ɵfac = function NgbAccordionDirective_Factory(t) {\n      return new (t || NgbAccordionDirective)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbAccordionDirective,\n      selectors: [[\"\", \"ngbAccordion\", \"\"]],\n      contentQueries: function NgbAccordionDirective_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbAccordionItem, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._items = _t);\n        }\n      },\n      hostVars: 2,\n      hostBindings: function NgbAccordionDirective_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"accordion\", true);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        closeOthers: \"closeOthers\",\n        destroyOnHide: \"destroyOnHide\"\n      },\n      outputs: {\n        show: \"show\",\n        shown: \"shown\",\n        hide: \"hide\",\n        hidden: \"hidden\"\n      },\n      exportAs: [\"ngbAccordion\"],\n      standalone: true\n    });\n  }\n  return NgbAccordionDirective;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NGB_ACCORDION_DIRECTIVES = [NgbAccordionButton, NgbAccordionDirective, NgbAccordionItem, NgbAccordionHeader, NgbAccordionToggle, NgbAccordionBody, NgbAccordionCollapse];\nlet NgbAccordionModule = /*#__PURE__*/(() => {\n  class NgbAccordionModule {\n    static #_ = this.ɵfac = function NgbAccordionModule_Factory(t) {\n      return new (t || NgbAccordionModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbAccordionModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbAccordionModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [NgbAlert](#/components/alert/api#NgbAlert) component.\n *\n * You can inject this service, typically in your root component, and customize its properties\n * to provide default values for all alerts used in the application.\n */\nlet NgbAlertConfig = /*#__PURE__*/(() => {\n  class NgbAlertConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.dismissible = true;\n      this.type = 'warning';\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbAlertConfig_Factory(t) {\n      return new (t || NgbAlertConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbAlertConfig,\n      factory: NgbAlertConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbAlertConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ngbAlertFadingTransition = ({\n  classList\n}) => {\n  classList.remove('show');\n};\n\n/**\n * Alert is a component to provide contextual feedback messages for user.\n *\n * It supports several alert types and can be dismissed.\n */\nlet NgbAlert = /*#__PURE__*/(() => {\n  class NgbAlert {\n    constructor() {\n      this._config = inject(NgbAlertConfig);\n      this._elementRef = inject(ElementRef);\n      this._zone = inject(NgZone);\n      /**\n       * If `true`, alert closing will be animated.\n       *\n       * Animation is triggered only when clicked on the close button (×)\n       * or via the `.close()` function\n       *\n       * @since 8.0.0\n       */\n      this.animation = this._config.animation;\n      /**\n       * If `true`, alert can be dismissed by the user.\n       *\n       * The close button (×) will be displayed and you can be notified\n       * of the event with the `(closed)` output.\n       */\n      this.dismissible = this._config.dismissible;\n      /**\n       * Type of the alert.\n       *\n       * Bootstrap provides styles for the following types: `'success'`, `'info'`, `'warning'`, `'danger'`, `'primary'`,\n       * `'secondary'`, `'light'` and `'dark'`.\n       */\n      this.type = this._config.type;\n      /**\n       * An event emitted when the close button is clicked. It has no payload and only relevant for dismissible alerts.\n       *\n       * @since 8.0.0\n       */\n      this.closed = new EventEmitter();\n    }\n    /**\n     * Triggers alert closing programmatically (same as clicking on the close button (×)).\n     *\n     * The returned observable will emit and be completed once the closing transition has finished.\n     * If the animations are turned off this happens synchronously.\n     *\n     * Alternatively you could listen or subscribe to the `(closed)` output\n     *\n     * @since 8.0.0\n     */\n    close() {\n      const transition = ngbRunTransition(this._zone, this._elementRef.nativeElement, ngbAlertFadingTransition, {\n        animation: this.animation,\n        runningTransition: 'continue'\n      });\n      transition.subscribe(() => this.closed.emit());\n      return transition;\n    }\n    static #_ = this.ɵfac = function NgbAlert_Factory(t) {\n      return new (t || NgbAlert)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbAlert,\n      selectors: [[\"ngb-alert\"]],\n      hostAttrs: [\"role\", \"alert\"],\n      hostVars: 6,\n      hostBindings: function NgbAlert_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassMap(\"alert show\" + (ctx.type ? \" alert-\" + ctx.type : \"\"));\n          i0.ɵɵclassProp(\"fade\", ctx.animation)(\"alert-dismissible\", ctx.dismissible);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        dismissible: \"dismissible\",\n        type: \"type\"\n      },\n      outputs: {\n        closed: \"closed\"\n      },\n      exportAs: [\"ngbAlert\"],\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 2,\n      vars: 1,\n      consts: () => {\n        let i18n_0;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_0 = goog.getMsg(\"Close\");\n          i18n_0 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_0;\n        } else {\n          i18n_0 = $localize`:@@ngb.alert.close:Close`;\n        }\n        return [[\"type\", \"button\", \"class\", \"btn-close\", \"aria-label\", i18n_0], [\"type\", \"button\", \"aria-label\", i18n_0, 1, \"btn-close\", 3, \"click\"]];\n      },\n      template: function NgbAlert_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n          i0.ɵɵtemplate(1, NgbAlert_Conditional_1_Template, 1, 0, \"button\", 0);\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(1, ctx.dismissible ? 1 : -1);\n        }\n      },\n      styles: [\"ngb-alert{display:block}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbAlert;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbAlertModule = /*#__PURE__*/(() => {\n  class NgbAlertModule {\n    static #_ = this.ɵfac = function NgbAlertModule_Factory(t) {\n      return new (t || NgbAlertModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbAlertModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbAlertModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [NgbCarousel](#/components/carousel/api#NgbCarousel) component.\n *\n * You can inject this service, typically in your root component, and customize its properties\n * to provide default values for all carousels used in the application.\n */\nlet NgbCarouselConfig = /*#__PURE__*/(() => {\n  class NgbCarouselConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.interval = 5000;\n      this.wrap = true;\n      this.keyboard = true;\n      this.pauseOnHover = true;\n      this.pauseOnFocus = true;\n      this.showNavigationArrows = true;\n      this.showNavigationIndicators = true;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbCarouselConfig_Factory(t) {\n      return new (t || NgbCarouselConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCarouselConfig,\n      factory: NgbCarouselConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbCarouselConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Defines the carousel slide transition direction.\n */\nvar NgbSlideEventDirection = /*#__PURE__*/function (NgbSlideEventDirection) {\n  NgbSlideEventDirection[\"START\"] = \"start\";\n  NgbSlideEventDirection[\"END\"] = \"end\";\n  return NgbSlideEventDirection;\n}(NgbSlideEventDirection || {});\nconst isBeingAnimated = ({\n  classList\n}) => {\n  return classList.contains('carousel-item-start') || classList.contains('carousel-item-end');\n};\nconst removeDirectionClasses = classList => {\n  classList.remove('carousel-item-start');\n  classList.remove('carousel-item-end');\n};\nconst removeClasses = classList => {\n  removeDirectionClasses(classList);\n  classList.remove('carousel-item-prev');\n  classList.remove('carousel-item-next');\n};\nconst ngbCarouselTransitionIn = (element, animation, {\n  direction\n}) => {\n  const {\n    classList\n  } = element;\n  if (!animation) {\n    removeDirectionClasses(classList);\n    removeClasses(classList);\n    classList.add('active');\n    return;\n  }\n  if (isBeingAnimated(element)) {\n    // Revert the transition\n    removeDirectionClasses(classList);\n  } else {\n    // For the 'in' transition, a 'pre-class' is applied to the element to ensure its visibility\n    classList.add('carousel-item-' + (direction === NgbSlideEventDirection.START ? 'next' : 'prev'));\n    reflow(element);\n    classList.add('carousel-item-' + direction);\n  }\n  return () => {\n    removeClasses(classList);\n    classList.add('active');\n  };\n};\nconst ngbCarouselTransitionOut = (element, animation, {\n  direction\n}) => {\n  const {\n    classList\n  } = element;\n  if (!animation) {\n    removeDirectionClasses(classList);\n    removeClasses(classList);\n    classList.remove('active');\n    return;\n  }\n  //  direction is left or right, depending on the way the slide goes out.\n  if (isBeingAnimated(element)) {\n    // Revert the transition\n    removeDirectionClasses(classList);\n  } else {\n    classList.add('carousel-item-' + direction);\n  }\n  return () => {\n    removeClasses(classList);\n    classList.remove('active');\n  };\n};\nlet nextId$2 = 0;\nlet carouselId = 0;\n/**\n * A directive that wraps the individual carousel slide.\n */\nlet NgbSlide = /*#__PURE__*/(() => {\n  class NgbSlide {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n      /**\n       * Slide id that must be unique for the entire document.\n       *\n       * If not provided, will be generated in the `ngb-slide-xx` format.\n       */\n      this.id = `ngb-slide-${nextId$2++}`;\n      /**\n       * An event emitted when the slide transition is finished\n       *\n       * @since 8.0.0\n       */\n      this.slid = new EventEmitter();\n    }\n    static #_ = this.ɵfac = function NgbSlide_Factory(t) {\n      return new (t || NgbSlide)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbSlide,\n      selectors: [[\"ng-template\", \"ngbSlide\", \"\"]],\n      inputs: {\n        id: \"id\"\n      },\n      outputs: {\n        slid: \"slid\"\n      },\n      standalone: true\n    });\n  }\n  return NgbSlide;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Carousel is a component to easily create and control slideshows.\n *\n * Allows to set intervals, change the way user interacts with the slides and provides a programmatic API.\n */\nlet NgbCarousel = /*#__PURE__*/(() => {\n  class NgbCarousel {\n    constructor() {\n      this.NgbSlideEventSource = NgbSlideEventSource;\n      this._config = inject(NgbCarouselConfig);\n      this._platformId = inject(PLATFORM_ID);\n      this._ngZone = inject(NgZone);\n      this._cd = inject(ChangeDetectorRef);\n      this._container = inject(ElementRef);\n      this._destroyRef = inject(DestroyRef);\n      this._interval$ = new BehaviorSubject(this._config.interval);\n      this._mouseHover$ = new BehaviorSubject(false);\n      this._focused$ = new BehaviorSubject(false);\n      this._pauseOnHover$ = new BehaviorSubject(this._config.pauseOnHover);\n      this._pauseOnFocus$ = new BehaviorSubject(this._config.pauseOnFocus);\n      this._pause$ = new BehaviorSubject(false);\n      this._wrap$ = new BehaviorSubject(this._config.wrap);\n      this.id = `ngb-carousel-${carouselId++}`;\n      /**\n       * A flag to enable/disable the animations.\n       *\n       * @since 8.0.0\n       */\n      this.animation = this._config.animation;\n      /**\n       * If `true`, allows to interact with carousel using keyboard 'arrow left' and 'arrow right'.\n       */\n      this.keyboard = this._config.keyboard;\n      /**\n       * If `true`, 'previous' and 'next' navigation arrows will be visible on the slide.\n       *\n       * @since 2.2.0\n       */\n      this.showNavigationArrows = this._config.showNavigationArrows;\n      /**\n       * If `true`, navigation indicators at the bottom of the slide will be visible.\n       *\n       * @since 2.2.0\n       */\n      this.showNavigationIndicators = this._config.showNavigationIndicators;\n      /**\n       * An event emitted just before the slide transition starts.\n       *\n       * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.\n       */\n      this.slide = new EventEmitter();\n      /**\n       * An event emitted right after the slide transition is completed.\n       *\n       * See [`NgbSlideEvent`](#/components/carousel/api#NgbSlideEvent) for payload details.\n       *\n       * @since 8.0.0\n       */\n      this.slid = new EventEmitter();\n      /*\n       * Keep the ids of the panels currently transitionning\n       * in order to allow only the transition revertion\n       */\n      this._transitionIds = null;\n    }\n    /**\n     * Time in milliseconds before the next slide is shown.\n     */\n    set interval(value) {\n      this._interval$.next(value);\n    }\n    get interval() {\n      return this._interval$.value;\n    }\n    /**\n     * If `true`, will 'wrap' the carousel by switching from the last slide back to the first.\n     */\n    set wrap(value) {\n      this._wrap$.next(value);\n    }\n    get wrap() {\n      return this._wrap$.value;\n    }\n    /**\n     * If `true`, will pause slide switching when mouse cursor hovers the slide.\n     *\n     * @since 2.2.0\n     */\n    set pauseOnHover(value) {\n      this._pauseOnHover$.next(value);\n    }\n    get pauseOnHover() {\n      return this._pauseOnHover$.value;\n    }\n    /**\n     * If `true`, will pause slide switching when the focus is inside the carousel.\n     */\n    set pauseOnFocus(value) {\n      this._pauseOnFocus$.next(value);\n    }\n    get pauseOnFocus() {\n      return this._pauseOnFocus$.value;\n    }\n    set mouseHover(value) {\n      this._mouseHover$.next(value);\n    }\n    get mouseHover() {\n      return this._mouseHover$.value;\n    }\n    set focused(value) {\n      this._focused$.next(value);\n    }\n    get focused() {\n      return this._focused$.value;\n    }\n    arrowLeft() {\n      this.focus();\n      this.prev(NgbSlideEventSource.ARROW_LEFT);\n    }\n    arrowRight() {\n      this.focus();\n      this.next(NgbSlideEventSource.ARROW_RIGHT);\n    }\n    ngAfterContentInit() {\n      // setInterval() doesn't play well with SSR and protractor,\n      // so we should run it in the browser and outside Angular\n      if (isPlatformBrowser(this._platformId)) {\n        this._ngZone.runOutsideAngular(() => {\n          const hasNextSlide$ = combineLatest([this.slide.pipe(map(slideEvent => slideEvent.current), startWith(this.activeId)), this._wrap$, this.slides.changes.pipe(startWith(null))]).pipe(map(([currentSlideId, wrap]) => {\n            const slideArr = this.slides.toArray();\n            const currentSlideIdx = this._getSlideIdxById(currentSlideId);\n            return wrap ? slideArr.length > 1 : currentSlideIdx < slideArr.length - 1;\n          }), distinctUntilChanged());\n          combineLatest([this._pause$, this._pauseOnHover$, this._mouseHover$, this._pauseOnFocus$, this._focused$, this._interval$, hasNextSlide$]).pipe(map(([pause, pauseOnHover, mouseHover, pauseOnFocus, focused, interval, hasNextSlide]) => pause || pauseOnHover && mouseHover || pauseOnFocus && focused || !hasNextSlide ? 0 : interval), distinctUntilChanged(), switchMap(interval => interval > 0 ? timer(interval, interval) : NEVER), takeUntilDestroyed(this._destroyRef)).subscribe(() => this._ngZone.run(() => this.next(NgbSlideEventSource.TIMER)));\n        });\n      }\n      this.slides.changes.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(() => {\n        this._transitionIds?.forEach(id => ngbCompleteTransition(this._getSlideElement(id)));\n        this._transitionIds = null;\n        this._cd.markForCheck();\n        // The following code need to be done asynchronously, after the dom becomes stable,\n        // otherwise all changes will be undone.\n        this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n          for (const {\n            id\n          } of this.slides) {\n            const element = this._getSlideElement(id);\n            if (id === this.activeId) {\n              element.classList.add('active');\n            } else {\n              element.classList.remove('active');\n            }\n          }\n        });\n      });\n    }\n    ngAfterContentChecked() {\n      let activeSlide = this._getSlideById(this.activeId);\n      this.activeId = activeSlide ? activeSlide.id : this.slides.length ? this.slides.first.id : '';\n    }\n    ngAfterViewInit() {\n      // Initialize the 'active' class (not managed by the template)\n      if (this.activeId) {\n        const element = this._getSlideElement(this.activeId);\n        if (element) {\n          element.classList.add('active');\n        }\n      }\n    }\n    /**\n     * Navigates to a slide with the specified identifier.\n     */\n    select(slideId, source) {\n      this._cycleToSelected(slideId, this._getSlideEventDirection(this.activeId, slideId), source);\n    }\n    /**\n     * Navigates to the previous slide.\n     */\n    prev(source) {\n      this._cycleToSelected(this._getPrevSlide(this.activeId), NgbSlideEventDirection.END, source);\n    }\n    /**\n     * Navigates to the next slide.\n     */\n    next(source) {\n      this._cycleToSelected(this._getNextSlide(this.activeId), NgbSlideEventDirection.START, source);\n    }\n    /**\n     * Pauses cycling through the slides.\n     */\n    pause() {\n      this._pause$.next(true);\n    }\n    /**\n     * Restarts cycling through the slides from start to end.\n     */\n    cycle() {\n      this._pause$.next(false);\n    }\n    /**\n     * Set the focus on the carousel.\n     */\n    focus() {\n      this._container.nativeElement.focus();\n    }\n    _cycleToSelected(slideIdx, direction, source) {\n      const transitionIds = this._transitionIds;\n      if (transitionIds && (transitionIds[0] !== slideIdx || transitionIds[1] !== this.activeId)) {\n        // Revert prevented\n        return;\n      }\n      let selectedSlide = this._getSlideById(slideIdx);\n      if (selectedSlide && selectedSlide.id !== this.activeId) {\n        this._transitionIds = [this.activeId, slideIdx];\n        this.slide.emit({\n          prev: this.activeId,\n          current: selectedSlide.id,\n          direction: direction,\n          paused: this._pause$.value,\n          source\n        });\n        const options = {\n          animation: this.animation,\n          runningTransition: 'stop',\n          context: {\n            direction\n          }\n        };\n        const transitions = [];\n        const activeSlide = this._getSlideById(this.activeId);\n        if (activeSlide) {\n          const activeSlideTransition = ngbRunTransition(this._ngZone, this._getSlideElement(activeSlide.id), ngbCarouselTransitionOut, options);\n          activeSlideTransition.subscribe(() => {\n            activeSlide.slid.emit({\n              isShown: false,\n              direction,\n              source\n            });\n          });\n          transitions.push(activeSlideTransition);\n        }\n        const previousId = this.activeId;\n        this.activeId = selectedSlide.id;\n        const nextSlide = this._getSlideById(this.activeId);\n        const transition = ngbRunTransition(this._ngZone, this._getSlideElement(selectedSlide.id), ngbCarouselTransitionIn, options);\n        transition.subscribe(() => {\n          nextSlide?.slid.emit({\n            isShown: true,\n            direction,\n            source\n          });\n        });\n        transitions.push(transition);\n        zip(...transitions).pipe(take(1)).subscribe(() => {\n          this._transitionIds = null;\n          this.slid.emit({\n            prev: previousId,\n            current: selectedSlide.id,\n            direction: direction,\n            paused: this._pause$.value,\n            source\n          });\n        });\n      }\n      // we get here after the interval fires or any external API call like next(), prev() or select()\n      this._cd.markForCheck();\n    }\n    _getSlideEventDirection(currentActiveSlideId, nextActiveSlideId) {\n      const currentActiveSlideIdx = this._getSlideIdxById(currentActiveSlideId);\n      const nextActiveSlideIdx = this._getSlideIdxById(nextActiveSlideId);\n      return currentActiveSlideIdx > nextActiveSlideIdx ? NgbSlideEventDirection.END : NgbSlideEventDirection.START;\n    }\n    _getSlideById(slideId) {\n      return this.slides.find(slide => slide.id === slideId) || null;\n    }\n    _getSlideIdxById(slideId) {\n      const slide = this._getSlideById(slideId);\n      return slide != null ? this.slides.toArray().indexOf(slide) : -1;\n    }\n    _getNextSlide(currentSlideId) {\n      const slideArr = this.slides.toArray();\n      const currentSlideIdx = this._getSlideIdxById(currentSlideId);\n      const isLastSlide = currentSlideIdx === slideArr.length - 1;\n      return isLastSlide ? this.wrap ? slideArr[0].id : slideArr[slideArr.length - 1].id : slideArr[currentSlideIdx + 1].id;\n    }\n    _getPrevSlide(currentSlideId) {\n      const slideArr = this.slides.toArray();\n      const currentSlideIdx = this._getSlideIdxById(currentSlideId);\n      const isFirstSlide = currentSlideIdx === 0;\n      return isFirstSlide ? this.wrap ? slideArr[slideArr.length - 1].id : slideArr[0].id : slideArr[currentSlideIdx - 1].id;\n    }\n    _getSlideElement(slideId) {\n      return this._container.nativeElement.querySelector(`#slide-${slideId}`);\n    }\n    static #_ = this.ɵfac = function NgbCarousel_Factory(t) {\n      return new (t || NgbCarousel)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbCarousel,\n      selectors: [[\"ngb-carousel\"]],\n      contentQueries: function NgbCarousel_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbSlide, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slides = _t);\n        }\n      },\n      hostAttrs: [\"tabIndex\", \"0\", 1, \"carousel\", \"slide\"],\n      hostVars: 3,\n      hostBindings: function NgbCarousel_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown.arrowLeft\", function NgbCarousel_keydown_arrowLeft_HostBindingHandler() {\n            return ctx.keyboard && ctx.arrowLeft();\n          })(\"keydown.arrowRight\", function NgbCarousel_keydown_arrowRight_HostBindingHandler() {\n            return ctx.keyboard && ctx.arrowRight();\n          })(\"mouseenter\", function NgbCarousel_mouseenter_HostBindingHandler() {\n            return ctx.mouseHover = true;\n          })(\"mouseleave\", function NgbCarousel_mouseleave_HostBindingHandler() {\n            return ctx.mouseHover = false;\n          })(\"focusin\", function NgbCarousel_focusin_HostBindingHandler() {\n            return ctx.focused = true;\n          })(\"focusout\", function NgbCarousel_focusout_HostBindingHandler() {\n            return ctx.focused = false;\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-activedescendant\", \"slide-\" + ctx.activeId);\n          i0.ɵɵstyleProp(\"display\", \"block\");\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        activeId: \"activeId\",\n        interval: \"interval\",\n        wrap: \"wrap\",\n        keyboard: \"keyboard\",\n        pauseOnHover: \"pauseOnHover\",\n        pauseOnFocus: \"pauseOnFocus\",\n        showNavigationArrows: \"showNavigationArrows\",\n        showNavigationIndicators: \"showNavigationIndicators\"\n      },\n      outputs: {\n        slide: \"slide\",\n        slid: \"slid\"\n      },\n      exportAs: [\"ngbCarousel\"],\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 7,\n      vars: 3,\n      consts: () => {\n        let i18n_1;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @desc Currently selected slide number read by screen reader\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__0 = goog.getMsg(\" Slide {$interpolation} of {$interpolation_1} \", {\n            \"interpolation\": \"\\uFFFD0\\uFFFD\",\n            \"interpolation_1\": \"\\uFFFD1\\uFFFD\"\n          }, {\n            original_code: {\n              \"interpolation\": \"{{ i + 1 }}\",\n              \"interpolation_1\": \"{{ c }}\"\n            }\n          });\n          i18n_1 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__0;\n        } else {\n          i18n_1 = $localize`:Currently selected slide number read by screen reader@@ngb.carousel.slide-number: Slide ${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION: of ${\"\\uFFFD1\\uFFFD\"}:INTERPOLATION_1: `;\n        }\n        let i18n_2;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__1 = goog.getMsg(\"Previous\");\n          i18n_2 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__1;\n        } else {\n          i18n_2 = $localize`:@@ngb.carousel.previous:Previous`;\n        }\n        let i18n_3;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__2 = goog.getMsg(\"Next\");\n          i18n_3 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__2;\n        } else {\n          i18n_3 = $localize`:@@ngb.carousel.next:Next`;\n        }\n        return [[\"role\", \"tablist\", 1, \"carousel-indicators\"], [1, \"carousel-inner\"], [\"type\", \"button\", \"data-bs-target\", \"\", \"role\", \"tab\", 3, \"click\"], [\"role\", \"tabpanel\", 1, \"carousel-item\", 3, \"id\"], [1, \"visually-hidden\"], i18n_1, [3, \"ngTemplateOutlet\"], [\"type\", \"button\", 1, \"carousel-control-prev\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"carousel-control-prev-icon\"], [1, \"visually-hidden\", 3, \"id\"], i18n_2, [\"type\", \"button\", 1, \"carousel-control-next\", 3, \"click\"], [\"aria-hidden\", \"true\", 1, \"carousel-control-next-icon\"], i18n_3, [\"type\", \"button\", \"data-bs-target\", \"\", \"role\", \"tab\", 3, \"active\"], [\"class\", \"carousel-item\", \"role\", \"tabpanel\", 3, \"id\"]];\n      },\n      template: function NgbCarousel_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0);\n          i0.ɵɵrepeaterCreate(1, NgbCarousel_For_2_Template, 1, 5, \"button\", 14, i0.ɵɵrepeaterTrackByIdentity);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(3, \"div\", 1);\n          i0.ɵɵrepeaterCreate(4, NgbCarousel_For_5_Template, 4, 4, \"div\", 15, i0.ɵɵrepeaterTrackByIdentity);\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(6, NgbCarousel_Conditional_6_Template, 8, 4);\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"visually-hidden\", !ctx.showNavigationIndicators);\n          i0.ɵɵadvance();\n          i0.ɵɵrepeater(ctx.slides);\n          i0.ɵɵadvance(3);\n          i0.ɵɵrepeater(ctx.slides);\n          i0.ɵɵadvance(2);\n          i0.ɵɵconditional(6, ctx.showNavigationArrows ? 6 : -1);\n        }\n      },\n      dependencies: [NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbCarousel;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar NgbSlideEventSource = /*#__PURE__*/function (NgbSlideEventSource) {\n  NgbSlideEventSource[\"TIMER\"] = \"timer\";\n  NgbSlideEventSource[\"ARROW_LEFT\"] = \"arrowLeft\";\n  NgbSlideEventSource[\"ARROW_RIGHT\"] = \"arrowRight\";\n  NgbSlideEventSource[\"INDICATOR\"] = \"indicator\";\n  return NgbSlideEventSource;\n}(NgbSlideEventSource || {});\nlet NgbCarouselModule = /*#__PURE__*/(() => {\n  class NgbCarouselModule {\n    static #_ = this.ɵfac = function NgbCarouselModule_Factory(t) {\n      return new (t || NgbCarouselModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbCarouselModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbCarouselModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbCollapseModule = /*#__PURE__*/(() => {\n  class NgbCollapseModule {\n    static #_ = this.ɵfac = function NgbCollapseModule_Factory(t) {\n      return new (t || NgbCollapseModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbCollapseModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbCollapseModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A simple class that represents a date that datepicker also uses internally.\n *\n * It is the implementation of the `NgbDateStruct` interface that adds some convenience methods,\n * like `.equals()`, `.before()`, etc.\n *\n * All datepicker APIs consume `NgbDateStruct`, but return `NgbDate`.\n *\n * In many cases it is simpler to manipulate these objects together with\n * [`NgbCalendar`](#/components/datepicker/api#NgbCalendar) than native JS Dates.\n *\n * See the [date format overview](#/components/datepicker/overview#date-model) for more details.\n *\n * @since 3.0.0\n */\nclass NgbDate {\n  /**\n   * A **static method** that creates a new date object from the `NgbDateStruct`,\n   *\n   * ex. `NgbDate.from({year: 2000, month: 5, day: 1})`.\n   *\n   * If the `date` is already of `NgbDate` type, the method will return the same object.\n   */\n  static from(date) {\n    if (date instanceof NgbDate) {\n      return date;\n    }\n    return date ? new NgbDate(date.year, date.month, date.day) : null;\n  }\n  constructor(year, month, day) {\n    this.year = isInteger(year) ? year : null;\n    this.month = isInteger(month) ? month : null;\n    this.day = isInteger(day) ? day : null;\n  }\n  /**\n   * Checks if the current date is equal to another date.\n   */\n  equals(other) {\n    return other != null && this.year === other.year && this.month === other.month && this.day === other.day;\n  }\n  /**\n   * Checks if the current date is before another date.\n   */\n  before(other) {\n    if (!other) {\n      return false;\n    }\n    if (this.year === other.year) {\n      if (this.month === other.month) {\n        return this.day === other.day ? false : this.day < other.day;\n      } else {\n        return this.month < other.month;\n      }\n    } else {\n      return this.year < other.year;\n    }\n  }\n  /**\n   * Checks if the current date is after another date.\n   */\n  after(other) {\n    if (!other) {\n      return false;\n    }\n    if (this.year === other.year) {\n      if (this.month === other.month) {\n        return this.day === other.day ? false : this.day > other.day;\n      } else {\n        return this.month > other.month;\n      }\n    } else {\n      return this.year > other.year;\n    }\n  }\n}\nfunction fromJSDate(jsDate) {\n  return new NgbDate(jsDate.getFullYear(), jsDate.getMonth() + 1, jsDate.getDate());\n}\nfunction toJSDate(date) {\n  const jsDate = new Date(date.year, date.month - 1, date.day, 12);\n  // this is done avoid 30 -> 1930 conversion\n  if (!isNaN(jsDate.getTime())) {\n    jsDate.setFullYear(date.year);\n  }\n  return jsDate;\n}\nfunction NGB_DATEPICKER_CALENDAR_FACTORY() {\n  return new NgbCalendarGregorian();\n}\n/**\n * A service that represents the calendar used by the datepicker.\n *\n * The default implementation uses the Gregorian calendar. You can inject it in your own\n * implementations if necessary to simplify `NgbDate` calculations.\n */\nlet NgbCalendar = /*#__PURE__*/(() => {\n  class NgbCalendar {\n    static #_ = this.ɵfac = function NgbCalendar_Factory(t) {\n      return new (t || NgbCalendar)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendar,\n      factory: () => NGB_DATEPICKER_CALENDAR_FACTORY(),\n      providedIn: 'root'\n    });\n  }\n  return NgbCalendar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbCalendarGregorian = /*#__PURE__*/(() => {\n  class NgbCalendarGregorian extends NgbCalendar {\n    getDaysPerWeek() {\n      return 7;\n    }\n    getMonths() {\n      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    }\n    getWeeksPerMonth() {\n      return 6;\n    }\n    getNext(date, period = 'd', number = 1) {\n      let jsDate = toJSDate(date);\n      let checkMonth = true;\n      let expectedMonth = jsDate.getMonth();\n      switch (period) {\n        case 'y':\n          jsDate.setFullYear(jsDate.getFullYear() + number);\n          break;\n        case 'm':\n          expectedMonth += number;\n          jsDate.setMonth(expectedMonth);\n          expectedMonth = expectedMonth % 12;\n          if (expectedMonth < 0) {\n            expectedMonth = expectedMonth + 12;\n          }\n          break;\n        case 'd':\n          jsDate.setDate(jsDate.getDate() + number);\n          checkMonth = false;\n          break;\n        default:\n          return date;\n      }\n      if (checkMonth && jsDate.getMonth() !== expectedMonth) {\n        // this means the destination month has less days than the initial month\n        // let's go back to the end of the previous month:\n        jsDate.setDate(0);\n      }\n      return fromJSDate(jsDate);\n    }\n    getPrev(date, period = 'd', number = 1) {\n      return this.getNext(date, period, -number);\n    }\n    getWeekday(date) {\n      let jsDate = toJSDate(date);\n      let day = jsDate.getDay();\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      return day === 0 ? 7 : day;\n    }\n    getWeekNumber(week, firstDayOfWeek) {\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      if (firstDayOfWeek === 7) {\n        firstDayOfWeek = 0;\n      }\n      const thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;\n      let date = week[thursdayIndex];\n      const jsDate = toJSDate(date);\n      jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday\n      const time = jsDate.getTime();\n      jsDate.setMonth(0); // Compare with Jan 1\n      jsDate.setDate(1);\n      return Math.floor(Math.round((time - jsDate.getTime()) / 86400000) / 7) + 1;\n    }\n    getToday() {\n      return fromJSDate(new Date());\n    }\n    isValid(date) {\n      if (!date || !isInteger(date.year) || !isInteger(date.month) || !isInteger(date.day)) {\n        return false;\n      }\n      // year 0 doesn't exist in Gregorian calendar\n      if (date.year === 0) {\n        return false;\n      }\n      const jsDate = toJSDate(date);\n      return !isNaN(jsDate.getTime()) && jsDate.getFullYear() === date.year && jsDate.getMonth() + 1 === date.month && jsDate.getDate() === date.day;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarGregorian_BaseFactory;\n      return function NgbCalendarGregorian_Factory(t) {\n        return (ɵNgbCalendarGregorian_BaseFactory || (ɵNgbCalendarGregorian_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarGregorian)))(t || NgbCalendarGregorian);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarGregorian,\n      factory: NgbCalendarGregorian.ɵfac\n    });\n  }\n  return NgbCalendarGregorian;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction isChangedDate(prev, next) {\n  return !dateComparator(prev, next);\n}\nfunction isChangedMonth(prev, next) {\n  return !prev && !next ? false : !prev || !next ? true : prev.year !== next.year || prev.month !== next.month;\n}\nfunction dateComparator(prev, next) {\n  return !prev && !next || !!prev && !!next && prev.equals(next);\n}\nfunction checkMinBeforeMax(minDate, maxDate) {\n  if (maxDate && minDate && maxDate.before(minDate)) {\n    throw new Error(`'maxDate' ${maxDate} should be greater than 'minDate' ${minDate}`);\n  }\n}\nfunction checkDateInRange(date, minDate, maxDate) {\n  if (date && minDate && date.before(minDate)) {\n    return minDate;\n  }\n  if (date && maxDate && date.after(maxDate)) {\n    return maxDate;\n  }\n  return date || null;\n}\nfunction isDateSelectable(date, state) {\n  const {\n    minDate,\n    maxDate,\n    disabled,\n    markDisabled\n  } = state;\n  return !(date === null || date === undefined || disabled || markDisabled && markDisabled(date, {\n    year: date.year,\n    month: date.month\n  }) || minDate && date.before(minDate) || maxDate && date.after(maxDate));\n}\nfunction generateSelectBoxMonths(calendar, date, minDate, maxDate) {\n  if (!date) {\n    return [];\n  }\n  let months = calendar.getMonths(date.year);\n  if (minDate && date.year === minDate.year) {\n    const index = months.findIndex(month => month === minDate.month);\n    months = months.slice(index);\n  }\n  if (maxDate && date.year === maxDate.year) {\n    const index = months.findIndex(month => month === maxDate.month);\n    months = months.slice(0, index + 1);\n  }\n  return months;\n}\nfunction generateSelectBoxYears(date, minDate, maxDate) {\n  if (!date) {\n    return [];\n  }\n  const start = minDate ? Math.max(minDate.year, date.year - 500) : date.year - 10;\n  const end = maxDate ? Math.min(maxDate.year, date.year + 500) : date.year + 10;\n  const length = end - start + 1;\n  const numbers = Array(length);\n  for (let i = 0; i < length; i++) {\n    numbers[i] = start + i;\n  }\n  return numbers;\n}\nfunction nextMonthDisabled(calendar, date, maxDate) {\n  const nextDate = Object.assign(calendar.getNext(date, 'm'), {\n    day: 1\n  });\n  return maxDate != null && nextDate.after(maxDate);\n}\nfunction prevMonthDisabled(calendar, date, minDate) {\n  const prevDate = Object.assign(calendar.getPrev(date, 'm'), {\n    day: 1\n  });\n  return minDate != null && (prevDate.year === minDate.year && prevDate.month < minDate.month || prevDate.year < minDate.year && minDate.month === 1);\n}\nfunction buildMonths(calendar, date, state, i18n, force) {\n  const {\n    displayMonths,\n    months\n  } = state;\n  // move old months to a temporary array\n  const monthsToReuse = months.splice(0, months.length);\n  // generate new first dates, nullify or reuse months\n  const firstDates = Array.from({\n    length: displayMonths\n  }, (_, i) => {\n    const firstDate = Object.assign(calendar.getNext(date, 'm', i), {\n      day: 1\n    });\n    months[i] = null;\n    if (!force) {\n      const reusedIndex = monthsToReuse.findIndex(month => month.firstDate.equals(firstDate));\n      // move reused month back to months\n      if (reusedIndex !== -1) {\n        months[i] = monthsToReuse.splice(reusedIndex, 1)[0];\n      }\n    }\n    return firstDate;\n  });\n  // rebuild nullified months\n  firstDates.forEach((firstDate, i) => {\n    if (months[i] === null) {\n      months[i] = buildMonth(calendar, firstDate, state, i18n, monthsToReuse.shift() || {});\n    }\n  });\n  return months;\n}\nfunction buildMonth(calendar, date, state, i18n, month = {}) {\n  const {\n    dayTemplateData,\n    minDate,\n    maxDate,\n    firstDayOfWeek,\n    markDisabled,\n    outsideDays,\n    weekdayWidth,\n    weekdaysVisible\n  } = state;\n  const calendarToday = calendar.getToday();\n  month.firstDate = null;\n  month.lastDate = null;\n  month.number = date.month;\n  month.year = date.year;\n  month.weeks = month.weeks || [];\n  month.weekdays = month.weekdays || [];\n  date = getFirstViewDate(calendar, date, firstDayOfWeek);\n  // clearing weekdays, if not visible\n  if (!weekdaysVisible) {\n    month.weekdays.length = 0;\n  }\n  // month has weeks\n  for (let week = 0; week < calendar.getWeeksPerMonth(); week++) {\n    let weekObject = month.weeks[week];\n    if (!weekObject) {\n      weekObject = month.weeks[week] = {\n        number: 0,\n        days: [],\n        collapsed: true\n      };\n    }\n    const days = weekObject.days;\n    // week has days\n    for (let day = 0; day < calendar.getDaysPerWeek(); day++) {\n      if (week === 0 && weekdaysVisible) {\n        month.weekdays[day] = i18n.getWeekdayLabel(calendar.getWeekday(date), weekdayWidth);\n      }\n      const newDate = new NgbDate(date.year, date.month, date.day);\n      const nextDate = calendar.getNext(newDate);\n      const ariaLabel = i18n.getDayAriaLabel(newDate);\n      // marking date as disabled\n      let disabled = !!(minDate && newDate.before(minDate) || maxDate && newDate.after(maxDate));\n      if (!disabled && markDisabled) {\n        disabled = markDisabled(newDate, {\n          month: month.number,\n          year: month.year\n        });\n      }\n      // today\n      let today = newDate.equals(calendarToday);\n      // adding user-provided data to the context\n      let contextUserData = dayTemplateData ? dayTemplateData(newDate, {\n        month: month.number,\n        year: month.year\n      }) : undefined;\n      // saving first date of the month\n      if (month.firstDate === null && newDate.month === month.number) {\n        month.firstDate = newDate;\n      }\n      // saving last date of the month\n      if (newDate.month === month.number && nextDate.month !== month.number) {\n        month.lastDate = newDate;\n      }\n      let dayObject = days[day];\n      if (!dayObject) {\n        dayObject = days[day] = {};\n      }\n      dayObject.date = newDate;\n      dayObject.context = Object.assign(dayObject.context || {}, {\n        $implicit: newDate,\n        date: newDate,\n        data: contextUserData,\n        currentMonth: month.number,\n        currentYear: month.year,\n        disabled,\n        focused: false,\n        selected: false,\n        today\n      });\n      dayObject.tabindex = -1;\n      dayObject.ariaLabel = ariaLabel;\n      dayObject.hidden = false;\n      date = nextDate;\n    }\n    weekObject.number = calendar.getWeekNumber(days.map(day => day.date), firstDayOfWeek);\n    // marking week as collapsed\n    weekObject.collapsed = outsideDays === 'collapsed' && days[0].date.month !== month.number && days[days.length - 1].date.month !== month.number;\n  }\n  return month;\n}\nfunction getFirstViewDate(calendar, date, firstDayOfWeek) {\n  const daysPerWeek = calendar.getDaysPerWeek();\n  const firstMonthDate = new NgbDate(date.year, date.month, 1);\n  const dayOfWeek = calendar.getWeekday(firstMonthDate) % daysPerWeek;\n  return calendar.getPrev(firstMonthDate, 'd', (daysPerWeek + dayOfWeek - firstDayOfWeek) % daysPerWeek);\n}\n\n/**\n * A service supplying i18n data to the datepicker component.\n *\n * The default implementation of this service uses the Angular locale and registered locale data for\n * weekdays and month names (as explained in the Angular i18n guide).\n *\n * It also provides a way to i18n data that depends on calendar calculations, like aria labels, day, week and year\n * numerals. For other static labels the datepicker uses the default Angular i18n.\n *\n * See the [i18n demo](#/components/datepicker/examples#i18n) and\n * [Hebrew calendar demo](#/components/datepicker/calendars#hebrew) on how to extend this class and define\n * a custom provider for i18n.\n */\nlet NgbDatepickerI18n = /*#__PURE__*/(() => {\n  class NgbDatepickerI18n {\n    /**\n     * Returns the text label to display above the day view.\n     *\n     * @since 9.1.0\n     */\n    getMonthLabel(date) {\n      return `${this.getMonthFullName(date.month, date.year)} ${this.getYearNumerals(date.year)}`;\n    }\n    /**\n     * Returns the textual representation of a day that is rendered in a day cell.\n     *\n     * @since 3.0.0\n     */\n    getDayNumerals(date) {\n      return `${date.day}`;\n    }\n    /**\n     * Returns the textual representation of a week number rendered by datepicker.\n     *\n     * @since 3.0.0\n     */\n    getWeekNumerals(weekNumber) {\n      return `${weekNumber}`;\n    }\n    /**\n     * Returns the textual representation of a year that is rendered in the datepicker year select box.\n     *\n     * @since 3.0.0\n     */\n    getYearNumerals(year) {\n      return `${year}`;\n    }\n    /**\n     * Returns the week label to display in the heading of the month view.\n     *\n     * @since 9.1.0\n     */\n    getWeekLabel() {\n      return '';\n    }\n    static #_ = this.ɵfac = function NgbDatepickerI18n_Factory(t) {\n      return new (t || NgbDatepickerI18n)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDatepickerI18n,\n      factory: () => (() => new NgbDatepickerI18nDefault())(),\n      providedIn: 'root'\n    });\n  }\n  return NgbDatepickerI18n;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A service providing default implementation for the datepicker i18n.\n * It can be used as a base implementation if necessary.\n *\n * @since 9.1.0\n */\nlet NgbDatepickerI18nDefault = /*#__PURE__*/(() => {\n  class NgbDatepickerI18nDefault extends NgbDatepickerI18n {\n    constructor() {\n      super(...arguments);\n      this._locale = inject(LOCALE_ID);\n      this._monthsShort = getLocaleMonthNames(this._locale, FormStyle.Standalone, TranslationWidth.Abbreviated);\n      this._monthsFull = getLocaleMonthNames(this._locale, FormStyle.Standalone, TranslationWidth.Wide);\n    }\n    getWeekdayLabel(weekday, width) {\n      const weekdaysStartingOnSunday = getLocaleDayNames(this._locale, FormStyle.Standalone, width === undefined ? TranslationWidth.Short : width);\n      const weekdays = weekdaysStartingOnSunday.map((day, index) => weekdaysStartingOnSunday[(index + 1) % 7]);\n      return weekdays[weekday - 1] || '';\n    }\n    getMonthShortName(month) {\n      return this._monthsShort[month - 1] || '';\n    }\n    getMonthFullName(month) {\n      return this._monthsFull[month - 1] || '';\n    }\n    getDayAriaLabel(date) {\n      const jsDate = new Date(date.year, date.month - 1, date.day);\n      return formatDate(jsDate, 'fullDate', this._locale);\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDatepickerI18nDefault_BaseFactory;\n      return function NgbDatepickerI18nDefault_Factory(t) {\n        return (ɵNgbDatepickerI18nDefault_BaseFactory || (ɵNgbDatepickerI18nDefault_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDatepickerI18nDefault)))(t || NgbDatepickerI18nDefault);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDatepickerI18nDefault,\n      factory: NgbDatepickerI18nDefault.ɵfac\n    });\n  }\n  return NgbDatepickerI18nDefault;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbDatepickerService = /*#__PURE__*/(() => {\n  class NgbDatepickerService {\n    constructor() {\n      this._VALIDATORS = {\n        dayTemplateData: dayTemplateData => {\n          if (this._state.dayTemplateData !== dayTemplateData) {\n            return {\n              dayTemplateData\n            };\n          }\n        },\n        displayMonths: displayMonths => {\n          displayMonths = toInteger(displayMonths);\n          if (isInteger(displayMonths) && displayMonths > 0 && this._state.displayMonths !== displayMonths) {\n            return {\n              displayMonths\n            };\n          }\n        },\n        disabled: disabled => {\n          if (this._state.disabled !== disabled) {\n            return {\n              disabled\n            };\n          }\n        },\n        firstDayOfWeek: firstDayOfWeek => {\n          firstDayOfWeek = toInteger(firstDayOfWeek);\n          if (isInteger(firstDayOfWeek) && firstDayOfWeek >= 0 && this._state.firstDayOfWeek !== firstDayOfWeek) {\n            return {\n              firstDayOfWeek\n            };\n          }\n        },\n        focusVisible: focusVisible => {\n          if (this._state.focusVisible !== focusVisible && !this._state.disabled) {\n            return {\n              focusVisible\n            };\n          }\n        },\n        markDisabled: markDisabled => {\n          if (this._state.markDisabled !== markDisabled) {\n            return {\n              markDisabled\n            };\n          }\n        },\n        maxDate: date => {\n          const maxDate = this.toValidDate(date, null);\n          if (isChangedDate(this._state.maxDate, maxDate)) {\n            return {\n              maxDate\n            };\n          }\n        },\n        minDate: date => {\n          const minDate = this.toValidDate(date, null);\n          if (isChangedDate(this._state.minDate, minDate)) {\n            return {\n              minDate\n            };\n          }\n        },\n        navigation: navigation => {\n          if (this._state.navigation !== navigation) {\n            return {\n              navigation\n            };\n          }\n        },\n        outsideDays: outsideDays => {\n          if (this._state.outsideDays !== outsideDays) {\n            return {\n              outsideDays\n            };\n          }\n        },\n        weekdays: weekdays => {\n          const weekdayWidth = weekdays === true || weekdays === false ? TranslationWidth.Short : weekdays;\n          const weekdaysVisible = weekdays === true || weekdays === false ? weekdays : true;\n          if (this._state.weekdayWidth !== weekdayWidth || this._state.weekdaysVisible !== weekdaysVisible) {\n            return {\n              weekdayWidth,\n              weekdaysVisible\n            };\n          }\n        }\n      };\n      this._calendar = inject(NgbCalendar);\n      this._i18n = inject(NgbDatepickerI18n);\n      this._model$ = new Subject();\n      this._dateSelect$ = new Subject();\n      this._state = {\n        dayTemplateData: null,\n        markDisabled: null,\n        maxDate: null,\n        minDate: null,\n        disabled: false,\n        displayMonths: 1,\n        firstDate: null,\n        firstDayOfWeek: 1,\n        lastDate: null,\n        focusDate: null,\n        focusVisible: false,\n        months: [],\n        navigation: 'select',\n        outsideDays: 'visible',\n        prevDisabled: false,\n        nextDisabled: false,\n        selectedDate: null,\n        selectBoxes: {\n          years: [],\n          months: []\n        },\n        weekdayWidth: TranslationWidth.Short,\n        weekdaysVisible: true\n      };\n    }\n    get model$() {\n      return this._model$.pipe(filter(model => model.months.length > 0));\n    }\n    get dateSelect$() {\n      return this._dateSelect$.pipe(filter(date => date !== null));\n    }\n    set(options) {\n      let patch = Object.keys(options).map(key => this._VALIDATORS[key](options[key])).reduce((obj, part) => ({\n        ...obj,\n        ...part\n      }), {});\n      if (Object.keys(patch).length > 0) {\n        this._nextState(patch);\n      }\n    }\n    focus(date) {\n      const focusedDate = this.toValidDate(date, null);\n      if (focusedDate != null && !this._state.disabled && isChangedDate(this._state.focusDate, focusedDate)) {\n        this._nextState({\n          focusDate: date\n        });\n      }\n    }\n    focusSelect() {\n      if (isDateSelectable(this._state.focusDate, this._state)) {\n        this.select(this._state.focusDate, {\n          emitEvent: true\n        });\n      }\n    }\n    open(date) {\n      const firstDate = this.toValidDate(date, this._calendar.getToday());\n      if (firstDate != null && !this._state.disabled && (!this._state.firstDate || isChangedMonth(this._state.firstDate, firstDate))) {\n        this._nextState({\n          firstDate\n        });\n      }\n    }\n    select(date, options = {}) {\n      const selectedDate = this.toValidDate(date, null);\n      if (selectedDate != null && !this._state.disabled) {\n        if (isChangedDate(this._state.selectedDate, selectedDate)) {\n          this._nextState({\n            selectedDate\n          });\n        }\n        if (options.emitEvent && isDateSelectable(selectedDate, this._state)) {\n          this._dateSelect$.next(selectedDate);\n        }\n      }\n    }\n    toValidDate(date, defaultValue) {\n      const ngbDate = NgbDate.from(date);\n      if (defaultValue === undefined) {\n        defaultValue = this._calendar.getToday();\n      }\n      return this._calendar.isValid(ngbDate) ? ngbDate : defaultValue;\n    }\n    getMonth(struct) {\n      for (let month of this._state.months) {\n        if (struct.month === month.number && struct.year === month.year) {\n          return month;\n        }\n      }\n      throw new Error(`month ${struct.month} of year ${struct.year} not found`);\n    }\n    _nextState(patch) {\n      const newState = this._updateState(patch);\n      this._patchContexts(newState);\n      this._state = newState;\n      this._model$.next(this._state);\n    }\n    _patchContexts(state) {\n      const {\n        months,\n        displayMonths,\n        selectedDate,\n        focusDate,\n        focusVisible,\n        disabled,\n        outsideDays\n      } = state;\n      state.months.forEach(month => {\n        month.weeks.forEach(week => {\n          week.days.forEach(day => {\n            // patch focus flag\n            if (focusDate) {\n              day.context.focused = focusDate.equals(day.date) && focusVisible;\n            }\n            // calculating tabindex\n            day.tabindex = !disabled && focusDate && day.date.equals(focusDate) && focusDate.month === month.number ? 0 : -1;\n            // override context disabled\n            if (disabled === true) {\n              day.context.disabled = true;\n            }\n            // patch selection flag\n            if (selectedDate !== undefined) {\n              day.context.selected = selectedDate !== null && selectedDate.equals(day.date);\n            }\n            // visibility\n            if (month.number !== day.date.month) {\n              day.hidden = outsideDays === 'hidden' || outsideDays === 'collapsed' || displayMonths > 1 && day.date.after(months[0].firstDate) && day.date.before(months[displayMonths - 1].lastDate);\n            }\n          });\n        });\n      });\n    }\n    _updateState(patch) {\n      // patching fields\n      const state = Object.assign({}, this._state, patch);\n      let startDate = state.firstDate;\n      // min/max dates changed\n      if ('minDate' in patch || 'maxDate' in patch) {\n        checkMinBeforeMax(state.minDate, state.maxDate);\n        state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);\n        state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);\n        startDate = state.focusDate;\n      }\n      // disabled\n      if ('disabled' in patch) {\n        state.focusVisible = false;\n      }\n      // initial rebuild via 'select()'\n      if ('selectedDate' in patch && this._state.months.length === 0) {\n        startDate = state.selectedDate;\n      }\n      // terminate early if only focus visibility was changed\n      if ('focusVisible' in patch) {\n        return state;\n      }\n      // focus date changed\n      if ('focusDate' in patch) {\n        state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);\n        startDate = state.focusDate;\n        // nothing to rebuild if only focus changed and it is still visible\n        if (state.months.length !== 0 && state.focusDate && !state.focusDate.before(state.firstDate) && !state.focusDate.after(state.lastDate)) {\n          return state;\n        }\n      }\n      // first date changed\n      if ('firstDate' in patch) {\n        state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);\n        startDate = state.firstDate;\n      }\n      // rebuilding months\n      if (startDate) {\n        const forceRebuild = 'dayTemplateData' in patch || 'firstDayOfWeek' in patch || 'markDisabled' in patch || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch || 'outsideDays' in patch || 'weekdaysVisible' in patch;\n        const months = buildMonths(this._calendar, startDate, state, this._i18n, forceRebuild);\n        // updating months and boundary dates\n        state.months = months;\n        state.firstDate = months[0].firstDate;\n        state.lastDate = months[months.length - 1].lastDate;\n        // reset selected date if 'markDisabled' returns true\n        if ('selectedDate' in patch && !isDateSelectable(state.selectedDate, state)) {\n          state.selectedDate = null;\n        }\n        // adjusting focus after months were built\n        if ('firstDate' in patch) {\n          if (!state.focusDate || state.focusDate.before(state.firstDate) || state.focusDate.after(state.lastDate)) {\n            state.focusDate = startDate;\n          }\n        }\n        // adjusting months/years for the select box navigation\n        const yearChanged = !this._state.firstDate || this._state.firstDate.year !== state.firstDate.year;\n        const monthChanged = !this._state.firstDate || this._state.firstDate.month !== state.firstDate.month;\n        if (state.navigation === 'select') {\n          // years ->  boundaries (min/max were changed)\n          if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.years.length === 0 || yearChanged) {\n            state.selectBoxes.years = generateSelectBoxYears(state.firstDate, state.minDate, state.maxDate);\n          }\n          // months -> when current year or boundaries change\n          if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.months.length === 0 || yearChanged) {\n            state.selectBoxes.months = generateSelectBoxMonths(this._calendar, state.firstDate, state.minDate, state.maxDate);\n          }\n        } else {\n          state.selectBoxes = {\n            years: [],\n            months: []\n          };\n        }\n        // updating navigation arrows -> boundaries change (min/max) or month/year changes\n        if ((state.navigation === 'arrows' || state.navigation === 'select') && (monthChanged || yearChanged || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch)) {\n          state.prevDisabled = state.disabled || prevMonthDisabled(this._calendar, state.firstDate, state.minDate);\n          state.nextDisabled = state.disabled || nextMonthDisabled(this._calendar, state.lastDate, state.maxDate);\n        }\n      }\n      return state;\n    }\n    static #_ = this.ɵfac = function NgbDatepickerService_Factory(t) {\n      return new (t || NgbDatepickerService)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDatepickerService,\n      factory: NgbDatepickerService.ɵfac\n    });\n  }\n  return NgbDatepickerService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar NavigationEvent = /*#__PURE__*/function (NavigationEvent) {\n  NavigationEvent[NavigationEvent[\"PREV\"] = 0] = \"PREV\";\n  NavigationEvent[NavigationEvent[\"NEXT\"] = 1] = \"NEXT\";\n  return NavigationEvent;\n}(NavigationEvent || {});\n/**\n * A configuration service for the [`NgbDatepicker`](#/components/datepicker/api#NgbDatepicker) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the datepickers used in the application.\n */\nlet NgbDatepickerConfig = /*#__PURE__*/(() => {\n  class NgbDatepickerConfig {\n    constructor() {\n      this.displayMonths = 1;\n      this.firstDayOfWeek = 1;\n      this.navigation = 'select';\n      this.outsideDays = 'visible';\n      this.showWeekNumbers = false;\n      this.weekdays = TranslationWidth.Short;\n    }\n    static #_ = this.ɵfac = function NgbDatepickerConfig_Factory(t) {\n      return new (t || NgbDatepickerConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDatepickerConfig,\n      factory: NgbDatepickerConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbDatepickerConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction NGB_DATEPICKER_DATE_ADAPTER_FACTORY() {\n  return new NgbDateStructAdapter();\n}\n/**\n * An abstract service that does the conversion between the internal datepicker `NgbDateStruct` model and\n * any provided user date model `D`, ex. a string, a native date, etc.\n *\n * The adapter is used **only** for conversion when binding datepicker to a form control,\n * ex. `[(ngModel)]=\"userDateModel\"`. Here `userDateModel` can be of any type.\n *\n * The default datepicker implementation assumes we use `NgbDateStruct` as a user model.\n *\n * See the [date format overview](#/components/datepicker/overview#date-model) for more details\n * and the [custom adapter demo](#/components/datepicker/examples#adapter) for an example.\n */\nlet NgbDateAdapter = /*#__PURE__*/(() => {\n  class NgbDateAdapter {\n    static #_ = this.ɵfac = function NgbDateAdapter_Factory(t) {\n      return new (t || NgbDateAdapter)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDateAdapter,\n      factory: () => NGB_DATEPICKER_DATE_ADAPTER_FACTORY(),\n      providedIn: 'root'\n    });\n  }\n  return NgbDateAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbDateStructAdapter = /*#__PURE__*/(() => {\n  class NgbDateStructAdapter extends NgbDateAdapter {\n    /**\n     * Converts a NgbDateStruct value into NgbDateStruct value\n     */\n    fromModel(date) {\n      return date && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) ? {\n        year: date.year,\n        month: date.month,\n        day: date.day\n      } : null;\n    }\n    /**\n     * Converts a NgbDateStruct value into NgbDateStruct value\n     */\n    toModel(date) {\n      return date && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) ? {\n        year: date.year,\n        month: date.month,\n        day: date.day\n      } : null;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDateStructAdapter_BaseFactory;\n      return function NgbDateStructAdapter_Factory(t) {\n        return (ɵNgbDateStructAdapter_BaseFactory || (ɵNgbDateStructAdapter_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDateStructAdapter)))(t || NgbDateStructAdapter);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDateStructAdapter,\n      factory: NgbDateStructAdapter.ɵfac\n    });\n  }\n  return NgbDateStructAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar Key = /*#__PURE__*/function (Key) {\n  Key[Key[\"Tab\"] = 9] = \"Tab\";\n  Key[Key[\"Enter\"] = 13] = \"Enter\";\n  Key[Key[\"Escape\"] = 27] = \"Escape\";\n  Key[Key[\"Space\"] = 32] = \"Space\";\n  Key[Key[\"PageUp\"] = 33] = \"PageUp\";\n  Key[Key[\"PageDown\"] = 34] = \"PageDown\";\n  Key[Key[\"End\"] = 35] = \"End\";\n  Key[Key[\"Home\"] = 36] = \"Home\";\n  Key[Key[\"ArrowLeft\"] = 37] = \"ArrowLeft\";\n  Key[Key[\"ArrowUp\"] = 38] = \"ArrowUp\";\n  Key[Key[\"ArrowRight\"] = 39] = \"ArrowRight\";\n  Key[Key[\"ArrowDown\"] = 40] = \"ArrowDown\";\n  return Key;\n}(Key || {});\n/**\n * A service that represents the keyboard navigation.\n *\n * Default keyboard shortcuts [are documented in the overview](#/components/datepicker/overview#keyboard-shortcuts)\n *\n * @since 5.2.0\n */\nlet NgbDatepickerKeyboardService = /*#__PURE__*/(() => {\n  class NgbDatepickerKeyboardService {\n    /**\n     * Processes a keyboard event.\n     */\n    processKey(event, datepicker) {\n      const {\n        state,\n        calendar\n      } = datepicker;\n      /* eslint-disable-next-line deprecation/deprecation */\n      switch (event.which) {\n        case Key.PageUp:\n          datepicker.focusDate(calendar.getPrev(state.focusedDate, event.shiftKey ? 'y' : 'm', 1));\n          break;\n        case Key.PageDown:\n          datepicker.focusDate(calendar.getNext(state.focusedDate, event.shiftKey ? 'y' : 'm', 1));\n          break;\n        case Key.End:\n          datepicker.focusDate(event.shiftKey ? state.maxDate : state.lastDate);\n          break;\n        case Key.Home:\n          datepicker.focusDate(event.shiftKey ? state.minDate : state.firstDate);\n          break;\n        case Key.ArrowLeft:\n          datepicker.focusDate(calendar.getPrev(state.focusedDate, 'd', 1));\n          break;\n        case Key.ArrowUp:\n          datepicker.focusDate(calendar.getPrev(state.focusedDate, 'd', calendar.getDaysPerWeek()));\n          break;\n        case Key.ArrowRight:\n          datepicker.focusDate(calendar.getNext(state.focusedDate, 'd', 1));\n          break;\n        case Key.ArrowDown:\n          datepicker.focusDate(calendar.getNext(state.focusedDate, 'd', calendar.getDaysPerWeek()));\n          break;\n        case Key.Enter:\n        case Key.Space:\n          datepicker.focusSelect();\n          break;\n        default:\n          return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n    }\n    static #_ = this.ɵfac = function NgbDatepickerKeyboardService_Factory(t) {\n      return new (t || NgbDatepickerKeyboardService)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDatepickerKeyboardService,\n      factory: NgbDatepickerKeyboardService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbDatepickerKeyboardService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbDatepickerDayView = /*#__PURE__*/(() => {\n  class NgbDatepickerDayView {\n    constructor() {\n      this.i18n = inject(NgbDatepickerI18n);\n    }\n    isMuted() {\n      return !this.selected && (this.date.month !== this.currentMonth || this.disabled);\n    }\n    static #_ = this.ɵfac = function NgbDatepickerDayView_Factory(t) {\n      return new (t || NgbDatepickerDayView)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbDatepickerDayView,\n      selectors: [[\"\", \"ngbDatepickerDayView\", \"\"]],\n      hostAttrs: [1, \"btn-light\"],\n      hostVars: 10,\n      hostBindings: function NgbDatepickerDayView_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"bg-primary\", ctx.selected)(\"text-white\", ctx.selected)(\"text-muted\", ctx.isMuted())(\"outside\", ctx.isMuted())(\"active\", ctx.focused);\n        }\n      },\n      inputs: {\n        currentMonth: \"currentMonth\",\n        date: \"date\",\n        disabled: \"disabled\",\n        focused: \"focused\",\n        selected: \"selected\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      attrs: _c1,\n      decls: 1,\n      vars: 1,\n      template: function NgbDatepickerDayView_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtext(0);\n        }\n        if (rf & 2) {\n          i0.ɵɵtextInterpolate(ctx.i18n.getDayNumerals(ctx.date));\n        }\n      },\n      styles: [\"[ngbDatepickerDayView]{text-align:center;width:2rem;height:2rem;line-height:2rem;border-radius:.25rem;background:transparent}[ngbDatepickerDayView]:hover:not(.bg-primary),[ngbDatepickerDayView].active:not(.bg-primary){background-color:var(--bs-tertiary-bg);outline:1px solid var(--bs-border-color)}[ngbDatepickerDayView].outside{opacity:.5}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbDatepickerDayView;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbDatepickerNavigationSelect = /*#__PURE__*/(() => {\n  class NgbDatepickerNavigationSelect {\n    constructor() {\n      this._month = -1;\n      this._year = -1;\n      this.i18n = inject(NgbDatepickerI18n);\n      this.select = new EventEmitter();\n    }\n    changeMonth(month) {\n      this.select.emit(new NgbDate(this.date.year, toInteger(month), 1));\n    }\n    changeYear(year) {\n      this.select.emit(new NgbDate(toInteger(year), this.date.month, 1));\n    }\n    ngAfterViewChecked() {\n      if (this.date) {\n        if (this.date.month !== this._month) {\n          this._month = this.date.month;\n          this.monthSelect.nativeElement.value = `${this._month}`;\n        }\n        if (this.date.year !== this._year) {\n          this._year = this.date.year;\n          this.yearSelect.nativeElement.value = `${this._year}`;\n        }\n      }\n    }\n    static #_ = this.ɵfac = function NgbDatepickerNavigationSelect_Factory(t) {\n      return new (t || NgbDatepickerNavigationSelect)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbDatepickerNavigationSelect,\n      selectors: [[\"ngb-datepicker-navigation-select\"]],\n      viewQuery: function NgbDatepickerNavigationSelect_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c2, 7, ElementRef);\n          i0.ɵɵviewQuery(_c3, 7, ElementRef);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.monthSelect = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.yearSelect = _t.first);\n        }\n      },\n      inputs: {\n        date: \"date\",\n        disabled: \"disabled\",\n        months: \"months\",\n        years: \"years\"\n      },\n      outputs: {\n        select: \"select\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 8,\n      vars: 2,\n      consts: () => {\n        let i18n_4;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_1 = goog.getMsg(\"Select month\");\n          i18n_4 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_1;\n        } else {\n          i18n_4 = $localize`:@@ngb.datepicker.select-month:Select month`;\n        }\n        let i18n_5;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_2 = goog.getMsg(\"Select month\");\n          i18n_5 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_2;\n        } else {\n          i18n_5 = $localize`:@@ngb.datepicker.select-month:Select month`;\n        }\n        let i18n_6;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_3 = goog.getMsg(\"Select year\");\n          i18n_6 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_3;\n        } else {\n          i18n_6 = $localize`:@@ngb.datepicker.select-year:Select year`;\n        }\n        let i18n_7;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_4 = goog.getMsg(\"Select year\");\n          i18n_7 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_4;\n        } else {\n          i18n_7 = $localize`:@@ngb.datepicker.select-year:Select year`;\n        }\n        return [[\"aria-label\", i18n_4, \"title\", i18n_5, 1, \"form-select\", 3, \"disabled\", \"change\"], [\"month\", \"\"], [\"aria-label\", i18n_6, \"title\", i18n_7, 1, \"form-select\", 3, \"disabled\", \"change\"], [\"year\", \"\"], [3, \"value\"]];\n      },\n      template: function NgbDatepickerNavigationSelect_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"select\", 0, 1);\n          i0.ɵɵlistener(\"change\", function NgbDatepickerNavigationSelect_Template_select_change_0_listener($event) {\n            return ctx.changeMonth($event.target.value);\n          });\n          i0.ɵɵrepeaterCreate(2, NgbDatepickerNavigationSelect_For_3_Template, 2, 3, \"option\", 4, i0.ɵɵrepeaterTrackByIdentity);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(4, \"select\", 2, 3);\n          i0.ɵɵlistener(\"change\", function NgbDatepickerNavigationSelect_Template_select_change_4_listener($event) {\n            return ctx.changeYear($event.target.value);\n          });\n          i0.ɵɵrepeaterCreate(6, NgbDatepickerNavigationSelect_For_7_Template, 2, 2, \"option\", 4, i0.ɵɵrepeaterTrackByIdentity);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵproperty(\"disabled\", ctx.disabled);\n          i0.ɵɵadvance(2);\n          i0.ɵɵrepeater(ctx.months);\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"disabled\", ctx.disabled);\n          i0.ɵɵadvance(2);\n          i0.ɵɵrepeater(ctx.years);\n        }\n      },\n      styles: [\"ngb-datepicker-navigation-select>.form-select{flex:1 1 auto;padding:0 .5rem;font-size:.875rem;height:1.85rem}ngb-datepicker-navigation-select>.form-select:focus{z-index:1}ngb-datepicker-navigation-select>.form-select::-ms-value{background-color:transparent!important}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbDatepickerNavigationSelect;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbDatepickerNavigation = /*#__PURE__*/(() => {\n  class NgbDatepickerNavigation {\n    constructor() {\n      this.navigation = NavigationEvent;\n      this.i18n = inject(NgbDatepickerI18n);\n      this.months = [];\n      this.navigate = new EventEmitter();\n      this.select = new EventEmitter();\n    }\n    onClickPrev(event) {\n      event.currentTarget.focus();\n      this.navigate.emit(this.navigation.PREV);\n    }\n    onClickNext(event) {\n      event.currentTarget.focus();\n      this.navigate.emit(this.navigation.NEXT);\n    }\n    static #_ = this.ɵfac = function NgbDatepickerNavigation_Factory(t) {\n      return new (t || NgbDatepickerNavigation)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbDatepickerNavigation,\n      selectors: [[\"ngb-datepicker-navigation\"]],\n      inputs: {\n        date: \"date\",\n        disabled: \"disabled\",\n        months: \"months\",\n        showSelect: \"showSelect\",\n        prevDisabled: \"prevDisabled\",\n        nextDisabled: \"nextDisabled\",\n        selectBoxes: \"selectBoxes\"\n      },\n      outputs: {\n        navigate: \"navigate\",\n        select: \"select\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 8,\n      vars: 4,\n      consts: () => {\n        let i18n_8;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_5 = goog.getMsg(\"Previous month\");\n          i18n_8 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_5;\n        } else {\n          i18n_8 = $localize`:@@ngb.datepicker.previous-month:Previous month`;\n        }\n        let i18n_9;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_6 = goog.getMsg(\"Previous month\");\n          i18n_9 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_6;\n        } else {\n          i18n_9 = $localize`:@@ngb.datepicker.previous-month:Previous month`;\n        }\n        let i18n_10;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_7 = goog.getMsg(\"Next month\");\n          i18n_10 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_7;\n        } else {\n          i18n_10 = $localize`:@@ngb.datepicker.next-month:Next month`;\n        }\n        let i18n_11;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_8 = goog.getMsg(\"Next month\");\n          i18n_11 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_8;\n        } else {\n          i18n_11 = $localize`:@@ngb.datepicker.next-month:Next month`;\n        }\n        return [[1, \"ngb-dp-arrow\", \"ngb-dp-arrow-prev\"], [\"type\", \"button\", \"aria-label\", i18n_8, \"title\", i18n_9, 1, \"btn\", \"btn-link\", \"ngb-dp-arrow-btn\", 3, \"disabled\", \"click\"], [1, \"ngb-dp-navigation-chevron\"], [\"class\", \"ngb-dp-navigation-select\", 3, \"date\", \"disabled\", \"months\", \"years\"], [1, \"ngb-dp-arrow\", \"ngb-dp-arrow-next\"], [\"type\", \"button\", \"aria-label\", i18n_10, \"title\", i18n_11, 1, \"btn\", \"btn-link\", \"ngb-dp-arrow-btn\", 3, \"disabled\", \"click\"], [1, \"ngb-dp-navigation-select\", 3, \"date\", \"disabled\", \"months\", \"years\", \"select\"], [\"class\", \"ngb-dp-arrow\"], [1, \"ngb-dp-month-name\"], [1, \"ngb-dp-arrow\"]];\n      },\n      template: function NgbDatepickerNavigation_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"div\", 0)(1, \"button\", 1);\n          i0.ɵɵlistener(\"click\", function NgbDatepickerNavigation_Template_button_click_1_listener($event) {\n            return ctx.onClickPrev($event);\n          });\n          i0.ɵɵelement(2, \"span\", 2);\n          i0.ɵɵelementEnd()();\n          i0.ɵɵtemplate(3, NgbDatepickerNavigation_Conditional_3_Template, 1, 4, \"ngb-datepicker-navigation-select\", 3)(4, NgbDatepickerNavigation_Conditional_4_Template, 2, 0);\n          i0.ɵɵelementStart(5, \"div\", 4)(6, \"button\", 5);\n          i0.ɵɵlistener(\"click\", function NgbDatepickerNavigation_Template_button_click_6_listener($event) {\n            return ctx.onClickNext($event);\n          });\n          i0.ɵɵelement(7, \"span\", 2);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"disabled\", ctx.prevDisabled);\n          i0.ɵɵadvance(2);\n          i0.ɵɵconditional(3, ctx.showSelect ? 3 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(4, !ctx.showSelect ? 4 : -1);\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"disabled\", ctx.nextDisabled);\n        }\n      },\n      dependencies: [NgbDatepickerNavigationSelect],\n      styles: [\"ngb-datepicker-navigation{display:flex;align-items:center}.ngb-dp-navigation-chevron{border-style:solid;border-width:.2em .2em 0 0;display:inline-block;width:.75em;height:.75em;margin-left:.25em;margin-right:.15em;transform:rotate(-135deg)}.ngb-dp-arrow{display:flex;flex:1 1 auto;padding-right:0;padding-left:0;margin:0;width:2rem;height:2rem}.ngb-dp-arrow-next{justify-content:flex-end}.ngb-dp-arrow-next .ngb-dp-navigation-chevron{transform:rotate(45deg);margin-left:.15em;margin-right:.25em}.ngb-dp-arrow-btn{padding:0 .25rem;margin:0 .5rem;border:none;background-color:transparent;z-index:1}.ngb-dp-arrow-btn:focus{outline-width:1px;outline-style:auto}@media all and (-ms-high-contrast: none),(-ms-high-contrast: active){.ngb-dp-arrow-btn:focus{outline-style:solid}}.ngb-dp-month-name{font-size:larger;height:2rem;line-height:2rem;text-align:center}.ngb-dp-navigation-select{display:flex;flex:1 1 9rem}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbDatepickerNavigation;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive that marks the content template that customizes the way datepicker months are displayed\n *\n * @since 5.3.0\n */\nlet NgbDatepickerContent = /*#__PURE__*/(() => {\n  class NgbDatepickerContent {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbDatepickerContent_Factory(t) {\n      return new (t || NgbDatepickerContent)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbDatepickerContent,\n      selectors: [[\"ng-template\", \"ngbDatepickerContent\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbDatepickerContent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component that renders one month including all the days, weekdays and week numbers. Can be used inside\n * the `<ng-template ngbDatepickerMonths></ng-template>` when you want to customize months layout.\n *\n * For a usage example, see [custom month layout demo](#/components/datepicker/examples#custommonth)\n *\n * @since 5.3.0\n */\nlet NgbDatepickerMonth = /*#__PURE__*/(() => {\n  class NgbDatepickerMonth {\n    constructor() {\n      this._keyboardService = inject(NgbDatepickerKeyboardService);\n      this._service = inject(NgbDatepickerService);\n      this.i18n = inject(NgbDatepickerI18n);\n      this.datepicker = inject(NgbDatepicker);\n    }\n    /**\n     * The first date of month to be rendered.\n     *\n     * This month must one of the months present in the\n     * [datepicker state](#/components/datepicker/api#NgbDatepickerState).\n     */\n    set month(month) {\n      this.viewModel = this._service.getMonth(month);\n    }\n    onKeyDown(event) {\n      this._keyboardService.processKey(event, this.datepicker);\n    }\n    doSelect(day) {\n      if (!day.context.disabled && !day.hidden) {\n        this.datepicker.onDateSelect(day.date);\n      }\n    }\n    static #_ = this.ɵfac = function NgbDatepickerMonth_Factory(t) {\n      return new (t || NgbDatepickerMonth)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbDatepickerMonth,\n      selectors: [[\"ngb-datepicker-month\"]],\n      hostAttrs: [\"role\", \"grid\"],\n      hostBindings: function NgbDatepickerMonth_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown\", function NgbDatepickerMonth_keydown_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          });\n        }\n      },\n      inputs: {\n        month: \"month\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 3,\n      vars: 1,\n      consts: [[\"class\", \"ngb-dp-week ngb-dp-weekdays\", \"role\", \"row\"], [\"role\", \"row\", 1, \"ngb-dp-week\", \"ngb-dp-weekdays\"], [\"class\", \"ngb-dp-weekday ngb-dp-showweek small\"], [1, \"ngb-dp-weekday\", \"ngb-dp-showweek\", \"small\"], [\"role\", \"columnheader\", 1, \"ngb-dp-weekday\", \"small\"], [\"class\", \"ngb-dp-weekday small\", \"role\", \"columnheader\"], [\"class\", \"ngb-dp-week\", \"role\", \"row\"], [\"role\", \"row\", 1, \"ngb-dp-week\"], [\"class\", \"ngb-dp-week-number small text-muted\"], [1, \"ngb-dp-week-number\", \"small\", \"text-muted\"], [\"role\", \"gridcell\", 1, \"ngb-dp-day\", 3, \"tabindex\", \"click\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"class\", \"ngb-dp-day\", \"role\", \"gridcell\", 3, \"disabled\", \"tabindex\", \"hidden\", \"ngb-dp-today\"]],\n      template: function NgbDatepickerMonth_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, NgbDatepickerMonth_Conditional_0_Template, 4, 1, \"div\", 0);\n          i0.ɵɵrepeaterCreate(1, NgbDatepickerMonth_For_2_Template, 1, 1, null, null, i0.ɵɵrepeaterTrackByIdentity);\n        }\n        if (rf & 2) {\n          i0.ɵɵconditional(0, ctx.viewModel.weekdays.length > 0 ? 0 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵrepeater(ctx.viewModel.weeks);\n        }\n      },\n      dependencies: [NgTemplateOutlet],\n      styles: [\"ngb-datepicker-month{display:block}.ngb-dp-weekday,.ngb-dp-week-number{line-height:2rem;text-align:center;font-style:italic}.ngb-dp-weekday{color:var(--bs-info)}.ngb-dp-week{border-radius:.25rem;display:flex}.ngb-dp-weekdays{border-bottom:1px solid var(--bs-border-color);border-radius:0;background-color:var(--bs-tertiary-bg)}.ngb-dp-day,.ngb-dp-weekday,.ngb-dp-week-number{width:2rem;height:2rem}.ngb-dp-day{cursor:pointer}.ngb-dp-day.disabled,.ngb-dp-day.hidden{cursor:default;pointer-events:none}.ngb-dp-day[tabindex=\\\"0\\\"]{z-index:1}\\n\"],\n      encapsulation: 2\n    });\n  }\n  return NgbDatepickerMonth;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A highly configurable component that helps you with selecting calendar dates.\n *\n * `NgbDatepicker` is meant to be displayed inline on a page or put inside a popup.\n */\nlet NgbDatepicker = /*#__PURE__*/(() => {\n  class NgbDatepicker {\n    constructor() {\n      this.injector = inject(Injector);\n      this._service = inject(NgbDatepickerService);\n      this._calendar = inject(NgbCalendar);\n      this._i18n = inject(NgbDatepickerI18n);\n      this._config = inject(NgbDatepickerConfig);\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this._ngbDateAdapter = inject(NgbDateAdapter);\n      this._ngZone = inject(NgZone);\n      this._destroyRef = inject(DestroyRef);\n      this._controlValue = null;\n      this._publicState = {};\n      /**\n       * The reference to a custom template for the day.\n       *\n       * Allows to completely override the way a day 'cell' in the calendar is displayed.\n       *\n       * See [`DayTemplateContext`](#/components/datepicker/api#DayTemplateContext) for the data you get inside.\n       */\n      this.dayTemplate = this._config.dayTemplate;\n      /**\n       * The callback to pass any arbitrary data to the template cell via the\n       * [`DayTemplateContext`](#/components/datepicker/api#DayTemplateContext)'s `data` parameter.\n       *\n       * `current` is the month that is currently displayed by the datepicker.\n       *\n       * @since 3.3.0\n       */\n      this.dayTemplateData = this._config.dayTemplateData;\n      /**\n       * The number of months to display.\n       */\n      this.displayMonths = this._config.displayMonths;\n      /**\n       * The first day of the week.\n       *\n       * With default calendar we use ISO 8601: 'weekday' is 1=Mon ... 7=Sun.\n       */\n      this.firstDayOfWeek = this._config.firstDayOfWeek;\n      /**\n       * The reference to the custom template for the datepicker footer.\n       *\n       * @since 3.3.0\n       */\n      this.footerTemplate = this._config.footerTemplate;\n      /**\n       * The callback to mark some dates as disabled.\n       *\n       * It is called for each new date when navigating to a different month.\n       *\n       * `current` is the month that is currently displayed by the datepicker.\n       */\n      this.markDisabled = this._config.markDisabled;\n      /**\n       * The latest date that can be displayed or selected.\n       *\n       * If not provided, 'year' select box will display 10 years after the current month.\n       */\n      this.maxDate = this._config.maxDate;\n      /**\n       * The earliest date that can be displayed or selected.\n       *\n       * If not provided, 'year' select box will display 10 years before the current month.\n       */\n      this.minDate = this._config.minDate;\n      /**\n       * Navigation type.\n       *\n       * * `\"select\"` - select boxes for month and navigation arrows\n       * * `\"arrows\"` - only navigation arrows\n       * * `\"none\"` - no navigation visible at all\n       */\n      this.navigation = this._config.navigation;\n      /**\n       * The way of displaying days that don't belong to the current month.\n       *\n       * * `\"visible\"` - days are visible\n       * * `\"hidden\"` - days are hidden, white space preserved\n       * * `\"collapsed\"` - days are collapsed, so the datepicker height might change between months\n       *\n       * For the 2+ months view, days in between months are never shown.\n       */\n      this.outsideDays = this._config.outsideDays;\n      /**\n       * If `true`, week numbers will be displayed.\n       */\n      this.showWeekNumbers = this._config.showWeekNumbers;\n      /**\n       * The date to open calendar with.\n       *\n       * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.\n       * If nothing or invalid date is provided, calendar will open with current month.\n       *\n       * You could use `navigateTo(date)` method as an alternative.\n       */\n      this.startDate = this._config.startDate;\n      /**\n       * The way weekdays should be displayed.\n       *\n       * * `true` - weekdays are displayed using default width\n       * * `false` - weekdays are not displayed\n       * * `TranslationWidth` - weekdays are displayed using specified width\n       *\n       * @since 9.1.0\n       */\n      this.weekdays = this._config.weekdays;\n      /**\n       * An event emitted right before the navigation happens and displayed month changes.\n       *\n       * See [`NgbDatepickerNavigateEvent`](#/components/datepicker/api#NgbDatepickerNavigateEvent) for the payload info.\n       */\n      this.navigate = new EventEmitter();\n      /**\n       * An event emitted when user selects a date using keyboard or mouse.\n       *\n       * The payload of the event is currently selected `NgbDate`.\n       *\n       * @since 5.2.0\n       */\n      this.dateSelect = new EventEmitter();\n      this.onChange = _ => {};\n      this.onTouched = () => {};\n      const cd = inject(ChangeDetectorRef);\n      this._service.dateSelect$.pipe(takeUntilDestroyed()).subscribe(date => {\n        this.dateSelect.emit(date);\n      });\n      this._service.model$.pipe(takeUntilDestroyed()).subscribe(model => {\n        const newDate = model.firstDate;\n        const oldDate = this.model ? this.model.firstDate : null;\n        // update public state\n        this._publicState = {\n          maxDate: model.maxDate,\n          minDate: model.minDate,\n          firstDate: model.firstDate,\n          lastDate: model.lastDate,\n          focusedDate: model.focusDate,\n          months: model.months.map(viewModel => viewModel.firstDate)\n        };\n        let navigationPrevented = false;\n        // emitting navigation event if the first month changes\n        if (!newDate.equals(oldDate)) {\n          this.navigate.emit({\n            current: oldDate ? {\n              year: oldDate.year,\n              month: oldDate.month\n            } : null,\n            next: {\n              year: newDate.year,\n              month: newDate.month\n            },\n            preventDefault: () => navigationPrevented = true\n          });\n          // can't prevent the very first navigation\n          if (navigationPrevented && oldDate !== null) {\n            this._service.open(oldDate);\n            return;\n          }\n        }\n        const newSelectedDate = model.selectedDate;\n        const newFocusedDate = model.focusDate;\n        const oldFocusedDate = this.model ? this.model.focusDate : null;\n        this.model = model;\n        // handling selection change\n        if (isChangedDate(newSelectedDate, this._controlValue)) {\n          this._controlValue = newSelectedDate;\n          this.onTouched();\n          this.onChange(this._ngbDateAdapter.toModel(newSelectedDate));\n        }\n        // handling focus change\n        if (isChangedDate(newFocusedDate, oldFocusedDate) && oldFocusedDate && model.focusVisible) {\n          this.focus();\n        }\n        cd.markForCheck();\n      });\n    }\n    /**\n     *  Returns the readonly public state of the datepicker\n     *\n     * @since 5.2.0\n     */\n    get state() {\n      return this._publicState;\n    }\n    /**\n     *  Returns the calendar service used in the specific datepicker instance.\n     *\n     *  @since 5.3.0\n     */\n    get calendar() {\n      return this._calendar;\n    }\n    /**\n     * Returns the i18n service used in the specific datepicker instance.\n     *\n     * @since 14.2.0\n     */\n    get i18n() {\n      return this._i18n;\n    }\n    /**\n     *  Focuses on given date.\n     */\n    focusDate(date) {\n      this._service.focus(NgbDate.from(date));\n    }\n    /**\n     *  Selects focused date.\n     */\n    focusSelect() {\n      this._service.focusSelect();\n    }\n    focus() {\n      this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(() => this._nativeElement.querySelector('div.ngb-dp-day[tabindex=\"0\"]')?.focus());\n    }\n    /**\n     * Navigates to the provided date.\n     *\n     * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.\n     * If nothing or invalid date provided calendar will open current month.\n     *\n     * Use the `[startDate]` input as an alternative.\n     */\n    navigateTo(date) {\n      this._service.open(NgbDate.from(date ? date.day ? date : {\n        ...date,\n        day: 1\n      } : null));\n    }\n    ngAfterViewInit() {\n      this._ngZone.runOutsideAngular(() => {\n        const focusIns$ = fromEvent(this._contentEl.nativeElement, 'focusin');\n        const focusOuts$ = fromEvent(this._contentEl.nativeElement, 'focusout');\n        // we're changing 'focusVisible' only when entering or leaving months view\n        // and ignoring all focus events where both 'target' and 'related' target are day cells\n        merge(focusIns$, focusOuts$).pipe(filter(focusEvent => {\n          const target = focusEvent.target;\n          const relatedTarget = focusEvent.relatedTarget;\n          return !(target?.classList.contains('ngb-dp-day') && relatedTarget?.classList.contains('ngb-dp-day') && this._nativeElement.contains(target) && this._nativeElement.contains(relatedTarget));\n        }), takeUntilDestroyed(this._destroyRef)).subscribe(({\n          type\n        }) => this._ngZone.run(() => this._service.set({\n          focusVisible: type === 'focusin'\n        })));\n      });\n    }\n    ngOnInit() {\n      if (this.model === undefined) {\n        const inputs = {};\n        ['dayTemplateData', 'displayMonths', 'markDisabled', 'firstDayOfWeek', 'navigation', 'minDate', 'maxDate', 'outsideDays', 'weekdays'].forEach(name => inputs[name] = this[name]);\n        this._service.set(inputs);\n        this.navigateTo(this.startDate);\n      }\n      if (!this.dayTemplate) {\n        this.dayTemplate = this._defaultDayTemplate;\n      }\n    }\n    ngOnChanges(changes) {\n      const inputs = {};\n      ['dayTemplateData', 'displayMonths', 'markDisabled', 'firstDayOfWeek', 'navigation', 'minDate', 'maxDate', 'outsideDays', 'weekdays'].filter(name => name in changes).forEach(name => inputs[name] = this[name]);\n      this._service.set(inputs);\n      if ('startDate' in changes) {\n        const {\n          currentValue,\n          previousValue\n        } = changes.startDate;\n        if (isChangedMonth(previousValue, currentValue)) {\n          this.navigateTo(this.startDate);\n        }\n      }\n    }\n    onDateSelect(date) {\n      this._service.focus(date);\n      this._service.select(date, {\n        emitEvent: true\n      });\n    }\n    onNavigateDateSelect(date) {\n      this._service.open(date);\n    }\n    onNavigateEvent(event) {\n      switch (event) {\n        case NavigationEvent.PREV:\n          this._service.open(this._calendar.getPrev(this.model.firstDate, 'm', 1));\n          break;\n        case NavigationEvent.NEXT:\n          this._service.open(this._calendar.getNext(this.model.firstDate, 'm', 1));\n          break;\n      }\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    setDisabledState(disabled) {\n      this._service.set({\n        disabled\n      });\n    }\n    writeValue(value) {\n      this._controlValue = NgbDate.from(this._ngbDateAdapter.fromModel(value));\n      this._service.select(this._controlValue);\n    }\n    static #_ = this.ɵfac = function NgbDatepicker_Factory(t) {\n      return new (t || NgbDatepicker)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbDatepicker,\n      selectors: [[\"ngb-datepicker\"]],\n      contentQueries: function NgbDatepicker_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbDatepickerContent, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTemplateFromContent = _t.first);\n        }\n      },\n      viewQuery: function NgbDatepicker_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c4, 7);\n          i0.ɵɵviewQuery(_c5, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._defaultDayTemplate = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._contentEl = _t.first);\n        }\n      },\n      hostVars: 2,\n      hostBindings: function NgbDatepicker_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"disabled\", ctx.model.disabled);\n        }\n      },\n      inputs: {\n        contentTemplate: \"contentTemplate\",\n        dayTemplate: \"dayTemplate\",\n        dayTemplateData: \"dayTemplateData\",\n        displayMonths: \"displayMonths\",\n        firstDayOfWeek: \"firstDayOfWeek\",\n        footerTemplate: \"footerTemplate\",\n        markDisabled: \"markDisabled\",\n        maxDate: \"maxDate\",\n        minDate: \"minDate\",\n        navigation: \"navigation\",\n        outsideDays: \"outsideDays\",\n        showWeekNumbers: \"showWeekNumbers\",\n        startDate: \"startDate\",\n        weekdays: \"weekdays\"\n      },\n      outputs: {\n        navigate: \"navigate\",\n        dateSelect: \"dateSelect\"\n      },\n      exportAs: [\"ngbDatepicker\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => NgbDatepicker),\n        multi: true\n      }, NgbDatepickerService]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      decls: 10,\n      vars: 9,\n      consts: [[\"defaultDayTemplate\", \"\"], [\"defaultContentTemplate\", \"\"], [1, \"ngb-dp-header\"], [3, \"date\", \"months\", \"disabled\", \"showSelect\", \"prevDisabled\", \"nextDisabled\", \"selectBoxes\"], [1, \"ngb-dp-content\"], [\"content\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", \"ngTemplateOutletInjector\"], [3, \"ngTemplateOutlet\"], [\"ngbDatepickerDayView\", \"\", 3, \"date\", \"currentMonth\", \"selected\", \"disabled\", \"focused\"], [1, \"ngb-dp-month\"], [\"class\", \"ngb-dp-month-name\"], [3, \"month\"], [1, \"ngb-dp-month-name\"], [\"class\", \"ngb-dp-month\"], [3, \"date\", \"months\", \"disabled\", \"showSelect\", \"prevDisabled\", \"nextDisabled\", \"selectBoxes\", \"navigate\", \"select\"]],\n      template: function NgbDatepicker_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, NgbDatepicker_ng_template_0_Template, 1, 5, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor)(2, NgbDatepicker_ng_template_2_Template, 2, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n          i0.ɵɵelementStart(4, \"div\", 2);\n          i0.ɵɵtemplate(5, NgbDatepicker_Conditional_5_Template, 1, 7, \"ngb-datepicker-navigation\", 3);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(6, \"div\", 4, 5);\n          i0.ɵɵtemplate(8, NgbDatepicker_ng_template_8_Template, 0, 0, \"ng-template\", 6);\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(9, NgbDatepicker_ng_template_9_Template, 0, 0, \"ng-template\", 7);\n        }\n        if (rf & 2) {\n          const _r3 = i0.ɵɵreference(3);\n          i0.ɵɵadvance(5);\n          i0.ɵɵconditional(5, ctx.navigation !== \"none\" ? 5 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵclassProp(\"ngb-dp-months\", !ctx.contentTemplate);\n          i0.ɵɵadvance(2);\n          i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.contentTemplate || (ctx.contentTemplateFromContent == null ? null : ctx.contentTemplateFromContent.templateRef) || _r3)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(7, _c6, ctx))(\"ngTemplateOutletInjector\", ctx.injector);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngTemplateOutlet\", ctx.footerTemplate);\n        }\n      },\n      dependencies: [NgTemplateOutlet, NgbDatepickerDayView, NgbDatepickerMonth, NgbDatepickerNavigation],\n      styles: [\"ngb-datepicker{border:1px solid var(--bs-border-color);border-radius:.25rem;display:inline-block}ngb-datepicker-month{pointer-events:auto}ngb-datepicker.dropdown-menu{padding:0}ngb-datepicker.disabled .ngb-dp-weekday,ngb-datepicker.disabled .ngb-dp-week-number,ngb-datepicker.disabled .ngb-dp-month-name{color:var(--bs-text-muted)}.ngb-dp-body{z-index:1055}.ngb-dp-header{border-bottom:0;border-radius:.25rem .25rem 0 0;padding-top:.25rem;background-color:var(--bs-tertiary-bg)}.ngb-dp-months{display:flex}.ngb-dp-month{pointer-events:none}.ngb-dp-month-name{font-size:larger;height:2rem;line-height:2rem;text-align:center;background-color:var(--bs-tertiary-bg)}.ngb-dp-month+.ngb-dp-month .ngb-dp-month-name,.ngb-dp-month+.ngb-dp-month .ngb-dp-week{padding-left:1rem}.ngb-dp-month:last-child .ngb-dp-week{padding-right:.25rem}.ngb-dp-month:first-child .ngb-dp-week{padding-left:.25rem}.ngb-dp-month .ngb-dp-week:last-child{padding-bottom:.25rem}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbDatepicker;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst isContainedIn = (element, array) => array ? array.some(item => item.contains(element)) : false;\nconst matchesSelectorIfAny = (element, selector) => !selector || closest(element, selector) != null;\n// we have to add a more significant delay to avoid re-opening when handling (click) on a toggling element\n// TODO: use proper Angular platform detection when NgbAutoClose becomes a service and we can inject PLATFORM_ID\nconst isMobile = (() => {\n  const isIOS = () => /iPad|iPhone|iPod/.test(navigator.userAgent) || /Macintosh/.test(navigator.userAgent) && navigator.maxTouchPoints && navigator.maxTouchPoints > 2;\n  const isAndroid = () => /Android/.test(navigator.userAgent);\n  return typeof navigator !== 'undefined' ? !!navigator.userAgent && (isIOS() || isAndroid()) : false;\n})();\n// setting 'ngbAutoClose' synchronously on mobile results in immediate popup closing\n// when tapping on the triggering element\nconst wrapAsyncForMobile = fn => isMobile ? () => setTimeout(() => fn(), 100) : fn;\nfunction ngbAutoClose(zone, document, type, close, closed$, insideElements, ignoreElements, insideSelector) {\n  // closing on ESC and outside clicks\n  if (type) {\n    zone.runOutsideAngular(wrapAsyncForMobile(() => {\n      const shouldCloseOnClick = event => {\n        const element = event.target;\n        if (event.button === 2 || isContainedIn(element, ignoreElements)) {\n          return false;\n        }\n        if (type === 'inside') {\n          return isContainedIn(element, insideElements) && matchesSelectorIfAny(element, insideSelector);\n        } else if (type === 'outside') {\n          return !isContainedIn(element, insideElements);\n        } /* if (type === true) */else {\n          return matchesSelectorIfAny(element, insideSelector) || !isContainedIn(element, insideElements);\n        }\n      };\n      const escapes$ = fromEvent(document, 'keydown').pipe(takeUntil(closed$), /* eslint-disable-next-line deprecation/deprecation */\n      filter(e => e.which === Key.Escape), tap(e => e.preventDefault()));\n      // we have to pre-calculate 'shouldCloseOnClick' on 'mousedown',\n      // because on 'mouseup' DOM nodes might be detached\n      const mouseDowns$ = fromEvent(document, 'mousedown').pipe(map(shouldCloseOnClick), takeUntil(closed$));\n      const closeableClicks$ = fromEvent(document, 'mouseup').pipe(withLatestFrom(mouseDowns$), filter(([_, shouldClose]) => shouldClose), delay(0), takeUntil(closed$));\n      race([escapes$.pipe(map(_ => 0 /* SOURCE.ESCAPE */)), closeableClicks$.pipe(map(_ => 1 /* SOURCE.CLICK */))]).subscribe(source => zone.run(() => close(source)));\n    }));\n  }\n}\nconst FOCUSABLE_ELEMENTS_SELECTOR = ['a[href]', 'button:not([disabled])', 'input:not([disabled]):not([type=\"hidden\"])', 'select:not([disabled])', 'textarea:not([disabled])', '[contenteditable]', '[tabindex]:not([tabindex=\"-1\"])'].join(', ');\n/**\n * Returns first and last focusable elements inside of a given element based on specific CSS selector\n */\nfunction getFocusableBoundaryElements(element) {\n  const list = Array.from(element.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR)).filter(el => el.tabIndex !== -1);\n  return [list[0], list[list.length - 1]];\n}\n/**\n * Function that enforces browser focus to be trapped inside a DOM element.\n *\n * Works only for clicks inside the element and navigation with 'Tab', ignoring clicks outside of the element\n *\n * @param zone Angular zone\n * @param element The element around which focus will be trapped inside\n * @param stopFocusTrap$ The observable stream. When completed the focus trap will clean up listeners\n * and free internal resources\n * @param refocusOnClick Put the focus back to the last focused element whenever a click occurs on element (default to\n * false)\n */\nconst ngbFocusTrap = (zone, element, stopFocusTrap$, refocusOnClick = false) => {\n  zone.runOutsideAngular(() => {\n    // last focused element\n    const lastFocusedElement$ = fromEvent(element, 'focusin').pipe(takeUntil(stopFocusTrap$), map(e => e.target));\n    // 'tab' / 'shift+tab' stream\n    fromEvent(element, 'keydown').pipe(takeUntil(stopFocusTrap$), /* eslint-disable-next-line deprecation/deprecation */\n    filter(e => e.which === Key.Tab), withLatestFrom(lastFocusedElement$)).subscribe(([tabEvent, focusedElement]) => {\n      const [first, last] = getFocusableBoundaryElements(element);\n      if ((focusedElement === first || focusedElement === element) && tabEvent.shiftKey) {\n        last.focus();\n        tabEvent.preventDefault();\n      }\n      if (focusedElement === last && !tabEvent.shiftKey) {\n        first.focus();\n        tabEvent.preventDefault();\n      }\n    });\n    // inside click\n    if (refocusOnClick) {\n      fromEvent(element, 'click').pipe(takeUntil(stopFocusTrap$), withLatestFrom(lastFocusedElement$), map(arr => arr[1])).subscribe(lastFocusedElement => lastFocusedElement.focus());\n    }\n  });\n};\nlet NgbRTL = /*#__PURE__*/(() => {\n  class NgbRTL {\n    constructor() {\n      this._element = inject(DOCUMENT).documentElement;\n    }\n    isRTL() {\n      return (this._element.getAttribute('dir') || '').toLowerCase() === 'rtl';\n    }\n    static #_ = this.ɵfac = function NgbRTL_Factory(t) {\n      return new (t || NgbRTL)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbRTL,\n      factory: NgbRTL.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbRTL;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst placementSeparator = /\\s+/;\nconst spacesRegExp = /  +/gi;\n/**\n * Matching classes from the Bootstrap ones to the poppers ones.\n * The first index of each array is used for the left to right direction,\n * the second one is used for the right to left, defaulting to the first index (when LTR and RTL lead to the same class)\n *\n * See [Bootstrap alignments](https://getbootstrap.com/docs/5.1/components/dropdowns/#alignment-options)\n * and [Popper placements](https://popper.js.org/docs/v2/constructors/#options)\n */\nconst bootstrapPopperMatches = {\n  top: ['top'],\n  bottom: ['bottom'],\n  start: ['left', 'right'],\n  left: ['left'],\n  end: ['right', 'left'],\n  right: ['right'],\n  'top-start': ['top-start', 'top-end'],\n  'top-left': ['top-start'],\n  'top-end': ['top-end', 'top-start'],\n  'top-right': ['top-end'],\n  'bottom-start': ['bottom-start', 'bottom-end'],\n  'bottom-left': ['bottom-start'],\n  'bottom-end': ['bottom-end', 'bottom-start'],\n  'bottom-right': ['bottom-end'],\n  'start-top': ['left-start', 'right-start'],\n  'left-top': ['left-start'],\n  'start-bottom': ['left-end', 'right-end'],\n  'left-bottom': ['left-end'],\n  'end-top': ['right-start', 'left-start'],\n  'right-top': ['right-start'],\n  'end-bottom': ['right-end', 'left-end'],\n  'right-bottom': ['right-end']\n};\nfunction getPopperClassPlacement(placement, isRTL) {\n  const [leftClass, rightClass] = bootstrapPopperMatches[placement];\n  return isRTL ? rightClass || leftClass : leftClass;\n}\nconst popperStartPrimaryPlacement = /^left/;\nconst popperEndPrimaryPlacement = /^right/;\nconst popperStartSecondaryPlacement = /^start/;\nconst popperEndSecondaryPlacement = /^end/;\nfunction getBootstrapBaseClassPlacement(baseClass, placement) {\n  let [primary, secondary] = placement.split('-');\n  const newPrimary = primary.replace(popperStartPrimaryPlacement, 'start').replace(popperEndPrimaryPlacement, 'end');\n  let classnames = [newPrimary];\n  if (secondary) {\n    let newSecondary = secondary;\n    if (primary === 'left' || primary === 'right') {\n      newSecondary = newSecondary.replace(popperStartSecondaryPlacement, 'top').replace(popperEndSecondaryPlacement, 'bottom');\n    }\n    classnames.push(`${newPrimary}-${newSecondary}`);\n  }\n  if (baseClass) {\n    classnames = classnames.map(classname => `${baseClass}-${classname}`);\n  }\n  return classnames.join(' ');\n}\n/*\n * Accept the placement array and applies the appropriate placement dependent on the viewport.\n * Returns the applied placement.\n * In case of auto placement, placements are selected in order\n *   'top', 'bottom', 'start', 'end',\n *   'top-start', 'top-end',\n *   'bottom-start', 'bottom-end',\n *   'start-top', 'start-bottom',\n *   'end-top', 'end-bottom'.\n * */\nfunction getPopperOptions({\n  placement,\n  baseClass\n}, rtl) {\n  let placementVals = Array.isArray(placement) ? placement : placement.split(placementSeparator);\n  // No need to consider left and right here, as start and end are enough, and it is used for 'auto' placement only\n  const allowedPlacements = ['top', 'bottom', 'start', 'end', 'top-start', 'top-end', 'bottom-start', 'bottom-end', 'start-top', 'start-bottom', 'end-top', 'end-bottom'];\n  // replace auto placement with other placements\n  let hasAuto = placementVals.findIndex(val => val === 'auto');\n  if (hasAuto >= 0) {\n    allowedPlacements.forEach(function (obj) {\n      if (placementVals.find(val => val.search('^' + obj) !== -1) == null) {\n        placementVals.splice(hasAuto++, 1, obj);\n      }\n    });\n  }\n  const popperPlacements = placementVals.map(_placement => {\n    return getPopperClassPlacement(_placement, rtl.isRTL());\n  });\n  let mainPlacement = popperPlacements.shift();\n  const bsModifier = {\n    name: 'bootstrapClasses',\n    enabled: !!baseClass,\n    phase: 'write',\n    fn({\n      state\n    }) {\n      const bsClassRegExp = new RegExp(baseClass + '(-[a-z]+)*', 'gi');\n      const popperElement = state.elements.popper;\n      const popperPlacement = state.placement;\n      let className = popperElement.className;\n      // Remove old bootstrap classes\n      className = className.replace(bsClassRegExp, '');\n      // Add current placements\n      className += ` ${getBootstrapBaseClassPlacement(baseClass, popperPlacement)}`;\n      // Remove multiple spaces\n      className = className.trim().replace(spacesRegExp, ' ');\n      // Reassign\n      popperElement.className = className;\n    }\n  };\n  return {\n    placement: mainPlacement,\n    modifiers: [bsModifier, flip, preventOverflow, arrow, {\n      enabled: true,\n      name: 'flip',\n      options: {\n        fallbackPlacements: popperPlacements\n      }\n    }, {\n      enabled: true,\n      name: 'preventOverflow',\n      phase: 'main',\n      fn: function () {}\n    }]\n  };\n}\nfunction noop(arg) {\n  return arg;\n}\nfunction ngbPositioning() {\n  const rtl = inject(NgbRTL);\n  let popperInstance = null;\n  return {\n    createPopper(positioningOption) {\n      if (!popperInstance) {\n        const updatePopperOptions = positioningOption.updatePopperOptions || noop;\n        let popperOptions = updatePopperOptions(getPopperOptions(positioningOption, rtl));\n        popperInstance = createPopperLite(positioningOption.hostElement, positioningOption.targetElement, popperOptions);\n      }\n    },\n    update() {\n      if (popperInstance) {\n        popperInstance.update();\n      }\n    },\n    setOptions(positioningOption) {\n      if (popperInstance) {\n        const updatePopperOptions = positioningOption.updatePopperOptions || noop;\n        let popperOptions = updatePopperOptions(getPopperOptions(positioningOption, rtl));\n        popperInstance.setOptions(popperOptions);\n      }\n    },\n    destroy() {\n      if (popperInstance) {\n        popperInstance.destroy();\n        popperInstance = null;\n      }\n    }\n  };\n}\nfunction NGB_DATEPICKER_PARSER_FORMATTER_FACTORY() {\n  return new NgbDateISOParserFormatter();\n}\n/**\n * An abstract service for parsing and formatting dates for the\n * [`NgbInputDatepicker`](#/components/datepicker/api#NgbInputDatepicker) directive.\n * Converts between the internal `NgbDateStruct` model presentation and a `string` that is displayed in the\n * input element.\n *\n * When user types something in the input this service attempts to parse it into a `NgbDateStruct` object.\n * And vice versa, when users selects a date in the calendar with the mouse, it must be displayed as a `string`\n * in the input.\n *\n * Default implementation uses the ISO 8601 format, but you can provide another implementation via DI\n * to use an alternative string format or a custom parsing logic.\n *\n * See the [date format overview](#/components/datepicker/overview#date-model) for more details.\n */\nlet NgbDateParserFormatter = /*#__PURE__*/(() => {\n  class NgbDateParserFormatter {\n    static #_ = this.ɵfac = function NgbDateParserFormatter_Factory(t) {\n      return new (t || NgbDateParserFormatter)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDateParserFormatter,\n      factory: () => NGB_DATEPICKER_PARSER_FORMATTER_FACTORY(),\n      providedIn: 'root'\n    });\n  }\n  return NgbDateParserFormatter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbDateISOParserFormatter = /*#__PURE__*/(() => {\n  class NgbDateISOParserFormatter extends NgbDateParserFormatter {\n    parse(value) {\n      if (value != null) {\n        const dateParts = value.trim().split('-');\n        if (dateParts.length === 1 && isNumber(dateParts[0])) {\n          return {\n            year: toInteger(dateParts[0]),\n            month: null,\n            day: null\n          };\n        } else if (dateParts.length === 2 && isNumber(dateParts[0]) && isNumber(dateParts[1])) {\n          return {\n            year: toInteger(dateParts[0]),\n            month: toInteger(dateParts[1]),\n            day: null\n          };\n        } else if (dateParts.length === 3 && isNumber(dateParts[0]) && isNumber(dateParts[1]) && isNumber(dateParts[2])) {\n          return {\n            year: toInteger(dateParts[0]),\n            month: toInteger(dateParts[1]),\n            day: toInteger(dateParts[2])\n          };\n        }\n      }\n      return null;\n    }\n    format(date) {\n      return date ? `${date.year}-${isNumber(date.month) ? padNumber(date.month) : ''}-${isNumber(date.day) ? padNumber(date.day) : ''}` : '';\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDateISOParserFormatter_BaseFactory;\n      return function NgbDateISOParserFormatter_Factory(t) {\n        return (ɵNgbDateISOParserFormatter_BaseFactory || (ɵNgbDateISOParserFormatter_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDateISOParserFormatter)))(t || NgbDateISOParserFormatter);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDateISOParserFormatter,\n      factory: NgbDateISOParserFormatter.ɵfac\n    });\n  }\n  return NgbDateISOParserFormatter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbDatepickerInput`](#/components/datepicker/api#NgbDatepicker) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the datepicker inputs used in the application.\n *\n * @since 5.2.0\n */\nlet NgbInputDatepickerConfig = /*#__PURE__*/(() => {\n  class NgbInputDatepickerConfig extends NgbDatepickerConfig {\n    constructor() {\n      super(...arguments);\n      this.autoClose = true;\n      this.placement = ['bottom-start', 'bottom-end', 'top-start', 'top-end'];\n      this.popperOptions = options => options;\n      this.restoreFocus = true;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbInputDatepickerConfig_BaseFactory;\n      return function NgbInputDatepickerConfig_Factory(t) {\n        return (ɵNgbInputDatepickerConfig_BaseFactory || (ɵNgbInputDatepickerConfig_BaseFactory = i0.ɵɵgetInheritedFactory(NgbInputDatepickerConfig)))(t || NgbInputDatepickerConfig);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbInputDatepickerConfig,\n      factory: NgbInputDatepickerConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbInputDatepickerConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction addPopperOffset(offset$1) {\n  return options => {\n    options.modifiers.push(offset, {\n      name: 'offset',\n      options: {\n        offset: () => offset$1\n      }\n    });\n    return options;\n  };\n}\n\n/**\n * A directive that allows to stick a datepicker popup to an input field.\n *\n * Manages interaction with the input field itself, does value formatting and provides forms integration.\n */\nlet NgbInputDatepicker = /*#__PURE__*/(() => {\n  class NgbInputDatepicker {\n    constructor() {\n      this._parserFormatter = inject(NgbDateParserFormatter);\n      this._elRef = inject(ElementRef);\n      this._vcRef = inject(ViewContainerRef);\n      this._ngZone = inject(NgZone);\n      this._calendar = inject(NgbCalendar);\n      this._dateAdapter = inject(NgbDateAdapter);\n      this._document = inject(DOCUMENT);\n      this._changeDetector = inject(ChangeDetectorRef);\n      this._config = inject(NgbInputDatepickerConfig);\n      this._cRef = null;\n      this._disabled = false;\n      this._elWithFocus = null;\n      this._model = null;\n      this._positioning = ngbPositioning();\n      this._destroyCloseHandlers$ = new Subject();\n      /**\n       * Indicates whether the datepicker popup should be closed automatically after date selection / outside click or not.\n       *\n       * * `true` - the popup will close on both date selection and outside click.\n       * * `false` - the popup can only be closed manually via `close()` or `toggle()` methods.\n       * * `\"inside\"` - the popup will close on date selection, but not outside clicks.\n       * * `\"outside\"` - the popup will close only on the outside click and not on date selection/inside clicks.\n       *\n       * @since 3.0.0\n       */\n      this.autoClose = this._config.autoClose;\n      /**\n       * The preferred placement of the datepicker popup, among the [possible values](#/guides/positioning#api).\n       *\n       * The default order of preference is `\"bottom-start bottom-end top-start top-end\"`\n       *\n       * Please see the [positioning overview](#/positioning) for more details.\n       */\n      this.placement = this._config.placement;\n      /**\n       * Allows to change default Popper options when positioning the popup.\n       * Receives current popper options and returns modified ones.\n       *\n       * @since 13.1.0\n       */\n      this.popperOptions = this._config.popperOptions;\n      /**\n       * A selector specifying the element the datepicker popup should be appended to.\n       *\n       * Currently only supports `\"body\"`.\n       */\n      this.container = this._config.container;\n      /**\n       * A css selector or html element specifying the element the datepicker popup should be positioned against.\n       *\n       * By default the input is used as a target.\n       *\n       * @since 4.2.0\n       */\n      this.positionTarget = this._config.positionTarget;\n      /**\n       * An event emitted when user selects a date using keyboard or mouse.\n       *\n       * The payload of the event is currently selected `NgbDate`.\n       *\n       * @since 1.1.1\n       */\n      this.dateSelect = new EventEmitter();\n      /**\n       * Event emitted right after the navigation happens and displayed month changes.\n       *\n       * See [`NgbDatepickerNavigateEvent`](#/components/datepicker/api#NgbDatepickerNavigateEvent) for the payload info.\n       */\n      this.navigate = new EventEmitter();\n      /**\n       * An event fired after closing datepicker window.\n       *\n       * @since 4.2.0\n       */\n      this.closed = new EventEmitter();\n      this._onChange = _ => {};\n      this._onTouched = () => {};\n      this._validatorChange = () => {};\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = value === '' || value && value !== 'false';\n      if (this.isOpen()) {\n        this._cRef.instance.setDisabledState(this._disabled);\n      }\n    }\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    registerOnValidatorChange(fn) {\n      this._validatorChange = fn;\n    }\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    validate(c) {\n      const {\n        value\n      } = c;\n      if (value != null) {\n        const ngbDate = this._fromDateStruct(this._dateAdapter.fromModel(value));\n        if (!ngbDate) {\n          return {\n            ngbDate: {\n              invalid: value\n            }\n          };\n        }\n        if (this.minDate && ngbDate.before(NgbDate.from(this.minDate))) {\n          return {\n            ngbDate: {\n              minDate: {\n                minDate: this.minDate,\n                actual: value\n              }\n            }\n          };\n        }\n        if (this.maxDate && ngbDate.after(NgbDate.from(this.maxDate))) {\n          return {\n            ngbDate: {\n              maxDate: {\n                maxDate: this.maxDate,\n                actual: value\n              }\n            }\n          };\n        }\n      }\n      return null;\n    }\n    writeValue(value) {\n      this._model = this._fromDateStruct(this._dateAdapter.fromModel(value));\n      this._writeModelValue(this._model);\n    }\n    manualDateChange(value, updateView = false) {\n      const inputValueChanged = value !== this._inputValue;\n      if (inputValueChanged) {\n        this._inputValue = value;\n        this._model = this._fromDateStruct(this._parserFormatter.parse(value));\n      }\n      if (inputValueChanged || !updateView) {\n        this._onChange(this._model ? this._dateAdapter.toModel(this._model) : value === '' ? null : value);\n      }\n      if (updateView && this._model) {\n        this._writeModelValue(this._model);\n      }\n    }\n    isOpen() {\n      return !!this._cRef;\n    }\n    /**\n     * Opens the datepicker popup.\n     *\n     * If the related form control contains a valid date, the corresponding month will be opened.\n     */\n    open() {\n      if (!this.isOpen()) {\n        this._cRef = this._vcRef.createComponent(NgbDatepicker);\n        this._applyPopupStyling(this._cRef.location.nativeElement);\n        this._applyDatepickerInputs(this._cRef);\n        this._subscribeForDatepickerOutputs(this._cRef.instance);\n        this._cRef.instance.ngOnInit();\n        this._cRef.instance.writeValue(this._dateAdapter.toModel(this._model));\n        // date selection event handling\n        this._cRef.instance.registerOnChange(selectedDate => {\n          this.writeValue(selectedDate);\n          this._onChange(selectedDate);\n          this._onTouched();\n        });\n        this._cRef.changeDetectorRef.detectChanges();\n        this._cRef.instance.setDisabledState(this.disabled);\n        if (this.container === 'body') {\n          this._document.querySelector(this.container)?.appendChild(this._cRef.location.nativeElement);\n        }\n        // focus handling\n        this._elWithFocus = this._document.activeElement;\n        ngbFocusTrap(this._ngZone, this._cRef.location.nativeElement, this.closed, true);\n        setTimeout(() => this._cRef?.instance.focus());\n        let hostElement;\n        if (isString(this.positionTarget)) {\n          hostElement = this._document.querySelector(this.positionTarget);\n        } else if (this.positionTarget instanceof HTMLElement) {\n          hostElement = this.positionTarget;\n        } else {\n          hostElement = this._elRef.nativeElement;\n        }\n        if (this.positionTarget && !hostElement) {\n          throw new Error('ngbDatepicker could not find element declared in [positionTarget] to position against.');\n        }\n        // Setting up popper and scheduling updates when zone is stable\n        this._ngZone.runOutsideAngular(() => {\n          if (this._cRef && hostElement) {\n            this._positioning.createPopper({\n              hostElement,\n              targetElement: this._cRef.location.nativeElement,\n              placement: this.placement,\n              appendToBody: this.container === 'body',\n              updatePopperOptions: options => this.popperOptions(addPopperOffset([0, 2])(options))\n            });\n            this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positioning.update());\n          }\n        });\n        this._setCloseHandlers();\n      }\n    }\n    /**\n     * Closes the datepicker popup.\n     */\n    close() {\n      if (this.isOpen()) {\n        this._vcRef.remove(this._vcRef.indexOf(this._cRef.hostView));\n        this._cRef = null;\n        this._positioning.destroy();\n        this._zoneSubscription?.unsubscribe();\n        this._destroyCloseHandlers$.next();\n        this.closed.emit();\n        this._changeDetector.markForCheck();\n        // restore focus\n        let elementToFocus = this._elWithFocus;\n        if (isString(this.restoreFocus)) {\n          elementToFocus = this._document.querySelector(this.restoreFocus);\n        } else if (this.restoreFocus !== undefined) {\n          elementToFocus = this.restoreFocus;\n        }\n        // in IE document.activeElement can contain an object without 'focus()' sometimes\n        if (elementToFocus && elementToFocus['focus']) {\n          elementToFocus.focus();\n        } else {\n          this._document.body.focus();\n        }\n      }\n    }\n    /**\n     * Toggles the datepicker popup.\n     */\n    toggle() {\n      if (this.isOpen()) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    /**\n     * Navigates to the provided date.\n     *\n     * With the default calendar we use ISO 8601: 'month' is 1=Jan ... 12=Dec.\n     * If nothing or invalid date provided calendar will open current month.\n     *\n     * Use the `[startDate]` input as an alternative.\n     */\n    navigateTo(date) {\n      if (this.isOpen()) {\n        this._cRef.instance.navigateTo(date);\n      }\n    }\n    onBlur() {\n      this._onTouched();\n    }\n    onFocus() {\n      this._elWithFocus = this._elRef.nativeElement;\n    }\n    ngOnChanges(changes) {\n      if (changes['minDate'] || changes['maxDate']) {\n        this._validatorChange();\n        if (this.isOpen()) {\n          if (changes['minDate']) {\n            this._cRef.setInput('minDate', this.minDate);\n          }\n          if (changes['maxDate']) {\n            this._cRef.setInput('maxDate', this.maxDate);\n          }\n        }\n      }\n      if (changes['datepickerClass']) {\n        const {\n          currentValue,\n          previousValue\n        } = changes['datepickerClass'];\n        this._applyPopupClass(currentValue, previousValue);\n      }\n      if (changes['autoClose'] && this.isOpen()) {\n        this._setCloseHandlers();\n      }\n    }\n    ngOnDestroy() {\n      this.close();\n    }\n    _applyDatepickerInputs(datepickerComponentRef) {\n      ['contentTemplate', 'dayTemplate', 'dayTemplateData', 'displayMonths', 'firstDayOfWeek', 'footerTemplate', 'markDisabled', 'minDate', 'maxDate', 'navigation', 'outsideDays', 'showNavigation', 'showWeekNumbers', 'weekdays'].forEach(inputName => {\n        if (this[inputName] !== undefined) {\n          datepickerComponentRef.setInput(inputName, this[inputName]);\n        }\n      });\n      datepickerComponentRef.setInput('startDate', this.startDate || this._model);\n    }\n    _applyPopupClass(newClass, oldClass) {\n      const popupEl = this._cRef?.location.nativeElement;\n      if (popupEl) {\n        if (newClass) {\n          popupEl.classList.add(newClass);\n        }\n        if (oldClass) {\n          popupEl.classList.remove(oldClass);\n        }\n      }\n    }\n    _applyPopupStyling(nativeElement) {\n      nativeElement.classList.add('dropdown-menu', 'show');\n      if (this.container === 'body') {\n        nativeElement.classList.add('ngb-dp-body');\n      }\n      this._applyPopupClass(this.datepickerClass);\n    }\n    _subscribeForDatepickerOutputs(datepickerInstance) {\n      datepickerInstance.navigate.subscribe(navigateEvent => this.navigate.emit(navigateEvent));\n      datepickerInstance.dateSelect.subscribe(date => {\n        this.dateSelect.emit(date);\n        if (this.autoClose === true || this.autoClose === 'inside') {\n          this.close();\n        }\n      });\n    }\n    _writeModelValue(model) {\n      const value = this._parserFormatter.format(model);\n      this._inputValue = value;\n      this._elRef.nativeElement.value = value;\n      if (this.isOpen()) {\n        this._cRef.instance.writeValue(this._dateAdapter.toModel(model));\n        this._onTouched();\n      }\n    }\n    _fromDateStruct(date) {\n      const ngbDate = date ? new NgbDate(date.year, date.month, date.day) : null;\n      return this._calendar.isValid(ngbDate) ? ngbDate : null;\n    }\n    _setCloseHandlers() {\n      this._destroyCloseHandlers$.next();\n      ngbAutoClose(this._ngZone, this._document, this.autoClose, () => this.close(), this._destroyCloseHandlers$, [], [this._elRef.nativeElement, this._cRef.location.nativeElement]);\n    }\n    static #_ = this.ɵfac = function NgbInputDatepicker_Factory(t) {\n      return new (t || NgbInputDatepicker)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbInputDatepicker,\n      selectors: [[\"input\", \"ngbDatepicker\", \"\"]],\n      hostVars: 1,\n      hostBindings: function NgbInputDatepicker_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"input\", function NgbInputDatepicker_input_HostBindingHandler($event) {\n            return ctx.manualDateChange($event.target.value);\n          })(\"change\", function NgbInputDatepicker_change_HostBindingHandler($event) {\n            return ctx.manualDateChange($event.target.value, true);\n          })(\"focus\", function NgbInputDatepicker_focus_HostBindingHandler() {\n            return ctx.onFocus();\n          })(\"blur\", function NgbInputDatepicker_blur_HostBindingHandler() {\n            return ctx.onBlur();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"disabled\", ctx.disabled);\n        }\n      },\n      inputs: {\n        autoClose: \"autoClose\",\n        contentTemplate: \"contentTemplate\",\n        datepickerClass: \"datepickerClass\",\n        dayTemplate: \"dayTemplate\",\n        dayTemplateData: \"dayTemplateData\",\n        displayMonths: \"displayMonths\",\n        firstDayOfWeek: \"firstDayOfWeek\",\n        footerTemplate: \"footerTemplate\",\n        markDisabled: \"markDisabled\",\n        minDate: \"minDate\",\n        maxDate: \"maxDate\",\n        navigation: \"navigation\",\n        outsideDays: \"outsideDays\",\n        placement: \"placement\",\n        popperOptions: \"popperOptions\",\n        restoreFocus: \"restoreFocus\",\n        showWeekNumbers: \"showWeekNumbers\",\n        startDate: \"startDate\",\n        container: \"container\",\n        positionTarget: \"positionTarget\",\n        weekdays: \"weekdays\",\n        disabled: \"disabled\"\n      },\n      outputs: {\n        dateSelect: \"dateSelect\",\n        navigate: \"navigate\",\n        closed: \"closed\"\n      },\n      exportAs: [\"ngbDatepicker\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => NgbInputDatepicker),\n        multi: true\n      }, {\n        provide: NG_VALIDATORS,\n        useExisting: forwardRef(() => NgbInputDatepicker),\n        multi: true\n      }, {\n        provide: NgbDatepickerConfig,\n        useExisting: NgbInputDatepickerConfig\n      }]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgbInputDatepicker;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbCalendarHijri = /*#__PURE__*/(() => {\n  class NgbCalendarHijri extends NgbCalendar {\n    getDaysPerWeek() {\n      return 7;\n    }\n    getMonths() {\n      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    }\n    getWeeksPerMonth() {\n      return 6;\n    }\n    getNext(date, period = 'd', number = 1) {\n      date = new NgbDate(date.year, date.month, date.day);\n      switch (period) {\n        case 'y':\n          date = this._setYear(date, date.year + number);\n          date.month = 1;\n          date.day = 1;\n          return date;\n        case 'm':\n          date = this._setMonth(date, date.month + number);\n          date.day = 1;\n          return date;\n        case 'd':\n          return this._setDay(date, date.day + number);\n        default:\n          return date;\n      }\n    }\n    getPrev(date, period = 'd', number = 1) {\n      return this.getNext(date, period, -number);\n    }\n    getWeekday(date) {\n      const day = this.toGregorian(date).getDay();\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      return day === 0 ? 7 : day;\n    }\n    getWeekNumber(week, firstDayOfWeek) {\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      if (firstDayOfWeek === 7) {\n        firstDayOfWeek = 0;\n      }\n      const thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;\n      const date = week[thursdayIndex];\n      const jsDate = this.toGregorian(date);\n      jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday\n      const time = jsDate.getTime();\n      const MuhDate = this.toGregorian(new NgbDate(date.year, 1, 1)); // Compare with Muharram 1\n      return Math.floor(Math.round((time - MuhDate.getTime()) / 86400000) / 7) + 1;\n    }\n    getToday() {\n      return this.fromGregorian(new Date());\n    }\n    isValid(date) {\n      return date != null && isNumber(date.year) && isNumber(date.month) && isNumber(date.day) && !isNaN(this.toGregorian(date).getTime());\n    }\n    _setDay(date, day) {\n      day = +day;\n      let mDays = this.getDaysPerMonth(date.month, date.year);\n      if (day <= 0) {\n        while (day <= 0) {\n          date = this._setMonth(date, date.month - 1);\n          mDays = this.getDaysPerMonth(date.month, date.year);\n          day += mDays;\n        }\n      } else if (day > mDays) {\n        while (day > mDays) {\n          day -= mDays;\n          date = this._setMonth(date, date.month + 1);\n          mDays = this.getDaysPerMonth(date.month, date.year);\n        }\n      }\n      date.day = day;\n      return date;\n    }\n    _setMonth(date, month) {\n      month = +month;\n      date.year = date.year + Math.floor((month - 1) / 12);\n      date.month = Math.floor(((month - 1) % 12 + 12) % 12) + 1;\n      return date;\n    }\n    _setYear(date, year) {\n      date.year = +year;\n      return date;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarHijri_BaseFactory;\n      return function NgbCalendarHijri_Factory(t) {\n        return (ɵNgbCalendarHijri_BaseFactory || (ɵNgbCalendarHijri_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarHijri)))(t || NgbCalendarHijri);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarHijri,\n      factory: NgbCalendarHijri.ɵfac\n    });\n  }\n  return NgbCalendarHijri;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Checks if islamic year is a leap year\n */\nfunction isIslamicLeapYear(hYear) {\n  return (14 + 11 * hYear) % 30 < 11;\n}\n/**\n * Checks if gregorian years is a leap year\n */\nfunction isGregorianLeapYear$1(gDate) {\n  const year = gDate.getFullYear();\n  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\n/**\n * Returns the start of Hijri Month.\n * `hMonth` is 0 for Muharram, 1 for Safar, etc.\n * `hYear` is any Hijri hYear.\n */\nfunction getIslamicMonthStart(hYear, hMonth) {\n  return Math.ceil(29.5 * hMonth) + (hYear - 1) * 354 + Math.floor((3 + 11 * hYear) / 30.0);\n}\n/**\n * Returns the start of Hijri year.\n * `year` is any Hijri year.\n */\nfunction getIslamicYearStart(year) {\n  return (year - 1) * 354 + Math.floor((3 + 11 * year) / 30.0);\n}\nfunction mod$1(a, b) {\n  return a - b * Math.floor(a / b);\n}\n/**\n * The civil calendar is one type of Hijri calendars used in islamic countries.\n * Uses a fixed cycle of alternating 29- and 30-day months,\n * with a leap day added to the last month of 11 out of every 30 years.\n * http://cldr.unicode.org/development/development-process/design-proposals/islamic-calendar-types\n * All the calculations here are based on the equations from \"Calendrical Calculations\" By Edward M. Reingold, Nachum\n * Dershowitz.\n */\nconst GREGORIAN_EPOCH$1 = 1721425.5;\nconst ISLAMIC_EPOCH = 1948439.5;\nlet NgbCalendarIslamicCivil = /*#__PURE__*/(() => {\n  class NgbCalendarIslamicCivil extends NgbCalendarHijri {\n    /**\n     * Returns the equivalent islamic(civil) date value for a give input Gregorian date.\n     * `gDate` is a JS Date to be converted to Hijri.\n     */\n    fromGregorian(gDate) {\n      const gYear = gDate.getFullYear(),\n        gMonth = gDate.getMonth(),\n        gDay = gDate.getDate();\n      let julianDay = GREGORIAN_EPOCH$1 - 1 + 365 * (gYear - 1) + Math.floor((gYear - 1) / 4) + -Math.floor((gYear - 1) / 100) + Math.floor((gYear - 1) / 400) + Math.floor((367 * (gMonth + 1) - 362) / 12 + (gMonth + 1 <= 2 ? 0 : isGregorianLeapYear$1(gDate) ? -1 : -2) + gDay);\n      julianDay = Math.floor(julianDay) + 0.5;\n      const days = julianDay - ISLAMIC_EPOCH;\n      const hYear = Math.floor((30 * days + 10646) / 10631.0);\n      let hMonth = Math.ceil((days - 29 - getIslamicYearStart(hYear)) / 29.5);\n      hMonth = Math.min(hMonth, 11);\n      const hDay = Math.ceil(days - getIslamicMonthStart(hYear, hMonth)) + 1;\n      return new NgbDate(hYear, hMonth + 1, hDay);\n    }\n    /**\n     * Returns the equivalent JS date value for a give input islamic(civil) date.\n     * `hDate` is an islamic(civil) date to be converted to Gregorian.\n     */\n    toGregorian(hDate) {\n      const hYear = hDate.year;\n      const hMonth = hDate.month - 1;\n      const hDay = hDate.day;\n      const julianDay = hDay + Math.ceil(29.5 * hMonth) + (hYear - 1) * 354 + Math.floor((3 + 11 * hYear) / 30) + ISLAMIC_EPOCH - 1;\n      const wjd = Math.floor(julianDay - 0.5) + 0.5,\n        depoch = wjd - GREGORIAN_EPOCH$1,\n        quadricent = Math.floor(depoch / 146097),\n        dqc = mod$1(depoch, 146097),\n        cent = Math.floor(dqc / 36524),\n        dcent = mod$1(dqc, 36524),\n        quad = Math.floor(dcent / 1461),\n        dquad = mod$1(dcent, 1461),\n        yindex = Math.floor(dquad / 365);\n      let year = quadricent * 400 + cent * 100 + quad * 4 + yindex;\n      if (!(cent === 4 || yindex === 4)) {\n        year++;\n      }\n      const gYearStart = GREGORIAN_EPOCH$1 + 365 * (year - 1) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400);\n      const yearday = wjd - gYearStart;\n      const tjd = GREGORIAN_EPOCH$1 - 1 + 365 * (year - 1) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400) + Math.floor(739 / 12 + (isGregorianLeapYear$1(new Date(year, 3, 1)) ? -1 : -2) + 1);\n      const leapadj = wjd < tjd ? 0 : isGregorianLeapYear$1(new Date(year, 3, 1)) ? 1 : 2;\n      const month = Math.floor(((yearday + leapadj) * 12 + 373) / 367);\n      const tjd2 = GREGORIAN_EPOCH$1 - 1 + 365 * (year - 1) + Math.floor((year - 1) / 4) - Math.floor((year - 1) / 100) + Math.floor((year - 1) / 400) + Math.floor((367 * month - 362) / 12 + (month <= 2 ? 0 : isGregorianLeapYear$1(new Date(year, month - 1, 1)) ? -1 : -2) + 1);\n      const day = wjd - tjd2 + 1;\n      return new Date(year, month - 1, day);\n    }\n    /**\n     * Returns the number of days in a specific Hijri month.\n     * `month` is 1 for Muharram, 2 for Safar, etc.\n     * `year` is any Hijri year.\n     */\n    getDaysPerMonth(month, year) {\n      year = year + Math.floor(month / 13);\n      month = (month - 1) % 12 + 1;\n      let length = 29 + month % 2;\n      if (month === 12 && isIslamicLeapYear(year)) {\n        length++;\n      }\n      return length;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarIslamicCivil_BaseFactory;\n      return function NgbCalendarIslamicCivil_Factory(t) {\n        return (ɵNgbCalendarIslamicCivil_BaseFactory || (ɵNgbCalendarIslamicCivil_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarIslamicCivil)))(t || NgbCalendarIslamicCivil);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarIslamicCivil,\n      factory: NgbCalendarIslamicCivil.ɵfac\n    });\n  }\n  return NgbCalendarIslamicCivil;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Umalqura calendar is one type of Hijri calendars used in islamic countries.\n * This Calendar is used by Saudi Arabia for administrative purpose.\n * Unlike tabular calendars, the algorithm involves astronomical calculation, but it's still deterministic.\n * http://cldr.unicode.org/development/development-process/design-proposals/islamic-calendar-types\n */\nconst GREGORIAN_FIRST_DATE = new Date(1882, 10, 12);\nconst GREGORIAN_LAST_DATE = new Date(2174, 10, 25);\nconst HIJRI_BEGIN = 1300;\nconst HIJRI_END = 1600;\nconst ONE_DAY = 1000 * 60 * 60 * 24;\nconst MONTH_LENGTH = [\n// 1300-1304\n'101010101010', '110101010100', '111011001001', '011011010100', '011011101010',\n// 1305-1309\n'001101101100', '101010101101', '010101010101', '011010101001', '011110010010',\n// 1310-1314\n'101110101001', '010111010100', '101011011010', '010101011100', '110100101101',\n// 1315-1319\n'011010010101', '011101001010', '101101010100', '101101101010', '010110101101',\n// 1320-1324\n'010010101110', '101001001111', '010100010111', '011010001011', '011010100101',\n// 1325-1329\n'101011010101', '001011010110', '100101011011', '010010011101', '101001001101',\n// 1330-1334\n'110100100110', '110110010101', '010110101100', '100110110110', '001010111010',\n// 1335-1339\n'101001011011', '010100101011', '101010010101', '011011001010', '101011101001',\n// 1340-1344\n'001011110100', '100101110110', '001010110110', '100101010110', '101011001010',\n// 1345-1349\n'101110100100', '101111010010', '010111011001', '001011011100', '100101101101',\n// 1350-1354\n'010101001101', '101010100101', '101101010010', '101110100101', '010110110100',\n// 1355-1359\n'100110110110', '010101010111', '001010010111', '010101001011', '011010100011',\n// 1360-1364\n'011101010010', '101101100101', '010101101010', '101010101011', '010100101011',\n// 1365-1369\n'110010010101', '110101001010', '110110100101', '010111001010', '101011010110',\n// 1370-1374\n'100101010111', '010010101011', '100101001011', '101010100101', '101101010010',\n// 1375-1379\n'101101101010', '010101110101', '001001110110', '100010110111', '010001011011',\n// 1380-1384\n'010101010101', '010110101001', '010110110100', '100111011010', '010011011101',\n// 1385-1389\n'001001101110', '100100110110', '101010101010', '110101010100', '110110110010',\n// 1390-1394\n'010111010101', '001011011010', '100101011011', '010010101011', '101001010101',\n// 1395-1399\n'101101001001', '101101100100', '101101110001', '010110110100', '101010110101',\n// 1400-1404\n'101001010101', '110100100101', '111010010010', '111011001001', '011011010100',\n// 1405-1409\n'101011101001', '100101101011', '010010101011', '101010010011', '110101001001',\n// 1410-1414\n'110110100100', '110110110010', '101010111001', '010010111010', '101001011011',\n// 1415-1419\n'010100101011', '101010010101', '101100101010', '101101010101', '010101011100',\n// 1420-1424\n'010010111101', '001000111101', '100100011101', '101010010101', '101101001010',\n// 1425-1429\n'101101011010', '010101101101', '001010110110', '100100111011', '010010011011',\n// 1430-1434\n'011001010101', '011010101001', '011101010100', '101101101010', '010101101100',\n// 1435-1439\n'101010101101', '010101010101', '101100101001', '101110010010', '101110101001',\n// 1440-1444\n'010111010100', '101011011010', '010101011010', '101010101011', '010110010101',\n// 1445-1449\n'011101001001', '011101100100', '101110101010', '010110110101', '001010110110',\n// 1450-1454\n'101001010110', '111001001101', '101100100101', '101101010010', '101101101010',\n// 1455-1459\n'010110101101', '001010101110', '100100101111', '010010010111', '011001001011',\n// 1460-1464\n'011010100101', '011010101100', '101011010110', '010101011101', '010010011101',\n// 1465-1469\n'101001001101', '110100010110', '110110010101', '010110101010', '010110110101',\n// 1470-1474\n'001011011010', '100101011011', '010010101101', '010110010101', '011011001010',\n// 1475-1479\n'011011100100', '101011101010', '010011110101', '001010110110', '100101010110',\n// 1480-1484\n'101010101010', '101101010100', '101111010010', '010111011001', '001011101010',\n// 1485-1489\n'100101101101', '010010101101', '101010010101', '101101001010', '101110100101',\n// 1490-1494\n'010110110010', '100110110101', '010011010110', '101010010111', '010101000111',\n// 1495-1499\n'011010010011', '011101001001', '101101010101', '010101101010', '101001101011',\n// 1500-1504\n'010100101011', '101010001011', '110101000110', '110110100011', '010111001010',\n// 1505-1509\n'101011010110', '010011011011', '001001101011', '100101001011', '101010100101',\n// 1510-1514\n'101101010010', '101101101001', '010101110101', '000101110110', '100010110111',\n// 1515-1519\n'001001011011', '010100101011', '010101100101', '010110110100', '100111011010',\n// 1520-1524\n'010011101101', '000101101101', '100010110110', '101010100110', '110101010010',\n// 1525-1529\n'110110101001', '010111010100', '101011011010', '100101011011', '010010101011',\n// 1530-1534\n'011001010011', '011100101001', '011101100010', '101110101001', '010110110010',\n// 1535-1539\n'101010110101', '010101010101', '101100100101', '110110010010', '111011001001',\n// 1540-1544\n'011011010010', '101011101001', '010101101011', '010010101011', '101001010101',\n// 1545-1549\n'110100101001', '110101010100', '110110101010', '100110110101', '010010111010',\n// 1550-1554\n'101000111011', '010010011011', '101001001101', '101010101010', '101011010101',\n// 1555-1559\n'001011011010', '100101011101', '010001011110', '101000101110', '110010011010',\n// 1560-1564\n'110101010101', '011010110010', '011010111001', '010010111010', '101001011101',\n// 1565-1569\n'010100101101', '101010010101', '101101010010', '101110101000', '101110110100',\n// 1570-1574\n'010110111001', '001011011010', '100101011010', '101101001010', '110110100100',\n// 1575-1579\n'111011010001', '011011101000', '101101101010', '010101101101', '010100110101',\n// 1580-1584\n'011010010101', '110101001010', '110110101000', '110111010100', '011011011010',\n// 1585-1589\n'010101011011', '001010011101', '011000101011', '101100010101', '101101001010',\n// 1590-1594\n'101110010101', '010110101010', '101010101110', '100100101110', '110010001111',\n// 1595-1599\n'010100100111', '011010010101', '011010101010', '101011010110', '010101011101',\n// 1600\n'001010011101'];\nfunction getDaysDiff(date1, date2) {\n  // Ignores the time part in date1 and date2:\n  const time1 = Date.UTC(date1.getFullYear(), date1.getMonth(), date1.getDate());\n  const time2 = Date.UTC(date2.getFullYear(), date2.getMonth(), date2.getDate());\n  const diff = Math.abs(time1 - time2);\n  return Math.round(diff / ONE_DAY);\n}\nlet NgbCalendarIslamicUmalqura = /*#__PURE__*/(() => {\n  class NgbCalendarIslamicUmalqura extends NgbCalendarIslamicCivil {\n    /**\n     * Returns the equivalent islamic(Umalqura) date value for a give input Gregorian date.\n     * `gdate` is s JS Date to be converted to Hijri.\n     */\n    fromGregorian(gDate) {\n      let hDay = 1,\n        hMonth = 0,\n        hYear = 1300;\n      let daysDiff = getDaysDiff(gDate, GREGORIAN_FIRST_DATE);\n      if (gDate.getTime() - GREGORIAN_FIRST_DATE.getTime() >= 0 && gDate.getTime() - GREGORIAN_LAST_DATE.getTime() <= 0) {\n        let year = 1300;\n        for (let i = 0; i < MONTH_LENGTH.length; i++, year++) {\n          for (let j = 0; j < 12; j++) {\n            let numOfDays = +MONTH_LENGTH[i][j] + 29;\n            if (daysDiff <= numOfDays) {\n              hDay = daysDiff + 1;\n              if (hDay > numOfDays) {\n                hDay = 1;\n                j++;\n              }\n              if (j > 11) {\n                j = 0;\n                year++;\n              }\n              hMonth = j;\n              hYear = year;\n              return new NgbDate(hYear, hMonth + 1, hDay);\n            }\n            daysDiff = daysDiff - numOfDays;\n          }\n        }\n        return null;\n      } else {\n        return super.fromGregorian(gDate);\n      }\n    }\n    /**\n     * Converts the current Hijri date to Gregorian.\n     */\n    toGregorian(hDate) {\n      const hYear = hDate.year;\n      const hMonth = hDate.month - 1;\n      const hDay = hDate.day;\n      let gDate = new Date(GREGORIAN_FIRST_DATE);\n      let dayDiff = hDay - 1;\n      if (hYear >= HIJRI_BEGIN && hYear <= HIJRI_END) {\n        for (let y = 0; y < hYear - HIJRI_BEGIN; y++) {\n          for (let m = 0; m < 12; m++) {\n            dayDiff += +MONTH_LENGTH[y][m] + 29;\n          }\n        }\n        for (let m = 0; m < hMonth; m++) {\n          dayDiff += +MONTH_LENGTH[hYear - HIJRI_BEGIN][m] + 29;\n        }\n        gDate.setDate(GREGORIAN_FIRST_DATE.getDate() + dayDiff);\n      } else {\n        gDate = super.toGregorian(hDate);\n      }\n      return gDate;\n    }\n    /**\n     * Returns the number of days in a specific Hijri hMonth.\n     * `hMonth` is 1 for Muharram, 2 for Safar, etc.\n     * `hYear` is any Hijri hYear.\n     */\n    getDaysPerMonth(hMonth, hYear) {\n      if (hYear >= HIJRI_BEGIN && hYear <= HIJRI_END) {\n        const pos = hYear - HIJRI_BEGIN;\n        return +MONTH_LENGTH[pos][hMonth - 1] + 29;\n      }\n      return super.getDaysPerMonth(hMonth, hYear);\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarIslamicUmalqura_BaseFactory;\n      return function NgbCalendarIslamicUmalqura_Factory(t) {\n        return (ɵNgbCalendarIslamicUmalqura_BaseFactory || (ɵNgbCalendarIslamicUmalqura_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarIslamicUmalqura)))(t || NgbCalendarIslamicUmalqura);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarIslamicUmalqura,\n      factory: NgbCalendarIslamicUmalqura.ɵfac\n    });\n  }\n  return NgbCalendarIslamicUmalqura;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Returns the equivalent JS date value for a give input Jalali date.\n * `jalaliDate` is an Jalali date to be converted to Gregorian.\n */\nfunction toGregorian$3(jalaliDate) {\n  let jdn = jalaliToJulian(jalaliDate.year, jalaliDate.month, jalaliDate.day);\n  let date = julianToGregorian$1(jdn);\n  date.setHours(6, 30, 3, 200);\n  return date;\n}\n/**\n * Returns the equivalent jalali date value for a give input Gregorian date.\n * `gdate` is a JS Date to be converted to jalali.\n * utc to local\n */\nfunction fromGregorian$3(gdate) {\n  let g2d = gregorianToJulian$1(gdate.getFullYear(), gdate.getMonth() + 1, gdate.getDate());\n  return julianToJalali(g2d);\n}\nfunction setJalaliYear(date, yearValue) {\n  date.year = +yearValue;\n  return date;\n}\nfunction setJalaliMonth(date, month) {\n  month = +month;\n  date.year = date.year + Math.floor((month - 1) / 12);\n  date.month = Math.floor(((month - 1) % 12 + 12) % 12) + 1;\n  return date;\n}\nfunction setJalaliDay(date, day) {\n  let mDays = getDaysPerMonth$1(date.month, date.year);\n  if (day <= 0) {\n    while (day <= 0) {\n      date = setJalaliMonth(date, date.month - 1);\n      mDays = getDaysPerMonth$1(date.month, date.year);\n      day += mDays;\n    }\n  } else if (day > mDays) {\n    while (day > mDays) {\n      day -= mDays;\n      date = setJalaliMonth(date, date.month + 1);\n      mDays = getDaysPerMonth$1(date.month, date.year);\n    }\n  }\n  date.day = day;\n  return date;\n}\nfunction mod(a, b) {\n  return a - b * Math.floor(a / b);\n}\nfunction div(a, b) {\n  return Math.trunc(a / b);\n}\n/*\n This function determines if the Jalali (Persian) year is\n leap (366-day long) or is the common year (365 days), and\n finds the day in March (Gregorian calendar) of the first\n day of the Jalali year (jalaliYear).\n @param jalaliYear Jalali calendar year (-61 to 3177)\n @return\n leap: number of years since the last leap year (0 to 4)\n gYear: Gregorian year of the beginning of Jalali year\n march: the March day of Farvardin the 1st (1st day of jalaliYear)\n @see: http://www.astro.uni.torun.pl/~kb/Papers/EMP/PersianC-EMP.htm\n @see: http://www.fourmilab.ch/documents/calendar/\n */\nfunction jalCal(jalaliYear) {\n  // Jalali years starting the 33-year rule.\n  let breaks = [-61, 9, 38, 199, 426, 686, 756, 818, 1111, 1181, 1210, 1635, 2060, 2097, 2192, 2262, 2324, 2394, 2456, 3178];\n  const breaksLength = breaks.length;\n  const gYear = jalaliYear + 621;\n  let leapJ = -14;\n  let jp = breaks[0];\n  if (jalaliYear < jp || jalaliYear >= breaks[breaksLength - 1]) {\n    throw new Error('Invalid Jalali year ' + jalaliYear);\n  }\n  // Find the limiting years for the Jalali year jalaliYear.\n  let jump;\n  for (let i = 1; i < breaksLength; i += 1) {\n    const jm = breaks[i];\n    jump = jm - jp;\n    if (jalaliYear < jm) {\n      break;\n    }\n    leapJ = leapJ + div(jump, 33) * 8 + div(mod(jump, 33), 4);\n    jp = jm;\n  }\n  let n = jalaliYear - jp;\n  // Find the number of leap years from AD 621 to the beginning\n  // of the current Jalali year in the Persian calendar.\n  leapJ = leapJ + div(n, 33) * 8 + div(mod(n, 33) + 3, 4);\n  if (mod(jump, 33) === 4 && jump - n === 4) {\n    leapJ += 1;\n  }\n  // And the same in the Gregorian calendar (until the year gYear).\n  const leapG = div(gYear, 4) - div((div(gYear, 100) + 1) * 3, 4) - 150;\n  // Determine the Gregorian date of Farvardin the 1st.\n  const march = 20 + leapJ - leapG;\n  // Find how many years have passed since the last leap year.\n  if (jump - n < 6) {\n    n = n - jump + div(jump + 4, 33) * 33;\n  }\n  let leap = mod(mod(n + 1, 33) - 1, 4);\n  if (leap === -1) {\n    leap = 4;\n  }\n  return {\n    leap: leap,\n    gy: gYear,\n    march: march\n  };\n}\n/*\n Calculates Gregorian and Julian calendar dates from the Julian Day number\n (jdn) for the period since jdn=-34839655 (i.e. the year -100100 of both\n calendars) to some millions years ahead of the present.\n @param jdn Julian Day number\n @return\n gYear: Calendar year (years BC numbered 0, -1, -2, ...)\n gMonth: Calendar month (1 to 12)\n gDay: Calendar day of the month M (1 to 28/29/30/31)\n */\nfunction julianToGregorian$1(julianDayNumber) {\n  let j = 4 * julianDayNumber + 139361631;\n  j = j + div(div(4 * julianDayNumber + 183187720, 146097) * 3, 4) * 4 - 3908;\n  const i = div(mod(j, 1461), 4) * 5 + 308;\n  const gDay = div(mod(i, 153), 5) + 1;\n  const gMonth = mod(div(i, 153), 12) + 1;\n  const gYear = div(j, 1461) - 100100 + div(8 - gMonth, 6);\n  return new Date(gYear, gMonth - 1, gDay);\n}\n/*\n Converts a date of the Jalali calendar to the Julian Day number.\n @param jy Jalali year (1 to 3100)\n @param jm Jalali month (1 to 12)\n @param jd Jalali day (1 to 29/31)\n @return Julian Day number\n */\nfunction gregorianToJulian$1(gy, gm, gd) {\n  let d = div((gy + div(gm - 8, 6) + 100100) * 1461, 4) + div(153 * mod(gm + 9, 12) + 2, 5) + gd - 34840408;\n  d = d - div(div(gy + 100100 + div(gm - 8, 6), 100) * 3, 4) + 752;\n  return d;\n}\n/*\n Converts the Julian Day number to a date in the Jalali calendar.\n @param julianDayNumber Julian Day number\n @return\n jalaliYear: Jalali year (1 to 3100)\n jalaliMonth: Jalali month (1 to 12)\n jalaliDay: Jalali day (1 to 29/31)\n */\nfunction julianToJalali(julianDayNumber) {\n  let gy = julianToGregorian$1(julianDayNumber).getFullYear(),\n    // Calculate Gregorian year (gy).\n    jalaliYear = gy - 621,\n    r = jalCal(jalaliYear),\n    gregorianDay = gregorianToJulian$1(gy, 3, r.march),\n    jalaliDay,\n    jalaliMonth,\n    numberOfDays;\n  // Find number of days that passed since 1 Farvardin.\n  numberOfDays = julianDayNumber - gregorianDay;\n  if (numberOfDays >= 0) {\n    if (numberOfDays <= 185) {\n      // The first 6 months.\n      jalaliMonth = 1 + div(numberOfDays, 31);\n      jalaliDay = mod(numberOfDays, 31) + 1;\n      return new NgbDate(jalaliYear, jalaliMonth, jalaliDay);\n    } else {\n      // The remaining months.\n      numberOfDays -= 186;\n    }\n  } else {\n    // Previous Jalali year.\n    jalaliYear -= 1;\n    numberOfDays += 179;\n    if (r.leap === 1) {\n      numberOfDays += 1;\n    }\n  }\n  jalaliMonth = 7 + div(numberOfDays, 30);\n  jalaliDay = mod(numberOfDays, 30) + 1;\n  return new NgbDate(jalaliYear, jalaliMonth, jalaliDay);\n}\n/*\n Converts a date of the Jalali calendar to the Julian Day number.\n @param jYear Jalali year (1 to 3100)\n @param jMonth Jalali month (1 to 12)\n @param jDay Jalali day (1 to 29/31)\n @return Julian Day number\n */\nfunction jalaliToJulian(jYear, jMonth, jDay) {\n  let r = jalCal(jYear);\n  return gregorianToJulian$1(r.gy, 3, r.march) + (jMonth - 1) * 31 - div(jMonth, 7) * (jMonth - 7) + jDay - 1;\n}\n/**\n * Returns the number of days in a specific jalali month.\n */\nfunction getDaysPerMonth$1(month, year) {\n  if (month <= 6) {\n    return 31;\n  }\n  if (month <= 11) {\n    return 30;\n  }\n  if (jalCal(year).leap === 0) {\n    return 30;\n  }\n  return 29;\n}\nlet NgbCalendarPersian = /*#__PURE__*/(() => {\n  class NgbCalendarPersian extends NgbCalendar {\n    getDaysPerWeek() {\n      return 7;\n    }\n    getMonths() {\n      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n    }\n    getWeeksPerMonth() {\n      return 6;\n    }\n    getNext(date, period = 'd', number = 1) {\n      date = new NgbDate(date.year, date.month, date.day);\n      switch (period) {\n        case 'y':\n          date = setJalaliYear(date, date.year + number);\n          date.month = 1;\n          date.day = 1;\n          return date;\n        case 'm':\n          date = setJalaliMonth(date, date.month + number);\n          date.day = 1;\n          return date;\n        case 'd':\n          return setJalaliDay(date, date.day + number);\n        default:\n          return date;\n      }\n    }\n    getPrev(date, period = 'd', number = 1) {\n      return this.getNext(date, period, -number);\n    }\n    getWeekday(date) {\n      const day = toGregorian$3(date).getDay();\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      return day === 0 ? 7 : day;\n    }\n    getWeekNumber(week, firstDayOfWeek) {\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      if (firstDayOfWeek === 7) {\n        firstDayOfWeek = 0;\n      }\n      const thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;\n      const date = week[thursdayIndex];\n      const jsDate = toGregorian$3(date);\n      jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday\n      const time = jsDate.getTime();\n      const startDate = toGregorian$3(new NgbDate(date.year, 1, 1));\n      return Math.floor(Math.round((time - startDate.getTime()) / 86400000) / 7) + 1;\n    }\n    getToday() {\n      return fromGregorian$3(new Date());\n    }\n    isValid(date) {\n      return date != null && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) && !isNaN(toGregorian$3(date).getTime());\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarPersian_BaseFactory;\n      return function NgbCalendarPersian_Factory(t) {\n        return (ɵNgbCalendarPersian_BaseFactory || (ɵNgbCalendarPersian_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarPersian)))(t || NgbCalendarPersian);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarPersian,\n      factory: NgbCalendarPersian.ɵfac\n    });\n  }\n  return NgbCalendarPersian;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PARTS_PER_HOUR = 1080;\nconst PARTS_PER_DAY = 24 * PARTS_PER_HOUR;\nconst PARTS_FRACTIONAL_MONTH = 12 * PARTS_PER_HOUR + 793;\nconst PARTS_PER_MONTH = 29 * PARTS_PER_DAY + PARTS_FRACTIONAL_MONTH;\nconst BAHARAD = 11 * PARTS_PER_HOUR + 204;\nconst HEBREW_DAY_ON_JAN_1_1970 = 2092591;\nconst GREGORIAN_EPOCH = 1721425.5;\nfunction isGregorianLeapYear(year) {\n  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n}\nfunction numberOfFirstDayInYear(year) {\n  let monthsBeforeYear = Math.floor((235 * year - 234) / 19);\n  let fractionalMonthsBeforeYear = monthsBeforeYear * PARTS_FRACTIONAL_MONTH + BAHARAD;\n  let dayNumber = monthsBeforeYear * 29 + Math.floor(fractionalMonthsBeforeYear / PARTS_PER_DAY);\n  let timeOfDay = fractionalMonthsBeforeYear % PARTS_PER_DAY;\n  let dayOfWeek = dayNumber % 7; // 0 == Monday\n  if (dayOfWeek === 2 || dayOfWeek === 4 || dayOfWeek === 6) {\n    dayNumber++;\n    dayOfWeek = dayNumber % 7;\n  }\n  if (dayOfWeek === 1 && timeOfDay > 15 * PARTS_PER_HOUR + 204 && !isHebrewLeapYear(year)) {\n    dayNumber += 2;\n  } else if (dayOfWeek === 0 && timeOfDay > 21 * PARTS_PER_HOUR + 589 && isHebrewLeapYear(year - 1)) {\n    dayNumber++;\n  }\n  return dayNumber;\n}\nfunction getDaysInGregorianMonth(month, year) {\n  let days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  if (isGregorianLeapYear(year)) {\n    days[1]++;\n  }\n  return days[month - 1];\n}\nfunction getHebrewMonths(year) {\n  return isHebrewLeapYear(year) ? 13 : 12;\n}\n/**\n * Returns the number of days in a specific Hebrew year.\n * `year` is any Hebrew year.\n */\nfunction getDaysInHebrewYear(year) {\n  return numberOfFirstDayInYear(year + 1) - numberOfFirstDayInYear(year);\n}\nfunction isHebrewLeapYear(year) {\n  if (year != null) {\n    let b = (year * 12 + 17) % 19;\n    return b >= (b < 0 ? -7 : 12);\n  }\n  return false;\n}\n/**\n * Returns the number of days in a specific Hebrew month.\n * `month` is 1 for Nisan, 2 for Iyar etc. Note: Hebrew leap year contains 13 months.\n * `year` is any Hebrew year.\n */\nfunction getDaysInHebrewMonth(month, year) {\n  let yearLength = numberOfFirstDayInYear(year + 1) - numberOfFirstDayInYear(year);\n  let yearType = (yearLength <= 380 ? yearLength : yearLength - 30) - 353;\n  let leapYear = isHebrewLeapYear(year);\n  let daysInMonth = leapYear ? [30, 29, 29, 29, 30, 30, 29, 30, 29, 30, 29, 30, 29] : [30, 29, 29, 29, 30, 29, 30, 29, 30, 29, 30, 29];\n  if (yearType > 0) {\n    daysInMonth[2]++; // Kislev gets an extra day in normal or complete years.\n  }\n  if (yearType > 1) {\n    daysInMonth[1]++; // Heshvan gets an extra day in complete years only.\n  }\n  return daysInMonth[month - 1];\n}\nfunction getDayNumberInHebrewYear(date) {\n  let numberOfDay = 0;\n  for (let i = 1; i < date.month; i++) {\n    numberOfDay += getDaysInHebrewMonth(i, date.year);\n  }\n  return numberOfDay + date.day;\n}\nfunction setHebrewMonth(date, val) {\n  let after = val >= 0;\n  if (!after) {\n    val = -val;\n  }\n  while (val > 0) {\n    if (after) {\n      if (val > getHebrewMonths(date.year) - date.month) {\n        val -= getHebrewMonths(date.year) - date.month + 1;\n        date.year++;\n        date.month = 1;\n      } else {\n        date.month += val;\n        val = 0;\n      }\n    } else {\n      if (val >= date.month) {\n        date.year--;\n        val -= date.month;\n        date.month = getHebrewMonths(date.year);\n      } else {\n        date.month -= val;\n        val = 0;\n      }\n    }\n  }\n  return date;\n}\nfunction setHebrewDay(date, val) {\n  let after = val >= 0;\n  if (!after) {\n    val = -val;\n  }\n  while (val > 0) {\n    if (after) {\n      if (val > getDaysInHebrewYear(date.year) - getDayNumberInHebrewYear(date)) {\n        val -= getDaysInHebrewYear(date.year) - getDayNumberInHebrewYear(date) + 1;\n        date.year++;\n        date.month = 1;\n        date.day = 1;\n      } else if (val > getDaysInHebrewMonth(date.month, date.year) - date.day) {\n        val -= getDaysInHebrewMonth(date.month, date.year) - date.day + 1;\n        date.month++;\n        date.day = 1;\n      } else {\n        date.day += val;\n        val = 0;\n      }\n    } else {\n      if (val >= date.day) {\n        val -= date.day;\n        date.month--;\n        if (date.month === 0) {\n          date.year--;\n          date.month = getHebrewMonths(date.year);\n        }\n        date.day = getDaysInHebrewMonth(date.month, date.year);\n      } else {\n        date.day -= val;\n        val = 0;\n      }\n    }\n  }\n  return date;\n}\n/**\n * Returns the equivalent Hebrew date value for a give input Gregorian date.\n * `gdate` is a JS Date to be converted to Hebrew date.\n */\nfunction fromGregorian$2(gdate) {\n  const date = new Date(gdate);\n  const gYear = date.getFullYear(),\n    gMonth = date.getMonth(),\n    gDay = date.getDate();\n  let julianDay = GREGORIAN_EPOCH - 1 + 365 * (gYear - 1) + Math.floor((gYear - 1) / 4) - Math.floor((gYear - 1) / 100) + Math.floor((gYear - 1) / 400) + Math.floor((367 * (gMonth + 1) - 362) / 12 + (gMonth + 1 <= 2 ? 0 : isGregorianLeapYear(gYear) ? -1 : -2) + gDay);\n  julianDay = Math.floor(julianDay + 0.5);\n  let daysSinceHebEpoch = julianDay - 347997;\n  let monthsSinceHebEpoch = Math.floor(daysSinceHebEpoch * PARTS_PER_DAY / PARTS_PER_MONTH);\n  let hYear = Math.floor((monthsSinceHebEpoch * 19 + 234) / 235) + 1;\n  let firstDayOfThisYear = numberOfFirstDayInYear(hYear);\n  let dayOfYear = daysSinceHebEpoch - firstDayOfThisYear;\n  while (dayOfYear < 1) {\n    hYear--;\n    firstDayOfThisYear = numberOfFirstDayInYear(hYear);\n    dayOfYear = daysSinceHebEpoch - firstDayOfThisYear;\n  }\n  let hMonth = 1;\n  let hDay = dayOfYear;\n  while (hDay > getDaysInHebrewMonth(hMonth, hYear)) {\n    hDay -= getDaysInHebrewMonth(hMonth, hYear);\n    hMonth++;\n  }\n  return new NgbDate(hYear, hMonth, hDay);\n}\n/**\n * Returns the equivalent JS date value for a given Hebrew date.\n * `hebrewDate` is an Hebrew date to be converted to Gregorian.\n */\nfunction toGregorian$2(hebrewDate) {\n  const hYear = hebrewDate.year;\n  const hMonth = hebrewDate.month;\n  const hDay = hebrewDate.day;\n  let days = numberOfFirstDayInYear(hYear);\n  for (let i = 1; i < hMonth; i++) {\n    days += getDaysInHebrewMonth(i, hYear);\n  }\n  days += hDay;\n  let diffDays = days - HEBREW_DAY_ON_JAN_1_1970;\n  let after = diffDays >= 0;\n  if (!after) {\n    diffDays = -diffDays;\n  }\n  let gYear = 1970;\n  let gMonth = 1;\n  let gDay = 1;\n  while (diffDays > 0) {\n    if (after) {\n      if (diffDays >= (isGregorianLeapYear(gYear) ? 366 : 365)) {\n        diffDays -= isGregorianLeapYear(gYear) ? 366 : 365;\n        gYear++;\n      } else if (diffDays >= getDaysInGregorianMonth(gMonth, gYear)) {\n        diffDays -= getDaysInGregorianMonth(gMonth, gYear);\n        gMonth++;\n      } else {\n        gDay += diffDays;\n        diffDays = 0;\n      }\n    } else {\n      if (diffDays >= (isGregorianLeapYear(gYear - 1) ? 366 : 365)) {\n        diffDays -= isGregorianLeapYear(gYear - 1) ? 366 : 365;\n        gYear--;\n      } else {\n        if (gMonth > 1) {\n          gMonth--;\n        } else {\n          gMonth = 12;\n          gYear--;\n        }\n        if (diffDays >= getDaysInGregorianMonth(gMonth, gYear)) {\n          diffDays -= getDaysInGregorianMonth(gMonth, gYear);\n        } else {\n          gDay = getDaysInGregorianMonth(gMonth, gYear) - diffDays + 1;\n          diffDays = 0;\n        }\n      }\n    }\n  }\n  return new Date(gYear, gMonth - 1, gDay);\n}\nfunction hebrewNumerals(numerals) {\n  if (!numerals) {\n    return '';\n  }\n  const hArray0_9 = ['', '\\u05d0', '\\u05d1', '\\u05d2', '\\u05d3', '\\u05d4', '\\u05d5', '\\u05d6', '\\u05d7', '\\u05d8'];\n  const hArray10_19 = ['\\u05d9', '\\u05d9\\u05d0', '\\u05d9\\u05d1', '\\u05d9\\u05d2', '\\u05d9\\u05d3', '\\u05d8\\u05d5', '\\u05d8\\u05d6', '\\u05d9\\u05d6', '\\u05d9\\u05d7', '\\u05d9\\u05d8'];\n  const hArray20_90 = ['', '', '\\u05db', '\\u05dc', '\\u05de', '\\u05e0', '\\u05e1', '\\u05e2', '\\u05e4', '\\u05e6'];\n  const hArray100_900 = ['', '\\u05e7', '\\u05e8', '\\u05e9', '\\u05ea', '\\u05ea\\u05e7', '\\u05ea\\u05e8', '\\u05ea\\u05e9', '\\u05ea\\u05ea', '\\u05ea\\u05ea\\u05e7'];\n  const hArray1000_9000 = ['', '\\u05d0', '\\u05d1', '\\u05d1\\u05d0', '\\u05d1\\u05d1', '\\u05d4', '\\u05d4\\u05d0', '\\u05d4\\u05d1', '\\u05d4\\u05d1\\u05d0', '\\u05d4\\u05d1\\u05d1'];\n  const geresh = '\\u05f3',\n    gershaim = '\\u05f4';\n  let mem = 0;\n  let result = [];\n  let step = 0;\n  while (numerals > 0) {\n    let m = numerals % 10;\n    if (step === 0) {\n      mem = m;\n    } else if (step === 1) {\n      if (m !== 1) {\n        result.unshift(hArray20_90[m], hArray0_9[mem]);\n      } else {\n        result.unshift(hArray10_19[mem]);\n      }\n    } else if (step === 2) {\n      result.unshift(hArray100_900[m]);\n    } else {\n      if (m !== 5) {\n        result.unshift(hArray1000_9000[m], geresh, ' ');\n      }\n      break;\n    }\n    numerals = Math.floor(numerals / 10);\n    if (step === 0 && numerals === 0) {\n      result.unshift(hArray0_9[m]);\n    }\n    step++;\n  }\n  result = result.join('').split('');\n  if (result.length === 1) {\n    result.push(geresh);\n  } else if (result.length > 1) {\n    result.splice(result.length - 1, 0, gershaim);\n  }\n  return result.join('');\n}\n\n/**\n * @since 3.2.0\n */\nlet NgbCalendarHebrew = /*#__PURE__*/(() => {\n  class NgbCalendarHebrew extends NgbCalendar {\n    getDaysPerWeek() {\n      return 7;\n    }\n    getMonths(year) {\n      if (year && isHebrewLeapYear(year)) {\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\n      } else {\n        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];\n      }\n    }\n    getWeeksPerMonth() {\n      return 6;\n    }\n    isValid(date) {\n      if (date != null) {\n        let b = isNumber(date.year) && isNumber(date.month) && isNumber(date.day);\n        b = b && date.month > 0 && date.month <= (isHebrewLeapYear(date.year) ? 13 : 12);\n        b = b && date.day > 0 && date.day <= getDaysInHebrewMonth(date.month, date.year);\n        return b && !isNaN(toGregorian$2(date).getTime());\n      }\n      return false;\n    }\n    getNext(date, period = 'd', number = 1) {\n      date = new NgbDate(date.year, date.month, date.day);\n      switch (period) {\n        case 'y':\n          date.year += number;\n          date.month = 1;\n          date.day = 1;\n          return date;\n        case 'm':\n          date = setHebrewMonth(date, number);\n          date.day = 1;\n          return date;\n        case 'd':\n          return setHebrewDay(date, number);\n        default:\n          return date;\n      }\n    }\n    getPrev(date, period = 'd', number = 1) {\n      return this.getNext(date, period, -number);\n    }\n    getWeekday(date) {\n      const day = toGregorian$2(date).getDay();\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      return day === 0 ? 7 : day;\n    }\n    getWeekNumber(week, firstDayOfWeek) {\n      const date = week[week.length - 1];\n      return Math.ceil(getDayNumberInHebrewYear(date) / 7);\n    }\n    getToday() {\n      return fromGregorian$2(new Date());\n    }\n    /**\n     * @since 3.4.0\n     */\n    toGregorian(date) {\n      return fromJSDate(toGregorian$2(date));\n    }\n    /**\n     * @since 3.4.0\n     */\n    fromGregorian(date) {\n      return fromGregorian$2(toJSDate(date));\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarHebrew_BaseFactory;\n      return function NgbCalendarHebrew_Factory(t) {\n        return (ɵNgbCalendarHebrew_BaseFactory || (ɵNgbCalendarHebrew_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarHebrew)))(t || NgbCalendarHebrew);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarHebrew,\n      factory: NgbCalendarHebrew.ɵfac\n    });\n  }\n  return NgbCalendarHebrew;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst WEEKDAYS$1 = ['שני', 'שלישי', 'רביעי', 'חמישי', 'שישי', 'שבת', 'ראשון'];\nconst MONTHS$1 = ['תשרי', 'חשון', 'כסלו', 'טבת', 'שבט', 'אדר', 'ניסן', 'אייר', 'סיון', 'תמוז', 'אב', 'אלול'];\nconst MONTHS_LEAP = ['תשרי', 'חשון', 'כסלו', 'טבת', 'שבט', 'אדר א׳', 'אדר ב׳', 'ניסן', 'אייר', 'סיון', 'תמוז', 'אב', 'אלול'];\n/**\n * @since 3.2.0\n */\nlet NgbDatepickerI18nHebrew = /*#__PURE__*/(() => {\n  class NgbDatepickerI18nHebrew extends NgbDatepickerI18n {\n    getMonthShortName(month, year) {\n      return this.getMonthFullName(month, year);\n    }\n    getMonthFullName(month, year) {\n      return isHebrewLeapYear(year) ? MONTHS_LEAP[month - 1] || '' : MONTHS$1[month - 1] || '';\n    }\n    getWeekdayLabel(weekday, width) {\n      return WEEKDAYS$1[weekday - 1] || '';\n    }\n    getDayAriaLabel(date) {\n      return `${hebrewNumerals(date.day)} ${this.getMonthFullName(date.month, date.year)} ${hebrewNumerals(date.year)}`;\n    }\n    getDayNumerals(date) {\n      return hebrewNumerals(date.day);\n    }\n    getWeekNumerals(weekNumber) {\n      return hebrewNumerals(weekNumber);\n    }\n    getYearNumerals(year) {\n      return hebrewNumerals(year);\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDatepickerI18nHebrew_BaseFactory;\n      return function NgbDatepickerI18nHebrew_Factory(t) {\n        return (ɵNgbDatepickerI18nHebrew_BaseFactory || (ɵNgbDatepickerI18nHebrew_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDatepickerI18nHebrew)))(t || NgbDatepickerI18nHebrew);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDatepickerI18nHebrew,\n      factory: NgbDatepickerI18nHebrew.ɵfac\n    });\n  }\n  return NgbDatepickerI18nHebrew;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Returns the equivalent JS date value for a give input Buddhist date.\n * `date` is an Buddhist date to be converted to Gregorian.\n */\nfunction toGregorian$1(date) {\n  return new Date(date.year - 543, date.month - 1, date.day);\n}\n/**\n * Returns the equivalent Buddhist date value for a give input Gregorian date.\n * `gdate` is a JS Date to be converted to Buddhist.\n * utc to local\n */\nfunction fromGregorian$1(gdate) {\n  return new NgbDate(gdate.getFullYear() + 543, gdate.getMonth() + 1, gdate.getDate());\n}\n\n/**\n * @since 9.1.0\n */\nlet NgbCalendarBuddhist = /*#__PURE__*/(() => {\n  class NgbCalendarBuddhist extends NgbCalendarGregorian {\n    getToday() {\n      return fromGregorian$1(new Date());\n    }\n    getNext(date, period = 'd', number = 1) {\n      let jsDate = toGregorian$1(date);\n      let checkMonth = true;\n      let expectedMonth = jsDate.getMonth();\n      switch (period) {\n        case 'y':\n          jsDate.setFullYear(jsDate.getFullYear() + number);\n          break;\n        case 'm':\n          expectedMonth += number;\n          jsDate.setMonth(expectedMonth);\n          expectedMonth = expectedMonth % 12;\n          if (expectedMonth < 0) {\n            expectedMonth = expectedMonth + 12;\n          }\n          break;\n        case 'd':\n          jsDate.setDate(jsDate.getDate() + number);\n          checkMonth = false;\n          break;\n        default:\n          return date;\n      }\n      if (checkMonth && jsDate.getMonth() !== expectedMonth) {\n        // this means the destination month has less days than the initial month\n        // let's go back to the end of the previous month:\n        jsDate.setDate(0);\n      }\n      return fromGregorian$1(jsDate);\n    }\n    getPrev(date, period = 'd', number = 1) {\n      return this.getNext(date, period, -number);\n    }\n    getWeekday(date) {\n      let jsDate = toGregorian$1(date);\n      let day = jsDate.getDay();\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      return day === 0 ? 7 : day;\n    }\n    getWeekNumber(week, firstDayOfWeek) {\n      // in JS Date Sun=0, in ISO 8601 Sun=7\n      if (firstDayOfWeek === 7) {\n        firstDayOfWeek = 0;\n      }\n      const thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;\n      let date = week[thursdayIndex];\n      const jsDate = toGregorian$1(date);\n      jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday\n      const time = jsDate.getTime();\n      jsDate.setMonth(0); // Compare with Jan 1\n      jsDate.setDate(1);\n      return Math.floor(Math.round((time - jsDate.getTime()) / 86400000) / 7) + 1;\n    }\n    isValid(date) {\n      if (!date || !isInteger(date.year) || !isInteger(date.month) || !isInteger(date.day)) {\n        return false;\n      }\n      // year 0 doesn't exist in Gregorian calendar\n      if (date.year === 0) {\n        return false;\n      }\n      const jsDate = toGregorian$1(date);\n      return !isNaN(jsDate.getTime()) && jsDate.getFullYear() === date.year - 543 && jsDate.getMonth() + 1 === date.month && jsDate.getDate() === date.day;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarBuddhist_BaseFactory;\n      return function NgbCalendarBuddhist_Factory(t) {\n        return (ɵNgbCalendarBuddhist_BaseFactory || (ɵNgbCalendarBuddhist_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarBuddhist)))(t || NgbCalendarBuddhist);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarBuddhist,\n      factory: NgbCalendarBuddhist.ɵfac\n    });\n  }\n  return NgbCalendarBuddhist;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst JD_EPOCH = 1724220.5;\nconst DAYSPERMONTH = [30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 5];\n/**\n * Determine whether this date is in a leap year.\n * * `year` is the year to examine\n * returns boolean - true if this is a leap year, false if not\n * */\nfunction isEthiopianLeapYear(year) {\n  if (year != null) {\n    return year % 4 == 3 || year % 4 == -1;\n  }\n  return false;\n}\n/**\n * Sets the Ethiopian year.\n * * `date` is Ethiopian date\n * * `yearValue` incremented year\n * returns NgbDate - ethiopian date\n * */\nfunction setEthiopianYear(date, yearValue) {\n  date.year = +yearValue;\n  return date;\n}\n/**\n * Sets the Ethiopian month.\n * * `date` is Ethiopian date\n * * `val` incremented month\n * returns NgbDate - Ethiopian date\n * */\nfunction setEthiopianMonth(date, val) {\n  val = +val;\n  date.year = date.year + Math.floor((val - 1) / 13);\n  date.month = Math.floor(((val - 1) % 13 + 13) % 13) + 1;\n  return date;\n}\n/**\n * Sets the Ethiopian day.\n * * `date` is Ethiopian date\n * * `day` incremented day\n * returns NgbDate - Ethiopian date\n * */\nfunction setEthiopianDay(date, day) {\n  let mDays = getDaysPerMonth(date.month, date.year);\n  if (day <= 0) {\n    while (day <= 0) {\n      date = setEthiopianMonth(date, date.month - 1);\n      mDays = getDaysPerMonth(date.month, date.year);\n      day += mDays;\n    }\n  } else if (day > mDays) {\n    while (day > mDays) {\n      day -= mDays;\n      date = setEthiopianMonth(date, date.month + 1);\n      mDays = getDaysPerMonth(date.month, date.year);\n    }\n  }\n  date.day = day;\n  return date;\n}\nfunction getDaysPerMonth(month, year) {\n  let leapYear = isEthiopianLeapYear(year);\n  return DAYSPERMONTH[month - 1] + (month === 13 && leapYear ? 1 : 0);\n}\nfunction toGregorian(ethiopianDate) {\n  let jdn = ethiopianToJulian(ethiopianDate.year, ethiopianDate.month, ethiopianDate.day);\n  let date = julianToGregorian(jdn);\n  date.setHours(6, 30, 3, 200);\n  return date;\n}\nfunction fromGregorian(gdate) {\n  let g2d = gregorianToJulian(gdate.getFullYear(), gdate.getMonth() + 1, gdate.getDate());\n  return juilianToEthiopia(g2d);\n}\nfunction ethiopianToJulian(year, month, day) {\n  if (year < 0) {\n    year++;\n  } // No year zero\n  return day + (month - 1) * 30 + (year - 1) * 365 + Math.floor(year / 4) + JD_EPOCH - 1;\n}\nfunction juilianToEthiopia(jd) {\n  let c = Math.floor(jd) + 0.5 - JD_EPOCH;\n  let year = Math.floor((c - Math.floor((c + 366) / 1461)) / 365) + 1;\n  if (year <= 0) {\n    year--;\n  } // No year zero\n  c = Math.floor(jd) + 0.5 - ethiopianToJulian(year, 1, 1);\n  let month = Math.floor(c / 30) + 1;\n  let day = c - (month - 1) * 30 + 1;\n  return new NgbDate(year, month, day);\n}\nfunction julianToGregorian(jd) {\n  let z = Math.floor(jd + 0.5);\n  let a = Math.floor((z - 1867216.25) / 36524.25);\n  a = z + 1 + a - Math.floor(a / 4);\n  let b = a + 1524;\n  let c = Math.floor((b - 122.1) / 365.25);\n  let d = Math.floor(365.25 * c);\n  let e = Math.floor((b - d) / 30.6001);\n  let day = b - d - Math.floor(e * 30.6001);\n  let month = e - (e > 13.5 ? 13 : 1);\n  let year = c - (month > 2.5 ? 4716 : 4715);\n  if (year <= 0) {\n    year--;\n  } // No year zero\n  return new Date(year, month, day);\n}\nfunction gregorianToJulian(year, month, day) {\n  if (year < 0) {\n    year++;\n  } // No year zero\n  // Jean Meeus algorithm, \"Astronomical Algorithms\", 1991\n  if (month < 3) {\n    month += 12;\n    year--;\n  }\n  let a = Math.floor(year / 100);\n  let b = 2 - a + Math.floor(a / 4);\n  return Math.floor(365.25 * (year + 4716)) + Math.floor(30.6001 * (month + 1)) + day + b - 1524.5;\n}\n\n/**\n * @since 16.0.0\n */\nlet NgbCalendarEthiopian = /*#__PURE__*/(() => {\n  class NgbCalendarEthiopian extends NgbCalendar {\n    getDaysPerWeek() {\n      return 7;\n    }\n    getMonths(year) {\n      return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];\n    }\n    getNext(date, period = 'd', number = 1) {\n      date = new NgbDate(date.year, date.month, date.day);\n      switch (period) {\n        case 'y':\n          date = setEthiopianYear(date, date.year + number);\n          date.month = 1;\n          date.day = 1;\n          return date;\n        case 'm':\n          date = setEthiopianMonth(date, date.month + number);\n          date.day = 1;\n          return date;\n        case 'd':\n          return setEthiopianDay(date, date.day + number);\n        default:\n          return date;\n      }\n    }\n    getPrev(date, period = 'd', number = 1) {\n      return this.getNext(date, period, -number);\n    }\n    getWeekday(date) {\n      const dt = Math.floor(ethiopianToJulian(date.year, date.month, date.day) + 3) % 7;\n      return dt === 0 ? 7 : dt;\n    }\n    getWeekNumber(week, firstDayOfWeek) {\n      if (firstDayOfWeek === 7) {\n        firstDayOfWeek = 0;\n      }\n      const thursdayIndex = (4 + 7 - firstDayOfWeek) % 7;\n      const date = week[thursdayIndex];\n      const jsDate = toGregorian(date);\n      jsDate.setDate(jsDate.getDate() + 4 - (jsDate.getDay() || 7)); // Thursday\n      const time = jsDate.getTime();\n      const startDate = toGregorian(new NgbDate(date.year, 1, 1));\n      return Math.floor(Math.round((time - startDate.getTime()) / 86400000) / 7) + 1;\n    }\n    getWeeksPerMonth() {\n      return 6;\n    }\n    getToday() {\n      return fromGregorian(new Date());\n    }\n    isValid(date) {\n      return date && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) && !isNaN(toGregorian(date).getTime());\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbCalendarEthiopian_BaseFactory;\n      return function NgbCalendarEthiopian_Factory(t) {\n        return (ɵNgbCalendarEthiopian_BaseFactory || (ɵNgbCalendarEthiopian_BaseFactory = i0.ɵɵgetInheritedFactory(NgbCalendarEthiopian)))(t || NgbCalendarEthiopian);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbCalendarEthiopian,\n      factory: NgbCalendarEthiopian.ɵfac\n    });\n  }\n  return NgbCalendarEthiopian;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst WEEKDAYS = ['እሑድ', 'ሰኞ', 'ማክሰኞ', 'ረቡዕ', 'ሓሙስ', 'ዓርብ', 'ቅዳሜ'];\nconst MONTHS = ['መስከረም', 'ጥቅምት', 'ኅዳር', 'ታህሣሥ', 'ጥር', 'የካቲት', 'መጋቢት', 'ሚያዝያ', 'ግንቦት', 'ሰኔ', 'ሐምሌ', 'ነሐሴ', 'ጳጉሜ'];\n/**\n * @since 16.0.0\n */\nlet NgbDatepickerI18nAmharic = /*#__PURE__*/(() => {\n  class NgbDatepickerI18nAmharic extends NgbDatepickerI18n {\n    getMonthShortName(month, year) {\n      return this.getMonthFullName(month, year);\n    }\n    getMonthFullName(month, year) {\n      return MONTHS[month - 1];\n    }\n    getWeekdayLabel(weekday, width) {\n      return WEEKDAYS[weekday - 1];\n    }\n    getDayAriaLabel(date) {\n      return `${date.day} ${this.getMonthFullName(date.month, date.year)} ${date.year}`;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDatepickerI18nAmharic_BaseFactory;\n      return function NgbDatepickerI18nAmharic_Factory(t) {\n        return (ɵNgbDatepickerI18nAmharic_BaseFactory || (ɵNgbDatepickerI18nAmharic_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDatepickerI18nAmharic)))(t || NgbDatepickerI18nAmharic);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDatepickerI18nAmharic,\n      factory: NgbDatepickerI18nAmharic.ɵfac\n    });\n  }\n  return NgbDatepickerI18nAmharic;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * [`NgbDateAdapter`](#/components/datepicker/api#NgbDateAdapter) implementation that uses\n * native javascript dates as a user date model.\n */\nlet NgbDateNativeAdapter = /*#__PURE__*/(() => {\n  class NgbDateNativeAdapter extends NgbDateAdapter {\n    /**\n     * Converts a native `Date` to a `NgbDateStruct`.\n     */\n    fromModel(date) {\n      return date instanceof Date && !isNaN(date.getTime()) ? this._fromNativeDate(date) : null;\n    }\n    /**\n     * Converts a `NgbDateStruct` to a native `Date`.\n     */\n    toModel(date) {\n      return date && isInteger(date.year) && isInteger(date.month) && isInteger(date.day) ? this._toNativeDate(date) : null;\n    }\n    _fromNativeDate(date) {\n      return {\n        year: date.getFullYear(),\n        month: date.getMonth() + 1,\n        day: date.getDate()\n      };\n    }\n    _toNativeDate(date) {\n      const jsDate = new Date(date.year, date.month - 1, date.day, 12);\n      // avoid 30 -> 1930 conversion\n      jsDate.setFullYear(date.year);\n      return jsDate;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDateNativeAdapter_BaseFactory;\n      return function NgbDateNativeAdapter_Factory(t) {\n        return (ɵNgbDateNativeAdapter_BaseFactory || (ɵNgbDateNativeAdapter_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDateNativeAdapter)))(t || NgbDateNativeAdapter);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDateNativeAdapter,\n      factory: NgbDateNativeAdapter.ɵfac\n    });\n  }\n  return NgbDateNativeAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Same as [`NgbDateNativeAdapter`](#/components/datepicker/api#NgbDateNativeAdapter), but with UTC dates.\n *\n * @since 3.2.0\n */\nlet NgbDateNativeUTCAdapter = /*#__PURE__*/(() => {\n  class NgbDateNativeUTCAdapter extends NgbDateNativeAdapter {\n    _fromNativeDate(date) {\n      return {\n        year: date.getUTCFullYear(),\n        month: date.getUTCMonth() + 1,\n        day: date.getUTCDate()\n      };\n    }\n    _toNativeDate(date) {\n      const jsDate = new Date(Date.UTC(date.year, date.month - 1, date.day));\n      // avoid 30 -> 1930 conversion\n      jsDate.setUTCFullYear(date.year);\n      return jsDate;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDateNativeUTCAdapter_BaseFactory;\n      return function NgbDateNativeUTCAdapter_Factory(t) {\n        return (ɵNgbDateNativeUTCAdapter_BaseFactory || (ɵNgbDateNativeUTCAdapter_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDateNativeUTCAdapter)))(t || NgbDateNativeUTCAdapter);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDateNativeUTCAdapter,\n      factory: NgbDateNativeUTCAdapter.ɵfac\n    });\n  }\n  return NgbDateNativeUTCAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NGB_DATEPICKER_DIRECTIVES = [NgbDatepicker, NgbDatepickerContent, NgbInputDatepicker, NgbDatepickerMonth];\nlet NgbDatepickerModule = /*#__PURE__*/(() => {\n  class NgbDatepickerModule {\n    static #_ = this.ɵfac = function NgbDatepickerModule_Factory(t) {\n      return new (t || NgbDatepickerModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbDatepickerModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbDatepickerModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbDropdown`](#/components/dropdown/api#NgbDropdown) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the dropdowns used in the application.\n */\nlet NgbDropdownConfig = /*#__PURE__*/(() => {\n  class NgbDropdownConfig {\n    constructor() {\n      this.autoClose = true;\n      this.placement = ['bottom-start', 'bottom-end', 'top-start', 'top-end'];\n      this.popperOptions = options => options;\n      this.container = null;\n    }\n    static #_ = this.ɵfac = function NgbDropdownConfig_Factory(t) {\n      return new (t || NgbDropdownConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbDropdownConfig,\n      factory: NgbDropdownConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbDropdownConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive you should put on a dropdown item to enable keyboard navigation.\n * Arrow keys will move focus between items marked with this directive.\n *\n * @since 4.1.0\n */\nlet NgbDropdownItem = /*#__PURE__*/(() => {\n  class NgbDropdownItem {\n    constructor() {\n      this._disabled = false;\n      this.nativeElement = inject(ElementRef).nativeElement;\n      this.tabindex = 0;\n    }\n    set disabled(value) {\n      this._disabled = value === '' || value === true; // accept an empty attribute as true\n    }\n    get disabled() {\n      return this._disabled;\n    }\n    static #_ = this.ɵfac = function NgbDropdownItem_Factory(t) {\n      return new (t || NgbDropdownItem)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbDropdownItem,\n      selectors: [[\"\", \"ngbDropdownItem\", \"\"]],\n      hostAttrs: [1, \"dropdown-item\"],\n      hostVars: 3,\n      hostBindings: function NgbDropdownItem_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabIndex\", ctx.disabled ? -1 : ctx.tabindex);\n          i0.ɵɵclassProp(\"disabled\", ctx.disabled);\n        }\n      },\n      inputs: {\n        tabindex: \"tabindex\",\n        disabled: \"disabled\"\n      },\n      standalone: true\n    });\n  }\n  return NgbDropdownItem;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that will be applied if dropdown item is a button.\n * It will only set the disabled property.\n */\nlet NgbDropdownButtonItem = /*#__PURE__*/(() => {\n  class NgbDropdownButtonItem {\n    constructor() {\n      this.item = inject(NgbDropdownItem);\n    }\n    static #_ = this.ɵfac = function NgbDropdownButtonItem_Factory(t) {\n      return new (t || NgbDropdownButtonItem)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbDropdownButtonItem,\n      selectors: [[\"button\", \"ngbDropdownItem\", \"\"]],\n      hostVars: 1,\n      hostBindings: function NgbDropdownButtonItem_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"disabled\", ctx.item.disabled);\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbDropdownButtonItem;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that wraps dropdown menu content and dropdown items.\n */\nlet NgbDropdownMenu = /*#__PURE__*/(() => {\n  class NgbDropdownMenu {\n    constructor() {\n      this.dropdown = inject(NgbDropdown);\n      this.nativeElement = inject(ElementRef).nativeElement;\n    }\n    static #_ = this.ɵfac = function NgbDropdownMenu_Factory(t) {\n      return new (t || NgbDropdownMenu)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbDropdownMenu,\n      selectors: [[\"\", \"ngbDropdownMenu\", \"\"]],\n      contentQueries: function NgbDropdownMenu_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbDropdownItem, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.menuItems = _t);\n        }\n      },\n      hostVars: 4,\n      hostBindings: function NgbDropdownMenu_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown.ArrowUp\", function NgbDropdownMenu_keydown_ArrowUp_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.ArrowDown\", function NgbDropdownMenu_keydown_ArrowDown_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Home\", function NgbDropdownMenu_keydown_Home_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.End\", function NgbDropdownMenu_keydown_End_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Enter\", function NgbDropdownMenu_keydown_Enter_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Space\", function NgbDropdownMenu_keydown_Space_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Tab\", function NgbDropdownMenu_keydown_Tab_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Shift.Tab\", function NgbDropdownMenu_keydown_Shift_Tab_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"dropdown-menu\", true)(\"show\", ctx.dropdown.isOpen());\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbDropdownMenu;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to mark an element to which dropdown menu will be anchored.\n *\n * This is a simple version of the `NgbDropdownToggle` directive.\n * It plays the same role, but doesn't listen to click events to toggle dropdown menu thus enabling support\n * for events other than click.\n *\n * @since 1.1.0\n */\nlet NgbDropdownAnchor = /*#__PURE__*/(() => {\n  class NgbDropdownAnchor {\n    constructor() {\n      this.dropdown = inject(NgbDropdown);\n      this.nativeElement = inject(ElementRef).nativeElement;\n    }\n    static #_ = this.ɵfac = function NgbDropdownAnchor_Factory(t) {\n      return new (t || NgbDropdownAnchor)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbDropdownAnchor,\n      selectors: [[\"\", \"ngbDropdownAnchor\", \"\"]],\n      hostAttrs: [1, \"dropdown-toggle\"],\n      hostVars: 3,\n      hostBindings: function NgbDropdownAnchor_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-expanded\", ctx.dropdown.isOpen());\n          i0.ɵɵclassProp(\"show\", ctx.dropdown.isOpen());\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbDropdownAnchor;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to mark an element that will toggle dropdown via the `click` event.\n *\n * You can also use `NgbDropdownAnchor` as an alternative.\n */\nlet NgbDropdownToggle = /*#__PURE__*/(() => {\n  class NgbDropdownToggle extends NgbDropdownAnchor {\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbDropdownToggle_BaseFactory;\n      return function NgbDropdownToggle_Factory(t) {\n        return (ɵNgbDropdownToggle_BaseFactory || (ɵNgbDropdownToggle_BaseFactory = i0.ɵɵgetInheritedFactory(NgbDropdownToggle)))(t || NgbDropdownToggle);\n      };\n    })();\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbDropdownToggle,\n      selectors: [[\"\", \"ngbDropdownToggle\", \"\"]],\n      hostAttrs: [1, \"dropdown-toggle\"],\n      hostVars: 3,\n      hostBindings: function NgbDropdownToggle_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function NgbDropdownToggle_click_HostBindingHandler() {\n            return ctx.dropdown.toggle();\n          })(\"keydown.ArrowUp\", function NgbDropdownToggle_keydown_ArrowUp_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.ArrowDown\", function NgbDropdownToggle_keydown_ArrowDown_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Home\", function NgbDropdownToggle_keydown_Home_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.End\", function NgbDropdownToggle_keydown_End_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Tab\", function NgbDropdownToggle_keydown_Tab_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          })(\"keydown.Shift.Tab\", function NgbDropdownToggle_keydown_Shift_Tab_HostBindingHandler($event) {\n            return ctx.dropdown.onKeyDown($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-expanded\", ctx.dropdown.isOpen());\n          i0.ɵɵclassProp(\"show\", ctx.dropdown.isOpen());\n        }\n      },\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NgbDropdownAnchor,\n        useExisting: forwardRef(() => NgbDropdownToggle)\n      }]), i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return NgbDropdownToggle;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that provides contextual overlays for displaying lists of links and more.\n */\nlet NgbDropdown = /*#__PURE__*/(() => {\n  class NgbDropdown {\n    constructor() {\n      this._changeDetector = inject(ChangeDetectorRef);\n      this._config = inject(NgbDropdownConfig);\n      this._document = inject(DOCUMENT);\n      this._ngZone = inject(NgZone);\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this._destroyCloseHandlers$ = new Subject();\n      this._bodyContainer = null;\n      this._positioning = ngbPositioning();\n      /**\n       * Indicates whether the dropdown should be closed when clicking one of dropdown items or pressing ESC.\n       *\n       * * `true` - the dropdown will close on both outside and inside (menu) clicks.\n       * * `false` - the dropdown can only be closed manually via `close()` or `toggle()` methods.\n       * * `\"inside\"` - the dropdown will close on inside menu clicks, but not outside clicks.\n       * * `\"outside\"` - the dropdown will close only on the outside clicks and not on menu clicks.\n       */\n      this.autoClose = this._config.autoClose;\n      /**\n       * Defines whether or not the dropdown menu is opened initially.\n       */\n      this._open = false;\n      /**\n       * The preferred placement of the dropdown, among the [possible values](#/guides/positioning#api).\n       *\n       * The default order of preference is `\"bottom-start bottom-end top-start top-end\"`\n       *\n       * Please see the [positioning overview](#/positioning) for more details.\n       */\n      this.placement = this._config.placement;\n      /**\n       * Allows to change default Popper options when positioning the dropdown.\n       * Receives current popper options and returns modified ones.\n       *\n       * @since 13.1.0\n       */\n      this.popperOptions = this._config.popperOptions;\n      /**\n       * A selector specifying the element the dropdown should be appended to.\n       * Currently only supports \"body\".\n       *\n       * @since 4.1.0\n       */\n      this.container = this._config.container;\n      /**\n       * An event fired when the dropdown is opened or closed.\n       *\n       * The event payload is a `boolean`:\n       * * `true` - the dropdown was opened\n       * * `false` - the dropdown was closed\n       */\n      this.openChange = new EventEmitter();\n    }\n    ngOnInit() {\n      if (!this.display) {\n        this.display = this._nativeElement.closest('.navbar') ? 'static' : 'dynamic';\n      }\n    }\n    ngAfterContentInit() {\n      this._ngZone.onStable.pipe(take(1)).subscribe(() => {\n        this._applyPlacementClasses();\n        if (this._open) {\n          this._setCloseHandlers();\n        }\n      });\n    }\n    ngOnChanges(changes) {\n      if (changes.container && this._open) {\n        this._applyContainer(this.container);\n      }\n      if (changes.placement && !changes.placement.firstChange) {\n        this._positioning.setOptions({\n          hostElement: this._anchor.nativeElement,\n          targetElement: this._bodyContainer || this._menu.nativeElement,\n          placement: this.placement,\n          appendToBody: this.container === 'body'\n        });\n        this._applyPlacementClasses();\n      }\n      if (changes.dropdownClass) {\n        const {\n          currentValue,\n          previousValue\n        } = changes.dropdownClass;\n        this._applyCustomDropdownClass(currentValue, previousValue);\n      }\n      if (changes.autoClose && this._open) {\n        this.autoClose = changes.autoClose.currentValue;\n        this._setCloseHandlers();\n      }\n    }\n    /**\n     * Checks if the dropdown menu is open.\n     */\n    isOpen() {\n      return this._open;\n    }\n    /**\n     * Opens the dropdown menu.\n     */\n    open() {\n      if (!this._open) {\n        this._open = true;\n        this._applyContainer(this.container);\n        this.openChange.emit(true);\n        this._setCloseHandlers();\n        if (this._anchor) {\n          this._anchor.nativeElement.focus();\n          if (this.display === 'dynamic') {\n            this._ngZone.runOutsideAngular(() => {\n              this._positioning.createPopper({\n                hostElement: this._anchor.nativeElement,\n                targetElement: this._bodyContainer || this._menu.nativeElement,\n                placement: this.placement,\n                appendToBody: this.container === 'body',\n                updatePopperOptions: options => this.popperOptions(addPopperOffset([0, 2])(options))\n              });\n              this._applyPlacementClasses();\n              this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positionMenu());\n            });\n          }\n        }\n      }\n    }\n    _setCloseHandlers() {\n      this._destroyCloseHandlers$.next(); // destroy any existing close handlers\n      ngbAutoClose(this._ngZone, this._document, this.autoClose, source => {\n        this.close();\n        if (source === 0 /* SOURCE.ESCAPE */) {\n          this._anchor.nativeElement.focus();\n        }\n      }, this._destroyCloseHandlers$, this._menu ? [this._menu.nativeElement] : [], this._anchor ? [this._anchor.nativeElement] : [], '.dropdown-item,.dropdown-divider');\n    }\n    /**\n     * Closes the dropdown menu.\n     */\n    close() {\n      if (this._open) {\n        this._open = false;\n        this._resetContainer();\n        this._positioning.destroy();\n        this._zoneSubscription?.unsubscribe();\n        this._destroyCloseHandlers$.next();\n        this.openChange.emit(false);\n        this._changeDetector.markForCheck();\n      }\n    }\n    /**\n     * Toggles the dropdown menu.\n     */\n    toggle() {\n      if (this.isOpen()) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    ngOnDestroy() {\n      this.close();\n    }\n    onKeyDown(event) {\n      /* eslint-disable-next-line deprecation/deprecation */\n      const key = event.which;\n      const itemElements = this._getMenuElements();\n      let position = -1;\n      let itemElement = null;\n      const isEventFromToggle = this._isEventFromToggle(event);\n      if (!isEventFromToggle && itemElements.length) {\n        itemElements.forEach((item, index) => {\n          if (item.contains(event.target)) {\n            itemElement = item;\n          }\n          if (item === getActiveElement(this._document)) {\n            position = index;\n          }\n        });\n      }\n      // closing on Enter / Space\n      if (key === Key.Space || key === Key.Enter) {\n        if (itemElement && (this.autoClose === true || this.autoClose === 'inside')) {\n          // Item is either a button or a link, so click will be triggered by the browser on Enter or Space.\n          // So we have to register a one-time click handler that will fire after any user defined click handlers\n          // to close the dropdown\n          fromEvent(itemElement, 'click').pipe(take(1)).subscribe(() => this.close());\n        }\n        return;\n      }\n      if (key === Key.Tab) {\n        if (event.target && this.isOpen() && this.autoClose) {\n          if (this._anchor.nativeElement === event.target) {\n            if (this.container === 'body' && !event.shiftKey) {\n              /* This case is special: user is using [Tab] from the anchor/toggle.\n              User expects the next focusable element in the dropdown menu to get focus.\n              But the menu is not a sibling to anchor/toggle, it is at the end of the body.\n              Trick is to synchronously focus the menu element, and let the [keydown.Tab] go\n              so that browser will focus the proper element (first one focusable in the menu) */\n              this._menu.nativeElement.setAttribute('tabindex', '0');\n              this._menu.nativeElement.focus();\n              this._menu.nativeElement.removeAttribute('tabindex');\n            } else if (event.shiftKey) {\n              this.close();\n            }\n            return;\n          } else if (this.container === 'body') {\n            const focusableElements = this._menu.nativeElement.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR);\n            if (event.shiftKey && event.target === focusableElements[0]) {\n              this._anchor.nativeElement.focus();\n              event.preventDefault();\n            } else if (!event.shiftKey && event.target === focusableElements[focusableElements.length - 1]) {\n              this._anchor.nativeElement.focus();\n              this.close();\n            }\n          } else {\n            fromEvent(event.target, 'focusout').pipe(take(1)).subscribe(({\n              relatedTarget\n            }) => {\n              if (!this._nativeElement.contains(relatedTarget)) {\n                this.close();\n              }\n            });\n          }\n        }\n        return;\n      }\n      // opening / navigating\n      if (isEventFromToggle || itemElement) {\n        this.open();\n        if (itemElements.length) {\n          switch (key) {\n            case Key.ArrowDown:\n              position = Math.min(position + 1, itemElements.length - 1);\n              break;\n            case Key.ArrowUp:\n              if (this._isDropup() && position === -1) {\n                position = itemElements.length - 1;\n                break;\n              }\n              position = Math.max(position - 1, 0);\n              break;\n            case Key.Home:\n              position = 0;\n              break;\n            case Key.End:\n              position = itemElements.length - 1;\n              break;\n          }\n          itemElements[position].focus();\n        }\n        event.preventDefault();\n      }\n    }\n    _isDropup() {\n      return this._nativeElement.classList.contains('dropup');\n    }\n    _isEventFromToggle(event) {\n      return this._anchor.nativeElement.contains(event.target);\n    }\n    _getMenuElements() {\n      return this._menu ? this._menu.menuItems.filter(({\n        disabled\n      }) => !disabled).map(({\n        nativeElement\n      }) => nativeElement) : [];\n    }\n    _positionMenu() {\n      const menu = this._menu;\n      if (this.isOpen() && menu) {\n        if (this.display === 'dynamic') {\n          this._positioning.update();\n          this._applyPlacementClasses();\n        } else {\n          this._applyPlacementClasses(this._getFirstPlacement(this.placement));\n        }\n      }\n    }\n    _getFirstPlacement(placement) {\n      return Array.isArray(placement) ? placement[0] : placement.split(' ')[0];\n    }\n    _resetContainer() {\n      if (this._menu) {\n        this._nativeElement.appendChild(this._menu.nativeElement);\n      }\n      if (this._bodyContainer) {\n        this._document.body.removeChild(this._bodyContainer);\n        this._bodyContainer = null;\n      }\n    }\n    _applyContainer(container = null) {\n      this._resetContainer();\n      if (container === 'body') {\n        const dropdownMenuElement = this._menu.nativeElement;\n        const bodyContainer = this._bodyContainer = this._bodyContainer || this._document.createElement('div');\n        // Override some styles to have the positioning working\n        bodyContainer.style.position = 'absolute';\n        dropdownMenuElement.style.position = 'static';\n        bodyContainer.style.zIndex = '1055';\n        bodyContainer.appendChild(dropdownMenuElement);\n        this._document.body.appendChild(bodyContainer);\n      }\n      this._applyCustomDropdownClass(this.dropdownClass);\n    }\n    _applyCustomDropdownClass(newClass, oldClass) {\n      const targetElement = this.container === 'body' ? this._bodyContainer : this._nativeElement;\n      if (targetElement) {\n        if (oldClass) {\n          targetElement.classList.remove(oldClass);\n        }\n        if (newClass) {\n          targetElement.classList.add(newClass);\n        }\n      }\n    }\n    _applyPlacementClasses(placement) {\n      if (this._menu) {\n        if (!placement) {\n          placement = this._getFirstPlacement(this.placement);\n        }\n        // remove the current placement classes\n        this._nativeElement.classList.remove('dropup', 'dropdown');\n        if (this.display === 'static') {\n          this._menu.nativeElement.setAttribute('data-bs-popper', 'static');\n        } else {\n          this._menu.nativeElement.removeAttribute('data-bs-popper');\n        }\n        /*\n         * apply the new placement\n         * in case of top use up-arrow or down-arrow otherwise\n         */\n        const dropdownClass = placement.search('^top') !== -1 ? 'dropup' : 'dropdown';\n        this._nativeElement.classList.add(dropdownClass);\n        if (this._bodyContainer) {\n          this._bodyContainer.classList.remove('dropup', 'dropdown');\n          this._bodyContainer.classList.add(dropdownClass);\n        }\n      }\n    }\n    static #_ = this.ɵfac = function NgbDropdown_Factory(t) {\n      return new (t || NgbDropdown)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbDropdown,\n      selectors: [[\"\", \"ngbDropdown\", \"\"]],\n      contentQueries: function NgbDropdown_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbDropdownMenu, 5);\n          i0.ɵɵcontentQuery(dirIndex, NgbDropdownAnchor, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._menu = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._anchor = _t.first);\n        }\n      },\n      hostVars: 2,\n      hostBindings: function NgbDropdown_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"show\", ctx.isOpen());\n        }\n      },\n      inputs: {\n        autoClose: \"autoClose\",\n        dropdownClass: \"dropdownClass\",\n        _open: [i0.ɵɵInputFlags.None, \"open\", \"_open\"],\n        placement: \"placement\",\n        popperOptions: \"popperOptions\",\n        container: \"container\",\n        display: \"display\"\n      },\n      outputs: {\n        openChange: \"openChange\"\n      },\n      exportAs: [\"ngbDropdown\"],\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgbDropdown;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NGB_DROPDOWN_DIRECTIVES = [NgbDropdown, NgbDropdownAnchor, NgbDropdownToggle, NgbDropdownMenu, NgbDropdownItem, NgbDropdownButtonItem];\nlet NgbDropdownModule = /*#__PURE__*/(() => {\n  class NgbDropdownModule {\n    static #_ = this.ɵfac = function NgbDropdownModule_Factory(t) {\n      return new (t || NgbDropdownModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbDropdownModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbDropdownModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbModal`](#/components/modal/api#NgbModal) service.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all modals used in the application.\n *\n * @since 3.1.0\n */\nlet NgbModalConfig = /*#__PURE__*/(() => {\n  class NgbModalConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.backdrop = true;\n      this.fullscreen = false;\n      this.keyboard = true;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbModalConfig_Factory(t) {\n      return new (t || NgbModalConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbModalConfig,\n      factory: NgbModalConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbModalConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass ContentRef {\n  constructor(nodes, viewRef, componentRef) {\n    this.nodes = nodes;\n    this.viewRef = viewRef;\n    this.componentRef = componentRef;\n  }\n}\nclass PopupService {\n  constructor(_componentType) {\n    this._componentType = _componentType;\n    this._windowRef = null;\n    this._contentRef = null;\n    this._document = inject(DOCUMENT);\n    this._applicationRef = inject(ApplicationRef);\n    this._injector = inject(Injector);\n    this._viewContainerRef = inject(ViewContainerRef);\n    this._ngZone = inject(NgZone);\n  }\n  open(content, templateContext, animation = false) {\n    if (!this._windowRef) {\n      this._contentRef = this._getContentRef(content, templateContext);\n      this._windowRef = this._viewContainerRef.createComponent(this._componentType, {\n        injector: this._injector,\n        projectableNodes: this._contentRef.nodes\n      });\n    }\n    const {\n      nativeElement\n    } = this._windowRef.location;\n    const transition$ = this._ngZone.onStable.pipe(take(1), mergeMap(() => ngbRunTransition(this._ngZone, nativeElement, ({\n      classList\n    }) => classList.add('show'), {\n      animation,\n      runningTransition: 'continue'\n    })));\n    return {\n      windowRef: this._windowRef,\n      transition$\n    };\n  }\n  close(animation = false) {\n    if (!this._windowRef) {\n      return of(undefined);\n    }\n    return ngbRunTransition(this._ngZone, this._windowRef.location.nativeElement, ({\n      classList\n    }) => classList.remove('show'), {\n      animation,\n      runningTransition: 'stop'\n    }).pipe(tap(() => {\n      if (this._windowRef) {\n        // this is required because of the container='body' option\n        this._viewContainerRef.remove(this._viewContainerRef.indexOf(this._windowRef.hostView));\n        this._windowRef = null;\n      }\n      if (this._contentRef?.viewRef) {\n        this._applicationRef.detachView(this._contentRef.viewRef);\n        this._contentRef.viewRef.destroy();\n        this._contentRef = null;\n      }\n    }));\n  }\n  _getContentRef(content, templateContext) {\n    if (!content) {\n      return new ContentRef([]);\n    } else if (content instanceof TemplateRef) {\n      const viewRef = content.createEmbeddedView(templateContext);\n      this._applicationRef.attachView(viewRef);\n      return new ContentRef([viewRef.rootNodes], viewRef);\n    } else {\n      return new ContentRef([[this._document.createTextNode(`${content}`)]]);\n    }\n  }\n}\n\n/**\n * Utility to handle the scrollbar.\n *\n * It allows to hide the scrollbar and compensate the lack of a vertical scrollbar\n * by adding an equivalent padding on the right of the body, and to revert this change.\n */\nlet ScrollBar = /*#__PURE__*/(() => {\n  class ScrollBar {\n    constructor() {\n      this._document = inject(DOCUMENT);\n    }\n    /**\n     * To be called to hide a potential vertical scrollbar:\n     * - if a scrollbar is there and has a width greater than 0, adds some compensation\n     * padding to the body to keep the same layout as when the scrollbar is there\n     * - adds overflow: hidden\n     *\n     * @return a callback used to revert the change\n     */\n    hide() {\n      const scrollbarWidth = Math.abs(window.innerWidth - this._document.documentElement.clientWidth);\n      const body = this._document.body;\n      const bodyStyle = body.style;\n      const {\n        overflow,\n        paddingRight\n      } = bodyStyle;\n      if (scrollbarWidth > 0) {\n        const actualPadding = parseFloat(window.getComputedStyle(body).paddingRight);\n        bodyStyle.paddingRight = `${actualPadding + scrollbarWidth}px`;\n      }\n      bodyStyle.overflow = 'hidden';\n      return () => {\n        if (scrollbarWidth > 0) {\n          bodyStyle.paddingRight = paddingRight;\n        }\n        bodyStyle.overflow = overflow;\n      };\n    }\n    static #_ = this.ɵfac = function ScrollBar_Factory(t) {\n      return new (t || ScrollBar)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: ScrollBar,\n      factory: ScrollBar.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return ScrollBar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbModalBackdrop = /*#__PURE__*/(() => {\n  class NgbModalBackdrop {\n    constructor() {\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this._zone = inject(NgZone);\n    }\n    ngOnInit() {\n      this._zone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        ngbRunTransition(this._zone, this._nativeElement, (element, animation) => {\n          if (animation) {\n            reflow(element);\n          }\n          element.classList.add('show');\n        }, {\n          animation: this.animation,\n          runningTransition: 'continue'\n        });\n      });\n    }\n    hide() {\n      return ngbRunTransition(this._zone, this._nativeElement, ({\n        classList\n      }) => classList.remove('show'), {\n        animation: this.animation,\n        runningTransition: 'stop'\n      });\n    }\n    static #_ = this.ɵfac = function NgbModalBackdrop_Factory(t) {\n      return new (t || NgbModalBackdrop)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbModalBackdrop,\n      selectors: [[\"ngb-modal-backdrop\"]],\n      hostAttrs: [2, \"z-index\", \"1055\"],\n      hostVars: 6,\n      hostBindings: function NgbModalBackdrop_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassMap(\"modal-backdrop\" + (ctx.backdropClass ? \" \" + ctx.backdropClass : \"\"));\n          i0.ɵɵclassProp(\"show\", !ctx.animation)(\"fade\", ctx.animation);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        backdropClass: \"backdropClass\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 0,\n      vars: 0,\n      template: function NgbModalBackdrop_Template(rf, ctx) {},\n      encapsulation: 2\n    });\n  }\n  return NgbModalBackdrop;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A reference to the currently opened (active) modal.\n *\n * Instances of this class can be injected into your component passed as modal content.\n * So you can `.update()`, `.close()` or `.dismiss()` the modal window from your component.\n */\nclass NgbActiveModal {\n  /**\n   * Updates options of an opened modal.\n   *\n   * @since 14.2.0\n   */\n  update(options) {}\n  /**\n   * Closes the modal with an optional `result` value.\n   *\n   * The `NgbModalRef.result` promise will be resolved with the provided value.\n   */\n  close(result) {}\n  /**\n   * Dismisses the modal with an optional `reason` value.\n   *\n   * The `NgbModalRef.result` promise will be rejected with the provided value.\n   */\n  dismiss(reason) {}\n}\nconst WINDOW_ATTRIBUTES = ['animation', 'ariaLabelledBy', 'ariaDescribedBy', 'backdrop', 'centered', 'fullscreen', 'keyboard', 'scrollable', 'size', 'windowClass', 'modalDialogClass'];\nconst BACKDROP_ATTRIBUTES = ['animation', 'backdropClass'];\n/**\n * A reference to the newly opened modal returned by the `NgbModal.open()` method.\n */\nclass NgbModalRef {\n  _applyWindowOptions(windowInstance, options) {\n    WINDOW_ATTRIBUTES.forEach(optionName => {\n      if (isDefined(options[optionName])) {\n        windowInstance[optionName] = options[optionName];\n      }\n    });\n  }\n  _applyBackdropOptions(backdropInstance, options) {\n    BACKDROP_ATTRIBUTES.forEach(optionName => {\n      if (isDefined(options[optionName])) {\n        backdropInstance[optionName] = options[optionName];\n      }\n    });\n  }\n  /**\n   * Updates options of an opened modal.\n   *\n   * @since 14.2.0\n   */\n  update(options) {\n    this._applyWindowOptions(this._windowCmptRef.instance, options);\n    if (this._backdropCmptRef && this._backdropCmptRef.instance) {\n      this._applyBackdropOptions(this._backdropCmptRef.instance, options);\n    }\n  }\n  /**\n   * The instance of a component used for the modal content.\n   *\n   * When a `TemplateRef` is used as the content or when the modal is closed, will return `undefined`.\n   */\n  get componentInstance() {\n    if (this._contentRef && this._contentRef.componentRef) {\n      return this._contentRef.componentRef.instance;\n    }\n  }\n  /**\n   * The observable that emits when the modal is closed via the `.close()` method.\n   *\n   * It will emit the result passed to the `.close()` method.\n   *\n   * @since 8.0.0\n   */\n  get closed() {\n    return this._closed.asObservable().pipe(takeUntil(this._hidden));\n  }\n  /**\n   * The observable that emits when the modal is dismissed via the `.dismiss()` method.\n   *\n   * It will emit the reason passed to the `.dismissed()` method by the user, or one of the internal\n   * reasons like backdrop click or ESC key press.\n   *\n   * @since 8.0.0\n   */\n  get dismissed() {\n    return this._dismissed.asObservable().pipe(takeUntil(this._hidden));\n  }\n  /**\n   * The observable that emits when both modal window and backdrop are closed and animations were finished.\n   * At this point modal and backdrop elements will be removed from the DOM tree.\n   *\n   * This observable will be completed after emitting.\n   *\n   * @since 8.0.0\n   */\n  get hidden() {\n    return this._hidden.asObservable();\n  }\n  /**\n   * The observable that emits when modal is fully visible and animation was finished.\n   * Modal DOM element is always available synchronously after calling 'modal.open()' service.\n   *\n   * This observable will be completed after emitting.\n   * It will not emit, if modal is closed before open animation is finished.\n   *\n   * @since 8.0.0\n   */\n  get shown() {\n    return this._windowCmptRef.instance.shown.asObservable();\n  }\n  constructor(_windowCmptRef, _contentRef, _backdropCmptRef, _beforeDismiss) {\n    this._windowCmptRef = _windowCmptRef;\n    this._contentRef = _contentRef;\n    this._backdropCmptRef = _backdropCmptRef;\n    this._beforeDismiss = _beforeDismiss;\n    this._closed = new Subject();\n    this._dismissed = new Subject();\n    this._hidden = new Subject();\n    _windowCmptRef.instance.dismissEvent.subscribe(reason => {\n      this.dismiss(reason);\n    });\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    this.result.then(null, () => {});\n  }\n  /**\n   * Closes the modal with an optional `result` value.\n   *\n   * The `NgbMobalRef.result` promise will be resolved with the provided value.\n   */\n  close(result) {\n    if (this._windowCmptRef) {\n      this._closed.next(result);\n      this._resolve(result);\n      this._removeModalElements();\n    }\n  }\n  _dismiss(reason) {\n    this._dismissed.next(reason);\n    this._reject(reason);\n    this._removeModalElements();\n  }\n  /**\n   * Dismisses the modal with an optional `reason` value.\n   *\n   * The `NgbModalRef.result` promise will be rejected with the provided value.\n   */\n  dismiss(reason) {\n    if (this._windowCmptRef) {\n      if (!this._beforeDismiss) {\n        this._dismiss(reason);\n      } else {\n        const dismiss = this._beforeDismiss();\n        if (isPromise(dismiss)) {\n          dismiss.then(result => {\n            if (result !== false) {\n              this._dismiss(reason);\n            }\n          }, () => {});\n        } else if (dismiss !== false) {\n          this._dismiss(reason);\n        }\n      }\n    }\n  }\n  _removeModalElements() {\n    const windowTransition$ = this._windowCmptRef.instance.hide();\n    const backdropTransition$ = this._backdropCmptRef ? this._backdropCmptRef.instance.hide() : of(undefined);\n    // hiding window\n    windowTransition$.subscribe(() => {\n      const {\n        nativeElement\n      } = this._windowCmptRef.location;\n      nativeElement.parentNode.removeChild(nativeElement);\n      this._windowCmptRef.destroy();\n      if (this._contentRef && this._contentRef.viewRef) {\n        this._contentRef.viewRef.destroy();\n      }\n      this._windowCmptRef = null;\n      this._contentRef = null;\n    });\n    // hiding backdrop\n    backdropTransition$.subscribe(() => {\n      if (this._backdropCmptRef) {\n        const {\n          nativeElement\n        } = this._backdropCmptRef.location;\n        nativeElement.parentNode.removeChild(nativeElement);\n        this._backdropCmptRef.destroy();\n        this._backdropCmptRef = null;\n      }\n    });\n    // all done\n    zip(windowTransition$, backdropTransition$).subscribe(() => {\n      this._hidden.next();\n      this._hidden.complete();\n    });\n  }\n}\nvar ModalDismissReasons = /*#__PURE__*/function (ModalDismissReasons) {\n  ModalDismissReasons[ModalDismissReasons[\"BACKDROP_CLICK\"] = 0] = \"BACKDROP_CLICK\";\n  ModalDismissReasons[ModalDismissReasons[\"ESC\"] = 1] = \"ESC\";\n  return ModalDismissReasons;\n}(ModalDismissReasons || {});\nlet NgbModalWindow = /*#__PURE__*/(() => {\n  class NgbModalWindow {\n    constructor() {\n      this._document = inject(DOCUMENT);\n      this._elRef = inject(ElementRef);\n      this._zone = inject(NgZone);\n      this._closed$ = new Subject();\n      this._elWithFocus = null; // element that is focused prior to modal opening\n      this.backdrop = true;\n      this.keyboard = true;\n      this.dismissEvent = new EventEmitter();\n      this.shown = new Subject();\n      this.hidden = new Subject();\n    }\n    get fullscreenClass() {\n      return this.fullscreen === true ? ' modal-fullscreen' : isString(this.fullscreen) ? ` modal-fullscreen-${this.fullscreen}-down` : '';\n    }\n    dismiss(reason) {\n      this.dismissEvent.emit(reason);\n    }\n    ngOnInit() {\n      this._elWithFocus = this._document.activeElement;\n      this._zone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        this._show();\n      });\n    }\n    ngOnDestroy() {\n      this._disableEventHandling();\n    }\n    hide() {\n      const {\n        nativeElement\n      } = this._elRef;\n      const context = {\n        animation: this.animation,\n        runningTransition: 'stop'\n      };\n      const windowTransition$ = ngbRunTransition(this._zone, nativeElement, () => nativeElement.classList.remove('show'), context);\n      const dialogTransition$ = ngbRunTransition(this._zone, this._dialogEl.nativeElement, () => {}, context);\n      const transitions$ = zip(windowTransition$, dialogTransition$);\n      transitions$.subscribe(() => {\n        this.hidden.next();\n        this.hidden.complete();\n      });\n      this._disableEventHandling();\n      this._restoreFocus();\n      return transitions$;\n    }\n    _show() {\n      const context = {\n        animation: this.animation,\n        runningTransition: 'continue'\n      };\n      const windowTransition$ = ngbRunTransition(this._zone, this._elRef.nativeElement, (element, animation) => {\n        if (animation) {\n          reflow(element);\n        }\n        element.classList.add('show');\n      }, context);\n      const dialogTransition$ = ngbRunTransition(this._zone, this._dialogEl.nativeElement, () => {}, context);\n      zip(windowTransition$, dialogTransition$).subscribe(() => {\n        this.shown.next();\n        this.shown.complete();\n      });\n      this._enableEventHandling();\n      this._setFocus();\n    }\n    _enableEventHandling() {\n      const {\n        nativeElement\n      } = this._elRef;\n      this._zone.runOutsideAngular(() => {\n        fromEvent(nativeElement, 'keydown').pipe(takeUntil(this._closed$), /* eslint-disable-next-line deprecation/deprecation */\n        filter(e => e.which === Key.Escape)).subscribe(event => {\n          if (this.keyboard) {\n            requestAnimationFrame(() => {\n              if (!event.defaultPrevented) {\n                this._zone.run(() => this.dismiss(ModalDismissReasons.ESC));\n              }\n            });\n          } else if (this.backdrop === 'static') {\n            this._bumpBackdrop();\n          }\n        });\n        // We're listening to 'mousedown' and 'mouseup' to prevent modal from closing when pressing the mouse\n        // inside the modal dialog and releasing it outside\n        let preventClose = false;\n        fromEvent(this._dialogEl.nativeElement, 'mousedown').pipe(takeUntil(this._closed$), tap(() => preventClose = false), switchMap(() => fromEvent(nativeElement, 'mouseup').pipe(takeUntil(this._closed$), take(1))), filter(({\n          target\n        }) => nativeElement === target)).subscribe(() => {\n          preventClose = true;\n        });\n        // We're listening to 'click' to dismiss modal on modal window click, except when:\n        // 1. clicking on modal dialog itself\n        // 2. closing was prevented by mousedown/up handlers\n        // 3. clicking on scrollbar when the viewport is too small and modal doesn't fit (click is not triggered at all)\n        fromEvent(nativeElement, 'click').pipe(takeUntil(this._closed$)).subscribe(({\n          target\n        }) => {\n          if (nativeElement === target) {\n            if (this.backdrop === 'static') {\n              this._bumpBackdrop();\n            } else if (this.backdrop === true && !preventClose) {\n              this._zone.run(() => this.dismiss(ModalDismissReasons.BACKDROP_CLICK));\n            }\n          }\n          preventClose = false;\n        });\n      });\n    }\n    _disableEventHandling() {\n      this._closed$.next();\n    }\n    _setFocus() {\n      const {\n        nativeElement\n      } = this._elRef;\n      if (!nativeElement.contains(document.activeElement)) {\n        const autoFocusable = nativeElement.querySelector(`[ngbAutofocus]`);\n        const firstFocusable = getFocusableBoundaryElements(nativeElement)[0];\n        const elementToFocus = autoFocusable || firstFocusable || nativeElement;\n        elementToFocus.focus();\n      }\n    }\n    _restoreFocus() {\n      const body = this._document.body;\n      const elWithFocus = this._elWithFocus;\n      let elementToFocus;\n      if (elWithFocus && elWithFocus['focus'] && body.contains(elWithFocus)) {\n        elementToFocus = elWithFocus;\n      } else {\n        elementToFocus = body;\n      }\n      this._zone.runOutsideAngular(() => {\n        setTimeout(() => elementToFocus.focus());\n        this._elWithFocus = null;\n      });\n    }\n    _bumpBackdrop() {\n      if (this.backdrop === 'static') {\n        ngbRunTransition(this._zone, this._elRef.nativeElement, ({\n          classList\n        }) => {\n          classList.add('modal-static');\n          return () => classList.remove('modal-static');\n        }, {\n          animation: this.animation,\n          runningTransition: 'continue'\n        });\n      }\n    }\n    static #_ = this.ɵfac = function NgbModalWindow_Factory(t) {\n      return new (t || NgbModalWindow)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbModalWindow,\n      selectors: [[\"ngb-modal-window\"]],\n      viewQuery: function NgbModalWindow_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(_c7, 7);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._dialogEl = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"dialog\", \"tabindex\", \"-1\"],\n      hostVars: 7,\n      hostBindings: function NgbModalWindow_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-modal\", true)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-describedby\", ctx.ariaDescribedBy);\n          i0.ɵɵclassMap(\"modal d-block\" + (ctx.windowClass ? \" \" + ctx.windowClass : \"\"));\n          i0.ɵɵclassProp(\"fade\", ctx.animation);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        ariaLabelledBy: \"ariaLabelledBy\",\n        ariaDescribedBy: \"ariaDescribedBy\",\n        backdrop: \"backdrop\",\n        centered: \"centered\",\n        fullscreen: \"fullscreen\",\n        keyboard: \"keyboard\",\n        scrollable: \"scrollable\",\n        size: \"size\",\n        windowClass: \"windowClass\",\n        modalDialogClass: \"modalDialogClass\"\n      },\n      outputs: {\n        dismissEvent: \"dismiss\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 4,\n      vars: 2,\n      consts: [[\"role\", \"document\"], [\"dialog\", \"\"], [1, \"modal-content\"]],\n      template: function NgbModalWindow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"div\", 2);\n          i0.ɵɵprojection(3);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵclassMap(\"modal-dialog\" + (ctx.size ? \" modal-\" + ctx.size : \"\") + (ctx.centered ? \" modal-dialog-centered\" : \"\") + ctx.fullscreenClass + (ctx.scrollable ? \" modal-dialog-scrollable\" : \"\") + (ctx.modalDialogClass ? \" \" + ctx.modalDialogClass : \"\"));\n        }\n      },\n      styles: [\"ngb-modal-window .component-host-scrollable{display:flex;flex-direction:column;overflow:hidden}\\n\"],\n      encapsulation: 2\n    });\n  }\n  return NgbModalWindow;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbModalStack = /*#__PURE__*/(() => {\n  class NgbModalStack {\n    constructor() {\n      this._applicationRef = inject(ApplicationRef);\n      this._injector = inject(Injector);\n      this._environmentInjector = inject(EnvironmentInjector);\n      this._document = inject(DOCUMENT);\n      this._scrollBar = inject(ScrollBar);\n      this._activeWindowCmptHasChanged = new Subject();\n      this._ariaHiddenValues = new Map();\n      this._scrollBarRestoreFn = null;\n      this._modalRefs = [];\n      this._windowCmpts = [];\n      this._activeInstances = new EventEmitter();\n      const ngZone = inject(NgZone);\n      // Trap focus on active WindowCmpt\n      this._activeWindowCmptHasChanged.subscribe(() => {\n        if (this._windowCmpts.length) {\n          const activeWindowCmpt = this._windowCmpts[this._windowCmpts.length - 1];\n          ngbFocusTrap(ngZone, activeWindowCmpt.location.nativeElement, this._activeWindowCmptHasChanged);\n          this._revertAriaHidden();\n          this._setAriaHidden(activeWindowCmpt.location.nativeElement);\n        }\n      });\n    }\n    _restoreScrollBar() {\n      const scrollBarRestoreFn = this._scrollBarRestoreFn;\n      if (scrollBarRestoreFn) {\n        this._scrollBarRestoreFn = null;\n        scrollBarRestoreFn();\n      }\n    }\n    _hideScrollBar() {\n      if (!this._scrollBarRestoreFn) {\n        this._scrollBarRestoreFn = this._scrollBar.hide();\n      }\n    }\n    open(contentInjector, content, options) {\n      const containerEl = options.container instanceof HTMLElement ? options.container : isDefined(options.container) ? this._document.querySelector(options.container) : this._document.body;\n      if (!containerEl) {\n        throw new Error(`The specified modal container \"${options.container || 'body'}\" was not found in the DOM.`);\n      }\n      this._hideScrollBar();\n      const activeModal = new NgbActiveModal();\n      contentInjector = options.injector || contentInjector;\n      const environmentInjector = contentInjector.get(EnvironmentInjector, null) || this._environmentInjector;\n      const contentRef = this._getContentRef(contentInjector, environmentInjector, content, activeModal, options);\n      let backdropCmptRef = options.backdrop !== false ? this._attachBackdrop(containerEl) : undefined;\n      let windowCmptRef = this._attachWindowComponent(containerEl, contentRef.nodes);\n      let ngbModalRef = new NgbModalRef(windowCmptRef, contentRef, backdropCmptRef, options.beforeDismiss);\n      this._registerModalRef(ngbModalRef);\n      this._registerWindowCmpt(windowCmptRef);\n      // We have to cleanup DOM after the last modal when BOTH 'hidden' was emitted and 'result' promise was resolved:\n      // - with animations OFF, 'hidden' emits synchronously, then 'result' is resolved asynchronously\n      // - with animations ON, 'result' is resolved asynchronously, then 'hidden' emits asynchronously\n      ngbModalRef.hidden.pipe(take(1)).subscribe(() => Promise.resolve(true).then(() => {\n        if (!this._modalRefs.length) {\n          this._document.body.classList.remove('modal-open');\n          this._restoreScrollBar();\n          this._revertAriaHidden();\n        }\n      }));\n      activeModal.close = result => {\n        ngbModalRef.close(result);\n      };\n      activeModal.dismiss = reason => {\n        ngbModalRef.dismiss(reason);\n      };\n      activeModal.update = options => {\n        ngbModalRef.update(options);\n      };\n      ngbModalRef.update(options);\n      if (this._modalRefs.length === 1) {\n        this._document.body.classList.add('modal-open');\n      }\n      if (backdropCmptRef && backdropCmptRef.instance) {\n        backdropCmptRef.changeDetectorRef.detectChanges();\n      }\n      windowCmptRef.changeDetectorRef.detectChanges();\n      return ngbModalRef;\n    }\n    get activeInstances() {\n      return this._activeInstances;\n    }\n    dismissAll(reason) {\n      this._modalRefs.forEach(ngbModalRef => ngbModalRef.dismiss(reason));\n    }\n    hasOpenModals() {\n      return this._modalRefs.length > 0;\n    }\n    _attachBackdrop(containerEl) {\n      let backdropCmptRef = createComponent(NgbModalBackdrop, {\n        environmentInjector: this._applicationRef.injector,\n        elementInjector: this._injector\n      });\n      this._applicationRef.attachView(backdropCmptRef.hostView);\n      containerEl.appendChild(backdropCmptRef.location.nativeElement);\n      return backdropCmptRef;\n    }\n    _attachWindowComponent(containerEl, projectableNodes) {\n      let windowCmptRef = createComponent(NgbModalWindow, {\n        environmentInjector: this._applicationRef.injector,\n        elementInjector: this._injector,\n        projectableNodes\n      });\n      this._applicationRef.attachView(windowCmptRef.hostView);\n      containerEl.appendChild(windowCmptRef.location.nativeElement);\n      return windowCmptRef;\n    }\n    _getContentRef(contentInjector, environmentInjector, content, activeModal, options) {\n      if (!content) {\n        return new ContentRef([]);\n      } else if (content instanceof TemplateRef) {\n        return this._createFromTemplateRef(content, activeModal);\n      } else if (isString(content)) {\n        return this._createFromString(content);\n      } else {\n        return this._createFromComponent(contentInjector, environmentInjector, content, activeModal, options);\n      }\n    }\n    _createFromTemplateRef(templateRef, activeModal) {\n      const context = {\n        $implicit: activeModal,\n        close(result) {\n          activeModal.close(result);\n        },\n        dismiss(reason) {\n          activeModal.dismiss(reason);\n        }\n      };\n      const viewRef = templateRef.createEmbeddedView(context);\n      this._applicationRef.attachView(viewRef);\n      return new ContentRef([viewRef.rootNodes], viewRef);\n    }\n    _createFromString(content) {\n      const component = this._document.createTextNode(`${content}`);\n      return new ContentRef([[component]]);\n    }\n    _createFromComponent(contentInjector, environmentInjector, componentType, context, options) {\n      const elementInjector = Injector.create({\n        providers: [{\n          provide: NgbActiveModal,\n          useValue: context\n        }],\n        parent: contentInjector\n      });\n      const componentRef = createComponent(componentType, {\n        environmentInjector,\n        elementInjector\n      });\n      const componentNativeEl = componentRef.location.nativeElement;\n      if (options.scrollable) {\n        componentNativeEl.classList.add('component-host-scrollable');\n      }\n      this._applicationRef.attachView(componentRef.hostView);\n      // FIXME: we should here get rid of the component nativeElement\n      // and use `[Array.from(componentNativeEl.childNodes)]` instead and remove the above CSS class.\n      return new ContentRef([[componentNativeEl]], componentRef.hostView, componentRef);\n    }\n    _setAriaHidden(element) {\n      const parent = element.parentElement;\n      if (parent && element !== this._document.body) {\n        Array.from(parent.children).forEach(sibling => {\n          if (sibling !== element && sibling.nodeName !== 'SCRIPT') {\n            this._ariaHiddenValues.set(sibling, sibling.getAttribute('aria-hidden'));\n            sibling.setAttribute('aria-hidden', 'true');\n          }\n        });\n        this._setAriaHidden(parent);\n      }\n    }\n    _revertAriaHidden() {\n      this._ariaHiddenValues.forEach((value, element) => {\n        if (value) {\n          element.setAttribute('aria-hidden', value);\n        } else {\n          element.removeAttribute('aria-hidden');\n        }\n      });\n      this._ariaHiddenValues.clear();\n    }\n    _registerModalRef(ngbModalRef) {\n      const unregisterModalRef = () => {\n        const index = this._modalRefs.indexOf(ngbModalRef);\n        if (index > -1) {\n          this._modalRefs.splice(index, 1);\n          this._activeInstances.emit(this._modalRefs);\n        }\n      };\n      this._modalRefs.push(ngbModalRef);\n      this._activeInstances.emit(this._modalRefs);\n      ngbModalRef.result.then(unregisterModalRef, unregisterModalRef);\n    }\n    _registerWindowCmpt(ngbWindowCmpt) {\n      this._windowCmpts.push(ngbWindowCmpt);\n      this._activeWindowCmptHasChanged.next();\n      ngbWindowCmpt.onDestroy(() => {\n        const index = this._windowCmpts.indexOf(ngbWindowCmpt);\n        if (index > -1) {\n          this._windowCmpts.splice(index, 1);\n          this._activeWindowCmptHasChanged.next();\n        }\n      });\n    }\n    static #_ = this.ɵfac = function NgbModalStack_Factory(t) {\n      return new (t || NgbModalStack)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbModalStack,\n      factory: NgbModalStack.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbModalStack;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A service for opening modal windows.\n *\n * Creating a modal is straightforward: create a component or a template and pass it as an argument to\n * the `.open()` method.\n */\nlet NgbModal = /*#__PURE__*/(() => {\n  class NgbModal {\n    constructor() {\n      this._injector = inject(Injector);\n      this._modalStack = inject(NgbModalStack);\n      this._config = inject(NgbModalConfig);\n    }\n    /**\n     * Opens a new modal window with the specified content and supplied options.\n     *\n     * Content can be provided as a `TemplateRef` or a component type. If you pass a component type as content,\n     * then instances of those components can be injected with an instance of the `NgbActiveModal` class. You can then\n     * use `NgbActiveModal` methods to close / dismiss modals from \"inside\" of your component.\n     *\n     * Also see the [`NgbModalOptions`](#/components/modal/api#NgbModalOptions) for the list of supported options.\n     */\n    open(content, options = {}) {\n      const combinedOptions = {\n        ...this._config,\n        animation: this._config.animation,\n        ...options\n      };\n      return this._modalStack.open(this._injector, content, combinedOptions);\n    }\n    /**\n     * Returns an observable that holds the active modal instances.\n     */\n    get activeInstances() {\n      return this._modalStack.activeInstances;\n    }\n    /**\n     * Dismisses all currently displayed modal windows with the supplied reason.\n     *\n     * @since 3.1.0\n     */\n    dismissAll(reason) {\n      this._modalStack.dismissAll(reason);\n    }\n    /**\n     * Indicates if there are currently any open modal windows in the application.\n     *\n     * @since 3.3.0\n     */\n    hasOpenModals() {\n      return this._modalStack.hasOpenModals();\n    }\n    static #_ = this.ɵfac = function NgbModal_Factory(t) {\n      return new (t || NgbModal)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbModal,\n      factory: NgbModal.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbModal;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbModalModule = /*#__PURE__*/(() => {\n  class NgbModalModule {\n    static #_ = this.ɵfac = function NgbModalModule_Factory(t) {\n      return new (t || NgbModalModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbModalModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      providers: [NgbModal]\n    });\n  }\n  return NgbModalModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbNav`](#/components/nav/api#NgbNav) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the navs used in the application.\n *\n * @since 5.2.0\n */\nlet NgbNavConfig = /*#__PURE__*/(() => {\n  class NgbNavConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.destroyOnHide = true;\n      this.orientation = 'horizontal';\n      this.roles = 'tablist';\n      this.keyboard = true;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbNavConfig_Factory(t) {\n      return new (t || NgbNavConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbNavConfig,\n      factory: NgbNavConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbNavConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst isValidNavId = id => isDefined(id) && id !== '';\nlet navCounter = 0;\n/**\n * This directive must be used to wrap content to be displayed in the nav.\n *\n * @since 5.2.0\n */\nlet NgbNavContent = /*#__PURE__*/(() => {\n  class NgbNavContent {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbNavContent_Factory(t) {\n      return new (t || NgbNavContent)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNavContent,\n      selectors: [[\"ng-template\", \"ngbNavContent\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbNavContent;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * This directive applies a specific role on a non-container based ngbNavItem.\n *\n * @since 14.1.0\n */\nlet NgbNavItemRole = /*#__PURE__*/(() => {\n  class NgbNavItemRole {\n    constructor(role) {\n      this.role = role;\n      this.nav = inject(NgbNav);\n    }\n    static #_ = this.ɵfac = function NgbNavItemRole_Factory(t) {\n      return new (t || NgbNavItemRole)(i0.ɵɵinjectAttribute('role'));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNavItemRole,\n      selectors: [[\"\", \"ngbNavItem\", \"\", 5, \"ng-container\"]],\n      hostVars: 1,\n      hostBindings: function NgbNavItemRole_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"role\", ctx.role ? ctx.role : ctx.nav.roles ? \"presentation\" : undefined);\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbNavItemRole;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The directive used to group nav link and related nav content. As well as set nav identifier and some options.\n *\n * @since 5.2.0\n */\nlet NgbNavItem = /*#__PURE__*/(() => {\n  class NgbNavItem {\n    constructor() {\n      this._nav = inject(NgbNav);\n      this._nativeElement = inject(ElementRef).nativeElement;\n      /**\n       * If `true`, the current nav item is disabled and can't be toggled by user.\n       *\n       * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.\n       */\n      this.disabled = false;\n      /**\n       * An event emitted when the fade in transition is finished on the related nav content\n       *\n       * @since 8.0.0\n       */\n      this.shown = new EventEmitter();\n      /**\n       * An event emitted when the fade out transition is finished on the related nav content\n       *\n       * @since 8.0.0\n       */\n      this.hidden = new EventEmitter();\n    }\n    ngAfterContentChecked() {\n      // We are using @ContentChildren instead of @ContentChild as in the Angular version being used\n      // only @ContentChildren allows us to specify the {descendants: false} option.\n      // Without {descendants: false} we are hitting bugs described in:\n      // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240\n      this.contentTpl = this.contentTpls.first;\n    }\n    ngOnInit() {\n      if (!isDefined(this.domId)) {\n        this.domId = `ngb-nav-${navCounter++}`;\n      }\n    }\n    get active() {\n      return this._nav.activeId === this.id;\n    }\n    get id() {\n      return isValidNavId(this._id) ? this._id : this.domId;\n    }\n    get panelDomId() {\n      return `${this.domId}-panel`;\n    }\n    isPanelInDom() {\n      return (isDefined(this.destroyOnHide) ? !this.destroyOnHide : !this._nav.destroyOnHide) || this.active;\n    }\n    /**\n     * @internal\n     */\n    isNgContainer() {\n      return this._nativeElement.nodeType === Node.COMMENT_NODE;\n    }\n    static #_ = this.ɵfac = function NgbNavItem_Factory(t) {\n      return new (t || NgbNavItem)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNavItem,\n      selectors: [[\"\", \"ngbNavItem\", \"\"]],\n      contentQueries: function NgbNavItem_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbNavContent, 4);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentTpls = _t);\n        }\n      },\n      hostVars: 2,\n      hostBindings: function NgbNavItem_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"nav-item\", true);\n        }\n      },\n      inputs: {\n        destroyOnHide: \"destroyOnHide\",\n        disabled: \"disabled\",\n        domId: \"domId\",\n        _id: [i0.ɵɵInputFlags.None, \"ngbNavItem\", \"_id\"]\n      },\n      outputs: {\n        shown: \"shown\",\n        hidden: \"hidden\"\n      },\n      exportAs: [\"ngbNavItem\"],\n      standalone: true\n    });\n  }\n  return NgbNavItem;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A nav directive that helps with implementing tabbed navigation components.\n *\n * @since 5.2.0\n */\nlet NgbNav = /*#__PURE__*/(() => {\n  class NgbNav {\n    constructor(role) {\n      this.role = role;\n      this._config = inject(NgbNavConfig);\n      this._cd = inject(ChangeDetectorRef);\n      this._document = inject(DOCUMENT);\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this.destroyRef = inject(DestroyRef);\n      this._navigatingWithKeyboard = false;\n      /**\n       * The event emitted after the active nav changes\n       * The payload of the event is the newly active nav id\n       *\n       * If you want to prevent nav change, you should use `(navChange)` event\n       */\n      this.activeIdChange = new EventEmitter();\n      /**\n       * If `true`, nav change will be animated.\n       *\n       * @since 8.0.0\n       */\n      this.animation = this._config.animation;\n      /**\n       * If `true`, non-active nav content will be removed from DOM\n       * Otherwise it will just be hidden\n       */\n      this.destroyOnHide = this._config.destroyOnHide;\n      /**\n       * The orientation of navs.\n       *\n       * Using `vertical` will also add the `aria-orientation` attribute\n       */\n      this.orientation = this._config.orientation;\n      /**\n       * Role attribute generating strategy:\n       * - `false` - no role attributes will be generated\n       * - `'tablist'` - 'tablist', 'tab' and 'tabpanel' will be generated (default)\n       */\n      this.roles = this._config.roles;\n      /**\n       * Keyboard support for nav focus/selection using arrow keys.\n       *\n       * * `true` - navs will be focused using keyboard arrow keys\n       * * `false` - no keyboard support\n       * * `'changeWithArrows'` -  nav will be selected using keyboard arrow keys\n       *\n       * See the [list of available keyboard shortcuts](#/components/nav/overview#keyboard-shortcuts).\n       *\n       * @since 6.1.0\n       */\n      this.keyboard = this._config.keyboard;\n      /**\n       * An event emitted when the fade in transition is finished for one of the items.\n       *\n       * Payload of the event is the nav id that was just shown.\n       *\n       * @since 8.0.0\n       */\n      this.shown = new EventEmitter();\n      /**\n       * An event emitted when the fade out transition is finished for one of the items.\n       *\n       * Payload of the event is the nav id that was just hidden.\n       *\n       * @since 8.0.0\n       */\n      this.hidden = new EventEmitter();\n      this.navItemChange$ = new Subject();\n      /**\n       * The nav change event emitted right before the nav change happens on user click.\n       *\n       * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.\n       *\n       * See [`NgbNavChangeEvent`](#/components/nav/api#NgbNavChangeEvent) for payload details.\n       */\n      this.navChange = new EventEmitter();\n    }\n    click(item) {\n      if (!item.disabled) {\n        this._updateActiveId(item.id);\n      }\n    }\n    onFocusout({\n      relatedTarget\n    }) {\n      if (!this._nativeElement.contains(relatedTarget)) {\n        this._navigatingWithKeyboard = false;\n      }\n    }\n    onKeyDown(event) {\n      if (this.roles !== 'tablist' || !this.keyboard) {\n        return;\n      }\n      /* eslint-disable-next-line deprecation/deprecation */\n      const key = event.which;\n      const enabledLinks = this.links.filter(link => !link.navItem.disabled);\n      const {\n        length\n      } = enabledLinks;\n      let position = -1;\n      enabledLinks.forEach((link, index) => {\n        if (link.nativeElement === this._document.activeElement) {\n          position = index;\n        }\n      });\n      if (length) {\n        switch (key) {\n          case Key.ArrowUp:\n          case Key.ArrowLeft:\n            position = (position - 1 + length) % length;\n            break;\n          case Key.ArrowRight:\n          case Key.ArrowDown:\n            position = (position + 1) % length;\n            break;\n          case Key.Home:\n            position = 0;\n            break;\n          case Key.End:\n            position = length - 1;\n            break;\n        }\n        if (this.keyboard === 'changeWithArrows') {\n          this.select(enabledLinks[position].navItem.id);\n        }\n        enabledLinks[position].nativeElement.focus();\n        this._navigatingWithKeyboard = true;\n        event.preventDefault();\n      }\n    }\n    /**\n     * Selects the nav with the given id and shows its associated pane.\n     * Any other nav that was previously selected becomes unselected and its associated pane is hidden.\n     */\n    select(id) {\n      this._updateActiveId(id, false);\n    }\n    ngAfterContentInit() {\n      if (!isDefined(this.activeId)) {\n        const nextId = this.items.first ? this.items.first.id : null;\n        if (isValidNavId(nextId)) {\n          this._updateActiveId(nextId, false);\n          this._cd.detectChanges();\n        }\n      }\n      this.items.changes.pipe(takeUntilDestroyed(this.destroyRef)).subscribe(() => this._notifyItemChanged(this.activeId));\n    }\n    ngOnChanges({\n      activeId\n    }) {\n      if (activeId && !activeId.firstChange) {\n        this._notifyItemChanged(activeId.currentValue);\n      }\n    }\n    _updateActiveId(nextId, emitNavChange = true) {\n      if (this.activeId !== nextId) {\n        let defaultPrevented = false;\n        if (emitNavChange) {\n          this.navChange.emit({\n            activeId: this.activeId,\n            nextId,\n            preventDefault: () => {\n              defaultPrevented = true;\n            }\n          });\n        }\n        if (!defaultPrevented) {\n          this.activeId = nextId;\n          this.activeIdChange.emit(nextId);\n          this._notifyItemChanged(nextId);\n        }\n      }\n    }\n    _notifyItemChanged(nextItemId) {\n      this.navItemChange$.next(this._getItemById(nextItemId));\n    }\n    _getItemById(itemId) {\n      return this.items && this.items.find(item => item.id === itemId) || null;\n    }\n    static #_ = this.ɵfac = function NgbNav_Factory(t) {\n      return new (t || NgbNav)(i0.ɵɵinjectAttribute('role'));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNav,\n      selectors: [[\"\", \"ngbNav\", \"\"]],\n      contentQueries: function NgbNav_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbNavItem, 4);\n          i0.ɵɵcontentQuery(dirIndex, NgbNavLinkBase, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.links = _t);\n        }\n      },\n      hostVars: 6,\n      hostBindings: function NgbNav_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"keydown.arrowLeft\", function NgbNav_keydown_arrowLeft_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          })(\"keydown.arrowRight\", function NgbNav_keydown_arrowRight_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          })(\"keydown.arrowDown\", function NgbNav_keydown_arrowDown_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          })(\"keydown.arrowUp\", function NgbNav_keydown_arrowUp_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          })(\"keydown.Home\", function NgbNav_keydown_Home_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          })(\"keydown.End\", function NgbNav_keydown_End_HostBindingHandler($event) {\n            return ctx.onKeyDown($event);\n          })(\"focusout\", function NgbNav_focusout_HostBindingHandler($event) {\n            return ctx.onFocusout($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-orientation\", ctx.orientation === \"vertical\" && ctx.roles === \"tablist\" ? \"vertical\" : undefined)(\"role\", ctx.role ? ctx.role : ctx.roles ? \"tablist\" : undefined);\n          i0.ɵɵclassProp(\"nav\", true)(\"flex-column\", ctx.orientation === \"vertical\");\n        }\n      },\n      inputs: {\n        activeId: \"activeId\",\n        animation: \"animation\",\n        destroyOnHide: \"destroyOnHide\",\n        orientation: \"orientation\",\n        roles: \"roles\",\n        keyboard: \"keyboard\"\n      },\n      outputs: {\n        activeIdChange: \"activeIdChange\",\n        shown: \"shown\",\n        hidden: \"hidden\",\n        navChange: \"navChange\"\n      },\n      exportAs: [\"ngbNav\"],\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgbNav;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbNavLinkBase = /*#__PURE__*/(() => {\n  class NgbNavLinkBase {\n    constructor(role) {\n      this.role = role;\n      this.navItem = inject(NgbNavItem);\n      this.nav = inject(NgbNav);\n      this.nativeElement = inject(ElementRef).nativeElement;\n    }\n    get tabindex() {\n      if (this.nav.keyboard === false) {\n        return this.navItem.disabled ? -1 : undefined;\n      }\n      if (this.nav._navigatingWithKeyboard) {\n        return -1;\n      }\n      return this.navItem.disabled || !this.navItem.active ? -1 : undefined;\n    }\n    static #_ = this.ɵfac = function NgbNavLinkBase_Factory(t) {\n      return new (t || NgbNavLinkBase)(i0.ɵɵinjectAttribute('role'));\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNavLinkBase,\n      selectors: [[\"\", \"ngbNavLink\", \"\"]],\n      hostVars: 14,\n      hostBindings: function NgbNavLinkBase_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.navItem.domId);\n          i0.ɵɵattribute(\"role\", ctx.role ? ctx.role : ctx.nav.roles ? \"tab\" : undefined)(\"tabindex\", ctx.tabindex)(\"aria-controls\", ctx.navItem.isPanelInDom() ? ctx.navItem.panelDomId : null)(\"aria-selected\", ctx.navItem.active)(\"aria-disabled\", ctx.navItem.disabled);\n          i0.ɵɵclassProp(\"nav-link\", true)(\"nav-item\", ctx.navItem.isNgContainer())(\"active\", ctx.navItem.active)(\"disabled\", ctx.navItem.disabled);\n        }\n      },\n      standalone: true\n    });\n  }\n  return NgbNavLinkBase;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to mark the nav link when used on a button element.\n */\nlet NgbNavLinkButton = /*#__PURE__*/(() => {\n  class NgbNavLinkButton extends NgbNavLinkBase {\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbNavLinkButton_BaseFactory;\n      return function NgbNavLinkButton_Factory(t) {\n        return (ɵNgbNavLinkButton_BaseFactory || (ɵNgbNavLinkButton_BaseFactory = i0.ɵɵgetInheritedFactory(NgbNavLinkButton)))(t || NgbNavLinkButton);\n      };\n    })();\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNavLinkButton,\n      selectors: [[\"button\", \"ngbNavLink\", \"\"]],\n      hostAttrs: [\"type\", \"button\"],\n      hostVars: 1,\n      hostBindings: function NgbNavLinkButton_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function NgbNavLinkButton_click_HostBindingHandler() {\n            return ctx.nav.click(ctx.navItem);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"disabled\", ctx.navItem.disabled);\n        }\n      },\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return NgbNavLinkButton;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to mark the nav link when used on a link element.\n *\n * @since 5.2.0\n */\nlet NgbNavLink = /*#__PURE__*/(() => {\n  class NgbNavLink extends NgbNavLinkBase {\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbNavLink_BaseFactory;\n      return function NgbNavLink_Factory(t) {\n        return (ɵNgbNavLink_BaseFactory || (ɵNgbNavLink_BaseFactory = i0.ɵɵgetInheritedFactory(NgbNavLink)))(t || NgbNavLink);\n      };\n    })();\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNavLink,\n      selectors: [[\"a\", \"ngbNavLink\", \"\"]],\n      hostAttrs: [\"href\", \"\"],\n      hostBindings: function NgbNavLink_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function NgbNavLink_click_HostBindingHandler($event) {\n            ctx.nav.click(ctx.navItem);\n            return $event.preventDefault();\n          });\n        }\n      },\n      standalone: true,\n      features: [i0.ɵɵInheritDefinitionFeature]\n    });\n  }\n  return NgbNavLink;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ngbNavFadeOutTransition = ({\n  classList\n}) => {\n  classList.remove('show');\n  return () => classList.remove('active');\n};\nconst ngbNavFadeInTransition = (element, animation) => {\n  if (animation) {\n    reflow(element);\n  }\n  element.classList.add('show');\n};\nlet NgbNavPane = /*#__PURE__*/(() => {\n  class NgbNavPane {\n    constructor() {\n      this.nativeElement = inject(ElementRef).nativeElement;\n    }\n    static #_ = this.ɵfac = function NgbNavPane_Factory(t) {\n      return new (t || NgbNavPane)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbNavPane,\n      selectors: [[\"\", \"ngbNavPane\", \"\"]],\n      hostAttrs: [1, \"tab-pane\"],\n      hostVars: 5,\n      hostBindings: function NgbNavPane_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.item.panelDomId);\n          i0.ɵɵattribute(\"role\", ctx.role ? ctx.role : ctx.nav.roles ? \"tabpanel\" : undefined)(\"aria-labelledby\", ctx.item.domId);\n          i0.ɵɵclassProp(\"fade\", ctx.nav.animation);\n        }\n      },\n      inputs: {\n        item: \"item\",\n        nav: \"nav\",\n        role: \"role\"\n      },\n      standalone: true\n    });\n  }\n  return NgbNavPane;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The outlet where currently active nav content will be displayed.\n *\n * @since 5.2.0\n */\nlet NgbNavOutlet = /*#__PURE__*/(() => {\n  class NgbNavOutlet {\n    constructor() {\n      this._cd = inject(ChangeDetectorRef);\n      this._ngZone = inject(NgZone);\n      this._activePane = null;\n    }\n    isPanelTransitioning(item) {\n      return this._activePane?.item === item;\n    }\n    ngAfterViewInit() {\n      // initial display\n      this._updateActivePane();\n      // this will be emitted for all 3 types of nav changes: .select(), [activeId] or (click)\n      this.nav.navItemChange$.pipe(takeUntilDestroyed(this.nav.destroyRef), startWith(this._activePane?.item || null), distinctUntilChanged(), skip(1)).subscribe(nextItem => {\n        const options = {\n          animation: this.nav.animation,\n          runningTransition: 'stop'\n        };\n        // next panel we're switching to will only appear in DOM after the change detection is done\n        // and `this._panes` will be updated\n        this._cd.detectChanges();\n        // fading out\n        if (this._activePane) {\n          ngbRunTransition(this._ngZone, this._activePane.nativeElement, ngbNavFadeOutTransition, options).subscribe(() => {\n            const activeItem = this._activePane?.item;\n            this._activePane = this._getPaneForItem(nextItem);\n            // mark for check when transition finishes as outlet or parent containers might be OnPush\n            // without this the panes that have \"faded out\" will stay in DOM\n            this._cd.markForCheck();\n            // fading in\n            if (this._activePane) {\n              // we have to add the '.active' class before running the transition,\n              // because it should be in place before `ngbRunTransition` does `reflow()`\n              this._activePane.nativeElement.classList.add('active');\n              ngbRunTransition(this._ngZone, this._activePane.nativeElement, ngbNavFadeInTransition, options).subscribe(() => {\n                if (nextItem) {\n                  nextItem.shown.emit();\n                  this.nav.shown.emit(nextItem.id);\n                }\n              });\n            }\n            if (activeItem) {\n              activeItem.hidden.emit();\n              this.nav.hidden.emit(activeItem.id);\n            }\n          });\n        } else {\n          this._updateActivePane();\n        }\n      });\n    }\n    _updateActivePane() {\n      this._activePane = this._getActivePane();\n      this._activePane?.nativeElement.classList.add('show');\n      this._activePane?.nativeElement.classList.add('active');\n    }\n    _getPaneForItem(item) {\n      return this._panes && this._panes.find(pane => pane.item === item) || null;\n    }\n    _getActivePane() {\n      return this._panes && this._panes.find(pane => pane.item.active) || null;\n    }\n    static #_ = this.ɵfac = function NgbNavOutlet_Factory(t) {\n      return new (t || NgbNavOutlet)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbNavOutlet,\n      selectors: [[\"\", \"ngbNavOutlet\", \"\"]],\n      viewQuery: function NgbNavOutlet_Query(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵviewQuery(NgbNavPane, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._panes = _t);\n        }\n      },\n      hostVars: 2,\n      hostBindings: function NgbNavOutlet_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"tab-content\", true);\n        }\n      },\n      inputs: {\n        paneRole: \"paneRole\",\n        nav: [i0.ɵɵInputFlags.None, \"ngbNavOutlet\", \"nav\"]\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      attrs: _c8,\n      decls: 2,\n      vars: 0,\n      consts: [[\"ngbNavPane\", \"\", 3, \"item\", \"nav\", \"role\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n      template: function NgbNavOutlet_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵrepeaterCreate(0, NgbNavOutlet_For_1_Template, 1, 1, null, null, i0.ɵɵrepeaterTrackByIdentity);\n        }\n        if (rf & 2) {\n          i0.ɵɵrepeater(ctx.nav.items);\n        }\n      },\n      dependencies: [NgbNavPane, NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbNavOutlet;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NGB_NAV_DIRECTIVES = [NgbNavContent, NgbNav, NgbNavItem, NgbNavItemRole, NgbNavLink, NgbNavLinkButton, NgbNavLinkBase, NgbNavOutlet, NgbNavPane];\nlet NgbNavModule = /*#__PURE__*/(() => {\n  class NgbNavModule {\n    static #_ = this.ɵfac = function NgbNavModule_Factory(t) {\n      return new (t || NgbNavModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbNavModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbNavModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbPagination`](#/components/pagination/api#NgbPagination) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the paginations used in the application.\n */\nlet NgbPaginationConfig = /*#__PURE__*/(() => {\n  class NgbPaginationConfig {\n    constructor() {\n      this.disabled = false;\n      this.boundaryLinks = false;\n      this.directionLinks = true;\n      this.ellipses = true;\n      this.maxSize = 0;\n      this.pageSize = 10;\n      this.rotate = false;\n    }\n    static #_ = this.ɵfac = function NgbPaginationConfig_Factory(t) {\n      return new (t || NgbPaginationConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbPaginationConfig,\n      factory: NgbPaginationConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbPaginationConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive to match the 'ellipsis' link template\n *\n * @since 4.1.0\n */\nlet NgbPaginationEllipsis = /*#__PURE__*/(() => {\n  class NgbPaginationEllipsis {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbPaginationEllipsis_Factory(t) {\n      return new (t || NgbPaginationEllipsis)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPaginationEllipsis,\n      selectors: [[\"ng-template\", \"ngbPaginationEllipsis\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbPaginationEllipsis;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to match the 'first' link template\n *\n * @since 4.1.0\n */\nlet NgbPaginationFirst = /*#__PURE__*/(() => {\n  class NgbPaginationFirst {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbPaginationFirst_Factory(t) {\n      return new (t || NgbPaginationFirst)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPaginationFirst,\n      selectors: [[\"ng-template\", \"ngbPaginationFirst\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbPaginationFirst;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to match the 'last' link template\n *\n * @since 4.1.0\n */\nlet NgbPaginationLast = /*#__PURE__*/(() => {\n  class NgbPaginationLast {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbPaginationLast_Factory(t) {\n      return new (t || NgbPaginationLast)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPaginationLast,\n      selectors: [[\"ng-template\", \"ngbPaginationLast\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbPaginationLast;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to match the 'next' link template\n *\n * @since 4.1.0\n */\nlet NgbPaginationNext = /*#__PURE__*/(() => {\n  class NgbPaginationNext {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbPaginationNext_Factory(t) {\n      return new (t || NgbPaginationNext)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPaginationNext,\n      selectors: [[\"ng-template\", \"ngbPaginationNext\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbPaginationNext;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to match the page 'number' link template\n *\n * @since 4.1.0\n */\nlet NgbPaginationNumber = /*#__PURE__*/(() => {\n  class NgbPaginationNumber {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbPaginationNumber_Factory(t) {\n      return new (t || NgbPaginationNumber)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPaginationNumber,\n      selectors: [[\"ng-template\", \"ngbPaginationNumber\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbPaginationNumber;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to match the 'previous' link template\n *\n * @since 4.1.0\n */\nlet NgbPaginationPrevious = /*#__PURE__*/(() => {\n  class NgbPaginationPrevious {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbPaginationPrevious_Factory(t) {\n      return new (t || NgbPaginationPrevious)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPaginationPrevious,\n      selectors: [[\"ng-template\", \"ngbPaginationPrevious\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbPaginationPrevious;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to match the 'pages' whole content\n *\n * @since 9.1.0\n */\nlet NgbPaginationPages = /*#__PURE__*/(() => {\n  class NgbPaginationPages {\n    constructor() {\n      this.templateRef = inject(TemplateRef);\n    }\n    static #_ = this.ɵfac = function NgbPaginationPages_Factory(t) {\n      return new (t || NgbPaginationPages)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPaginationPages,\n      selectors: [[\"ng-template\", \"ngbPaginationPages\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbPaginationPages;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A component that displays page numbers and allows to customize them in several ways.\n */\nlet NgbPagination = /*#__PURE__*/(() => {\n  class NgbPagination {\n    constructor() {\n      this._config = inject(NgbPaginationConfig);\n      this.pageCount = 0;\n      this.pages = [];\n      /**\n       * If `true`, pagination links will be disabled.\n       */\n      this.disabled = this._config.disabled;\n      /**\n       * If `true`, the \"First\" and \"Last\" page links are shown.\n       */\n      this.boundaryLinks = this._config.boundaryLinks;\n      /**\n       * If `true`, the \"Next\" and \"Previous\" page links are shown.\n       */\n      this.directionLinks = this._config.directionLinks;\n      /**\n       * If `true`, the ellipsis symbols and first/last page numbers will be shown when `maxSize` > number of pages.\n       */\n      this.ellipses = this._config.ellipses;\n      /**\n       * Whether to rotate pages when `maxSize` > number of pages.\n       *\n       * The current page always stays in the middle if `true`.\n       */\n      this.rotate = this._config.rotate;\n      /**\n       *  The maximum number of pages to display.\n       */\n      this.maxSize = this._config.maxSize;\n      /**\n       *  The current page.\n       *\n       *  Page numbers start with `1`.\n       */\n      this.page = 1;\n      /**\n       *  The number of items per page.\n       */\n      this.pageSize = this._config.pageSize;\n      /**\n       *  An event fired when the page is changed. Will fire only if collection size is set and all values are valid.\n       *\n       *  Event payload is the number of the newly selected page.\n       *\n       *  Page numbers start with `1`.\n       */\n      this.pageChange = new EventEmitter(true);\n      /**\n       * The pagination display size.\n       *\n       * Bootstrap currently supports small and large sizes.\n       *\n       * If the passed value is a string (ex. 'custom'), it will just add the `pagination-custom` css class\n       */\n      this.size = this._config.size;\n    }\n    hasPrevious() {\n      return this.page > 1;\n    }\n    hasNext() {\n      return this.page < this.pageCount;\n    }\n    nextDisabled() {\n      return !this.hasNext() || this.disabled;\n    }\n    previousDisabled() {\n      return !this.hasPrevious() || this.disabled;\n    }\n    selectPage(pageNumber) {\n      this._updatePages(pageNumber);\n    }\n    ngOnChanges(changes) {\n      this._updatePages(this.page);\n    }\n    isEllipsis(pageNumber) {\n      return pageNumber === -1;\n    }\n    /**\n     * Appends ellipses and first/last page number to the displayed pages\n     */\n    _applyEllipses(start, end) {\n      if (this.ellipses) {\n        if (start > 0) {\n          // The first page will always be included. If the displayed range\n          // starts after the third page, then add ellipsis. But if the range\n          // starts on the third page, then add the second page instead of\n          // an ellipsis, because the ellipsis would only hide a single page.\n          if (start > 2) {\n            this.pages.unshift(-1);\n          } else if (start === 2) {\n            this.pages.unshift(2);\n          }\n          this.pages.unshift(1);\n        }\n        if (end < this.pageCount) {\n          // The last page will always be included. If the displayed range\n          // ends before the third-last page, then add ellipsis. But if the range\n          // ends on third-last page, then add the second-last page instead of\n          // an ellipsis, because the ellipsis would only hide a single page.\n          if (end < this.pageCount - 2) {\n            this.pages.push(-1);\n          } else if (end === this.pageCount - 2) {\n            this.pages.push(this.pageCount - 1);\n          }\n          this.pages.push(this.pageCount);\n        }\n      }\n    }\n    /**\n     * Rotates page numbers based on maxSize items visible.\n     * Currently selected page stays in the middle:\n     *\n     * Ex. for selected page = 6:\n     * [5,*6*,7] for maxSize = 3\n     * [4,5,*6*,7] for maxSize = 4\n     */\n    _applyRotation() {\n      let start = 0;\n      let end = this.pageCount;\n      let leftOffset = Math.floor(this.maxSize / 2);\n      let rightOffset = this.maxSize % 2 === 0 ? leftOffset - 1 : leftOffset;\n      if (this.page <= leftOffset) {\n        // very beginning, no rotation -> [0..maxSize]\n        end = this.maxSize;\n      } else if (this.pageCount - this.page < leftOffset) {\n        // very end, no rotation -> [len-maxSize..len]\n        start = this.pageCount - this.maxSize;\n      } else {\n        // rotate\n        start = this.page - leftOffset - 1;\n        end = this.page + rightOffset;\n      }\n      return [start, end];\n    }\n    /**\n     * Paginates page numbers based on maxSize items per page.\n     */\n    _applyPagination() {\n      let page = Math.ceil(this.page / this.maxSize) - 1;\n      let start = page * this.maxSize;\n      let end = start + this.maxSize;\n      return [start, end];\n    }\n    _setPageInRange(newPageNo) {\n      const prevPageNo = this.page;\n      this.page = getValueInRange(newPageNo, this.pageCount, 1);\n      if (this.page !== prevPageNo && isNumber(this.collectionSize)) {\n        this.pageChange.emit(this.page);\n      }\n    }\n    _updatePages(newPage) {\n      this.pageCount = Math.ceil(this.collectionSize / this.pageSize);\n      if (!isNumber(this.pageCount)) {\n        this.pageCount = 0;\n      }\n      // fill-in model needed to render pages\n      this.pages.length = 0;\n      for (let i = 1; i <= this.pageCount; i++) {\n        this.pages.push(i);\n      }\n      // set page within 1..max range\n      this._setPageInRange(newPage);\n      // apply maxSize if necessary\n      if (this.maxSize > 0 && this.pageCount > this.maxSize) {\n        let start = 0;\n        let end = this.pageCount;\n        // either paginating or rotating page numbers\n        if (this.rotate) {\n          [start, end] = this._applyRotation();\n        } else {\n          [start, end] = this._applyPagination();\n        }\n        this.pages = this.pages.slice(start, end);\n        // adding ellipses\n        this._applyEllipses(start, end);\n      }\n    }\n    static #_ = this.ɵfac = function NgbPagination_Factory(t) {\n      return new (t || NgbPagination)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbPagination,\n      selectors: [[\"ngb-pagination\"]],\n      contentQueries: function NgbPagination_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbPaginationEllipsis, 5);\n          i0.ɵɵcontentQuery(dirIndex, NgbPaginationFirst, 5);\n          i0.ɵɵcontentQuery(dirIndex, NgbPaginationLast, 5);\n          i0.ɵɵcontentQuery(dirIndex, NgbPaginationNext, 5);\n          i0.ɵɵcontentQuery(dirIndex, NgbPaginationNumber, 5);\n          i0.ɵɵcontentQuery(dirIndex, NgbPaginationPrevious, 5);\n          i0.ɵɵcontentQuery(dirIndex, NgbPaginationPages, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tplEllipsis = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tplFirst = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tplLast = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tplNext = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tplNumber = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tplPrevious = _t.first);\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tplPages = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"navigation\"],\n      inputs: {\n        disabled: \"disabled\",\n        boundaryLinks: \"boundaryLinks\",\n        directionLinks: \"directionLinks\",\n        ellipses: \"ellipses\",\n        rotate: \"rotate\",\n        collectionSize: \"collectionSize\",\n        maxSize: \"maxSize\",\n        page: \"page\",\n        pageSize: \"pageSize\",\n        size: \"size\"\n      },\n      outputs: {\n        pageChange: \"pageChange\"\n      },\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      decls: 20,\n      vars: 12,\n      consts: () => {\n        let i18n_12;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__3 = goog.getMsg(\"\\xAB\\xAB\");\n          i18n_12 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__3;\n        } else {\n          i18n_12 = $localize`:@@ngb.pagination.first:««`;\n        }\n        let i18n_13;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__4 = goog.getMsg(\"\\xAB\");\n          i18n_13 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__4;\n        } else {\n          i18n_13 = $localize`:@@ngb.pagination.previous:«`;\n        }\n        let i18n_14;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__5 = goog.getMsg(\"\\xBB\");\n          i18n_14 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__5;\n        } else {\n          i18n_14 = $localize`:@@ngb.pagination.next:»`;\n        }\n        let i18n_15;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__6 = goog.getMsg(\"\\xBB\\xBB\");\n          i18n_15 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__6;\n        } else {\n          i18n_15 = $localize`:@@ngb.pagination.last:»»`;\n        }\n        let i18n_16;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__7 = goog.getMsg(\"First\");\n          i18n_16 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__7;\n        } else {\n          i18n_16 = $localize`:@@ngb.pagination.first-aria:First`;\n        }\n        let i18n_17;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__8 = goog.getMsg(\"Previous\");\n          i18n_17 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__8;\n        } else {\n          i18n_17 = $localize`:@@ngb.pagination.previous-aria:Previous`;\n        }\n        let i18n_18;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__9 = goog.getMsg(\"Next\");\n          i18n_18 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__9;\n        } else {\n          i18n_18 = $localize`:@@ngb.pagination.next-aria:Next`;\n        }\n        let i18n_19;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__10 = goog.getMsg(\"Last\");\n          i18n_19 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__10;\n        } else {\n          i18n_19 = $localize`:@@ngb.pagination.last-aria:Last`;\n        }\n        return [[\"first\", \"\"], [\"previous\", \"\"], [\"next\", \"\"], [\"last\", \"\"], [\"ellipsis\", \"\"], [\"defaultNumber\", \"\"], [\"defaultPages\", \"\"], [\"class\", \"page-item\", 3, \"disabled\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"aria-hidden\", \"true\"], i18n_12, i18n_13, i18n_14, i18n_15, [1, \"page-item\"], [\"class\", \"page-link\", \"tabindex\", \"-1\", \"aria-disabled\", \"true\"], [\"tabindex\", \"-1\", \"aria-disabled\", \"true\", 1, \"page-link\"], [\"href\", \"\", 1, \"page-link\", 3, \"click\"], [\"class\", \"page-item\", 3, \"active\", \"disabled\"], [\"aria-label\", i18n_16, \"href\", \"\", 1, \"page-link\", 3, \"click\"], [\"aria-label\", i18n_17, \"href\", \"\", 1, \"page-link\", 3, \"click\"], [\"aria-label\", i18n_18, \"href\", \"\", 1, \"page-link\", 3, \"click\"], [\"aria-label\", i18n_19, \"href\", \"\", 1, \"page-link\", 3, \"click\"]];\n      },\n      template: function NgbPagination_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, NgbPagination_ng_template_0_Template, 2, 0, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor)(2, NgbPagination_ng_template_2_Template, 2, 0, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor)(4, NgbPagination_ng_template_4_Template, 2, 0, \"ng-template\", null, 2, i0.ɵɵtemplateRefExtractor)(6, NgbPagination_ng_template_6_Template, 2, 0, \"ng-template\", null, 3, i0.ɵɵtemplateRefExtractor)(8, NgbPagination_ng_template_8_Template, 1, 0, \"ng-template\", null, 4, i0.ɵɵtemplateRefExtractor)(10, NgbPagination_ng_template_10_Template, 1, 1, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor)(12, NgbPagination_ng_template_12_Template, 2, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n          i0.ɵɵelementStart(14, \"ul\");\n          i0.ɵɵtemplate(15, NgbPagination_Conditional_15_Template, 3, 9, \"li\", 7)(16, NgbPagination_Conditional_16_Template, 3, 8, \"li\", 7)(17, NgbPagination_ng_template_17_Template, 0, 0, \"ng-template\", 8)(18, NgbPagination_Conditional_18_Template, 3, 9, \"li\", 7)(19, NgbPagination_Conditional_19_Template, 3, 9, \"li\", 7);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          const _r13 = i0.ɵɵreference(13);\n          i0.ɵɵadvance(14);\n          i0.ɵɵclassMap(\"pagination\" + (ctx.size ? \" pagination-\" + ctx.size : \"\"));\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(15, ctx.boundaryLinks ? 15 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(16, ctx.directionLinks ? 16 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx.tplPages == null ? null : ctx.tplPages.templateRef) || _r13)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction3(8, _c13, ctx.page, ctx.pages, ctx.disabled));\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(18, ctx.directionLinks ? 18 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(19, ctx.boundaryLinks ? 19 : -1);\n        }\n      },\n      dependencies: [NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbPagination;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NGB_PAGINATION_DIRECTIVES = [NgbPagination, NgbPaginationEllipsis, NgbPaginationFirst, NgbPaginationLast, NgbPaginationNext, NgbPaginationNumber, NgbPaginationPrevious, NgbPaginationPages];\nlet NgbPaginationModule = /*#__PURE__*/(() => {\n  class NgbPaginationModule {\n    static #_ = this.ɵfac = function NgbPaginationModule_Factory(t) {\n      return new (t || NgbPaginationModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbPaginationModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbPaginationModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ALIASES = {\n  hover: ['mouseenter', 'mouseleave'],\n  focus: ['focusin', 'focusout']\n};\nfunction parseTriggers(triggers) {\n  const trimmedTriggers = (triggers || '').trim();\n  if (trimmedTriggers.length === 0) {\n    return [];\n  }\n  const parsedTriggers = trimmedTriggers.split(/\\s+/).map(trigger => trigger.split(':')).map(triggerPair => ALIASES[triggerPair[0]] || triggerPair);\n  const manualTriggers = parsedTriggers.filter(triggerPair => triggerPair.includes('manual'));\n  if (manualTriggers.length > 1) {\n    throw `Triggers parse error: only one manual trigger is allowed`;\n  }\n  if (manualTriggers.length === 1 && parsedTriggers.length > 1) {\n    throw `Triggers parse error: manual trigger can't be mixed with other triggers`;\n  }\n  return manualTriggers.length ? [] : parsedTriggers;\n}\nfunction listenToTriggers(element, triggers, isOpenedFn, openFn, closeFn, openDelayMs = 0, closeDelayMs = 0) {\n  const parsedTriggers = parseTriggers(triggers);\n  if (parsedTriggers.length === 0) {\n    return () => {};\n  }\n  const activeOpenTriggers = new Set();\n  const cleanupFns = [];\n  let timeout;\n  function addEventListener(name, listener) {\n    element.addEventListener(name, listener);\n    cleanupFns.push(() => element.removeEventListener(name, listener));\n  }\n  function withDelay(fn, delayMs) {\n    clearTimeout(timeout);\n    if (delayMs > 0) {\n      timeout = setTimeout(fn, delayMs);\n    } else {\n      fn();\n    }\n  }\n  for (const [openTrigger, closeTrigger] of parsedTriggers) {\n    if (!closeTrigger) {\n      addEventListener(openTrigger, () => isOpenedFn() ? withDelay(closeFn, closeDelayMs) : withDelay(openFn, openDelayMs));\n    } else {\n      addEventListener(openTrigger, () => {\n        activeOpenTriggers.add(openTrigger);\n        withDelay(() => activeOpenTriggers.size > 0 && openFn(), openDelayMs);\n      });\n      addEventListener(closeTrigger, () => {\n        activeOpenTriggers.delete(openTrigger);\n        withDelay(() => activeOpenTriggers.size === 0 && closeFn(), closeDelayMs);\n      });\n    }\n  }\n  return () => cleanupFns.forEach(cleanupFn => cleanupFn());\n}\n\n/**\n * A configuration service for the [`NgbPopover`](#/components/popover/api#NgbPopover) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the popovers used in the application.\n */\nlet NgbPopoverConfig = /*#__PURE__*/(() => {\n  class NgbPopoverConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.autoClose = true;\n      this.placement = 'auto';\n      this.popperOptions = options => options;\n      this.triggers = 'click';\n      this.disablePopover = false;\n      this.openDelay = 0;\n      this.closeDelay = 0;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbPopoverConfig_Factory(t) {\n      return new (t || NgbPopoverConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbPopoverConfig,\n      factory: NgbPopoverConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbPopoverConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId$1 = 0;\nlet NgbPopoverWindow = /*#__PURE__*/(() => {\n  class NgbPopoverWindow {\n    isTitleTemplate() {\n      return this.title instanceof TemplateRef;\n    }\n    static #_ = this.ɵfac = function NgbPopoverWindow_Factory(t) {\n      return new (t || NgbPopoverWindow)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbPopoverWindow,\n      selectors: [[\"ngb-popover-window\"]],\n      hostAttrs: [\"role\", \"tooltip\", 2, \"position\", \"absolute\"],\n      hostVars: 5,\n      hostBindings: function NgbPopoverWindow_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.id);\n          i0.ɵɵclassMap(\"popover\" + (ctx.popoverClass ? \" \" + ctx.popoverClass : \"\"));\n          i0.ɵɵclassProp(\"fade\", ctx.animation);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        title: \"title\",\n        id: \"id\",\n        popoverClass: \"popoverClass\",\n        context: \"context\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 4,\n      vars: 1,\n      consts: [[\"data-popper-arrow\", \"\", 1, \"popover-arrow\"], [\"class\", \"popover-header\"], [1, \"popover-body\"], [1, \"popover-header\"], [\"simpleTitle\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n      template: function NgbPopoverWindow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelement(0, \"div\", 0);\n          i0.ɵɵtemplate(1, NgbPopoverWindow_Conditional_1_Template, 4, 2, \"h3\", 1);\n          i0.ɵɵelementStart(2, \"div\", 2);\n          i0.ɵɵprojection(3);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(1, ctx.title ? 1 : -1);\n        }\n      },\n      dependencies: [NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbPopoverWindow;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A lightweight and extensible directive for fancy popover creation.\n */\nlet NgbPopover = /*#__PURE__*/(() => {\n  class NgbPopover {\n    constructor() {\n      this._config = inject(NgbPopoverConfig);\n      /**\n       * If `true`, popover opening and closing will be animated.\n       *\n       * @since 8.0.0\n       */\n      this.animation = this._config.animation;\n      /**\n       * Indicates whether the popover should be closed on `Escape` key and inside/outside clicks:\n       *\n       * * `true` - closes on both outside and inside clicks as well as `Escape` presses\n       * * `false` - disables the autoClose feature (NB: triggers still apply)\n       * * `\"inside\"` - closes on inside clicks as well as Escape presses\n       * * `\"outside\"` - closes on outside clicks (sometimes also achievable through triggers)\n       * as well as `Escape` presses\n       *\n       * @since 3.0.0\n       */\n      this.autoClose = this._config.autoClose;\n      /**\n       * The preferred placement of the popover, among the [possible values](#/guides/positioning#api).\n       *\n       * The default order of preference is `\"auto\"`.\n       *\n       * Please see the [positioning overview](#/positioning) for more details.\n       */\n      this.placement = this._config.placement;\n      /**\n       * Allows to change default Popper options when positioning the popover.\n       * Receives current popper options and returns modified ones.\n       *\n       * @since 13.1.0\n       */\n      this.popperOptions = this._config.popperOptions;\n      /**\n       * Specifies events that should trigger the tooltip.\n       *\n       * Supports a space separated list of event names.\n       * For more details see the [triggers demo](#/components/popover/examples#triggers).\n       */\n      this.triggers = this._config.triggers;\n      /**\n       * A selector specifying the element the popover should be appended to.\n       *\n       * Currently only supports `body`.\n       */\n      this.container = this._config.container;\n      /**\n       * If `true`, popover is disabled and won't be displayed.\n       *\n       * @since 1.1.0\n       */\n      this.disablePopover = this._config.disablePopover;\n      /**\n       * An optional class applied to the popover window element.\n       *\n       * @since 2.2.0\n       */\n      this.popoverClass = this._config.popoverClass;\n      /**\n       * The opening delay in ms. Works only for \"non-manual\" opening triggers defined by the `triggers` input.\n       *\n       * @since 4.1.0\n       */\n      this.openDelay = this._config.openDelay;\n      /**\n       * The closing delay in ms. Works only for \"non-manual\" opening triggers defined by the `triggers` input.\n       *\n       * @since 4.1.0\n       */\n      this.closeDelay = this._config.closeDelay;\n      /**\n       * An event emitted when the popover opening animation has finished. Contains no payload.\n       */\n      this.shown = new EventEmitter();\n      /**\n       * An event emitted when the popover closing animation has finished. Contains no payload.\n       *\n       * At this point popover is not in the DOM anymore.\n       */\n      this.hidden = new EventEmitter();\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this._ngZone = inject(NgZone);\n      this._document = inject(DOCUMENT);\n      this._changeDetector = inject(ChangeDetectorRef);\n      this._ngbPopoverWindowId = `ngb-popover-${nextId$1++}`;\n      this._popupService = new PopupService(NgbPopoverWindow);\n      this._windowRef = null;\n      this._positioning = ngbPositioning();\n    }\n    /**\n     * Opens the popover.\n     *\n     * This is considered to be a \"manual\" triggering.\n     * The `context` is an optional value to be injected into the popover template when it is created.\n     */\n    open(context) {\n      if (!this._windowRef && !this._isDisabled()) {\n        // this type assertion is safe because otherwise _isDisabled would return true\n        const {\n          windowRef,\n          transition$\n        } = this._popupService.open(this.ngbPopover, context ?? this.popoverContext, this.animation);\n        this._windowRef = windowRef;\n        this._windowRef.setInput('animation', this.animation);\n        this._windowRef.setInput('title', this.popoverTitle);\n        this._windowRef.setInput('context', context ?? this.popoverContext);\n        this._windowRef.setInput('popoverClass', this.popoverClass);\n        this._windowRef.setInput('id', this._ngbPopoverWindowId);\n        this._getPositionTargetElement().setAttribute('aria-describedby', this._ngbPopoverWindowId);\n        if (this.container === 'body') {\n          this._document.body.appendChild(this._windowRef.location.nativeElement);\n        }\n        // We need to detect changes, because we don't know where .open() might be called from.\n        // Ex. opening popover from one of lifecycle hooks that run after the CD\n        // (say from ngAfterViewInit) will result in 'ExpressionHasChanged' exception\n        this._windowRef.changeDetectorRef.detectChanges();\n        // We need to mark for check, because popover won't work inside the OnPush component.\n        // Ex. when we use expression like `{{ popover.isOpen() : 'opened' : 'closed' }}`\n        // inside the template of an OnPush component and we change the popover from\n        // open -> closed, the expression in question won't be updated unless we explicitly\n        // mark the parent component to be checked.\n        this._windowRef.changeDetectorRef.markForCheck();\n        // Setting up popper and scheduling updates when zone is stable\n        this._ngZone.runOutsideAngular(() => {\n          this._positioning.createPopper({\n            hostElement: this._getPositionTargetElement(),\n            targetElement: this._windowRef.location.nativeElement,\n            placement: this.placement,\n            appendToBody: this.container === 'body',\n            baseClass: 'bs-popover',\n            updatePopperOptions: options => this.popperOptions(addPopperOffset([0, 8])(options))\n          });\n          Promise.resolve().then(() => {\n            // This update is required for correct arrow placement\n            this._positioning.update();\n            this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positioning.update());\n          });\n        });\n        ngbAutoClose(this._ngZone, this._document, this.autoClose, () => this.close(), this.hidden, [this._windowRef.location.nativeElement]);\n        transition$.subscribe(() => this.shown.emit());\n      }\n    }\n    /**\n     * Closes the popover.\n     *\n     * This is considered to be a \"manual\" triggering of the popover.\n     */\n    close(animation = this.animation) {\n      if (this._windowRef) {\n        this._getPositionTargetElement().removeAttribute('aria-describedby');\n        this._popupService.close(animation).subscribe(() => {\n          this._windowRef = null;\n          this._positioning.destroy();\n          this._zoneSubscription?.unsubscribe();\n          this.hidden.emit();\n          this._changeDetector.markForCheck();\n        });\n      }\n    }\n    /**\n     * Toggles the popover.\n     *\n     * This is considered to be a \"manual\" triggering of the popover.\n     */\n    toggle() {\n      if (this._windowRef) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    /**\n     * Returns `true`, if the popover is currently shown.\n     */\n    isOpen() {\n      return this._windowRef != null;\n    }\n    ngOnInit() {\n      this._unregisterListenersFn = listenToTriggers(this._nativeElement, this.triggers, this.isOpen.bind(this), this.open.bind(this), this.close.bind(this), +this.openDelay, +this.closeDelay);\n    }\n    ngOnChanges({\n      ngbPopover,\n      popoverTitle,\n      disablePopover,\n      popoverClass\n    }) {\n      if (popoverClass && this.isOpen()) {\n        this._windowRef.setInput('popoverClass', popoverClass.currentValue);\n      }\n      // close popover if title and content become empty, or disablePopover set to true\n      if ((ngbPopover || popoverTitle || disablePopover) && this._isDisabled()) {\n        this.close();\n      }\n    }\n    ngOnDestroy() {\n      this.close(false);\n      // This check is needed as it might happen that ngOnDestroy is called before ngOnInit\n      // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199\n      this._unregisterListenersFn?.();\n    }\n    _isDisabled() {\n      return this.disablePopover ? true : !this.ngbPopover && !this.popoverTitle;\n    }\n    _getPositionTargetElement() {\n      return (isString(this.positionTarget) ? this._document.querySelector(this.positionTarget) : this.positionTarget) || this._nativeElement;\n    }\n    static #_ = this.ɵfac = function NgbPopover_Factory(t) {\n      return new (t || NgbPopover)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbPopover,\n      selectors: [[\"\", \"ngbPopover\", \"\"]],\n      inputs: {\n        animation: \"animation\",\n        autoClose: \"autoClose\",\n        ngbPopover: \"ngbPopover\",\n        popoverTitle: \"popoverTitle\",\n        placement: \"placement\",\n        popperOptions: \"popperOptions\",\n        triggers: \"triggers\",\n        positionTarget: \"positionTarget\",\n        container: \"container\",\n        disablePopover: \"disablePopover\",\n        popoverClass: \"popoverClass\",\n        popoverContext: \"popoverContext\",\n        openDelay: \"openDelay\",\n        closeDelay: \"closeDelay\"\n      },\n      outputs: {\n        shown: \"shown\",\n        hidden: \"hidden\"\n      },\n      exportAs: [\"ngbPopover\"],\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgbPopover;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbPopoverModule = /*#__PURE__*/(() => {\n  class NgbPopoverModule {\n    static #_ = this.ɵfac = function NgbPopoverModule_Factory(t) {\n      return new (t || NgbPopoverModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbPopoverModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbPopoverModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbProgressbar`](#/components/progressbar/api#NgbProgressbar) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the progress bars used in the application.\n */\nlet NgbProgressbarConfig = /*#__PURE__*/(() => {\n  class NgbProgressbarConfig {\n    constructor() {\n      this.max = 100;\n      this.animated = false;\n      this.ariaLabel = 'progress bar';\n      this.striped = false;\n      this.showValue = false;\n    }\n    static #_ = this.ɵfac = function NgbProgressbarConfig_Factory(t) {\n      return new (t || NgbProgressbarConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbProgressbarConfig,\n      factory: NgbProgressbarConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbProgressbarConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive that provides feedback on the progress of a workflow or an action.\n */\nlet NgbProgressbar = /*#__PURE__*/(() => {\n  class NgbProgressbar {\n    /**\n     * The maximal value to be displayed in the progress bar.\n     *\n     * Should be a positive number. Will default to 100 otherwise.\n     */\n    set max(max) {\n      this._max = !isNumber(max) || max <= 0 ? 100 : max;\n    }\n    get max() {\n      return this._max;\n    }\n    constructor() {\n      this._config = inject(NgbProgressbarConfig);\n      this.stacked = inject(NgbProgressbarStacked, {\n        optional: true\n      });\n      /**\n       * If `true`, the stripes on the progress bar are animated.\n       *\n       * Takes effect only for browsers supporting CSS3 animations, and if `striped` is `true`.\n       */\n      this.animated = this._config.animated;\n      /**\n       * The accessible progress bar name.\n       *\n       * @since 13.1.0\n       */\n      this.ariaLabel = this._config.ariaLabel;\n      /**\n       * If `true`, the progress bars will be displayed as striped.\n       */\n      this.striped = this._config.striped;\n      /**\n       * If `true`, the current percentage will be shown in the `xx%` format.\n       */\n      this.showValue = this._config.showValue;\n      /**\n       * Optional text variant type of the progress bar.\n       *\n       * Supports types based on Bootstrap background color variants, like:\n       *  `\"success\"`, `\"info\"`, `\"warning\"`, `\"danger\"`, `\"primary\"`, `\"secondary\"`, `\"dark\"` and so on.\n       *\n       * @since 5.2.0\n       */\n      this.textType = this._config.textType;\n      /**\n       * The type of the progress bar.\n       *\n       * Supports types based on Bootstrap background color variants, like:\n       *  `\"success\"`, `\"info\"`, `\"warning\"`, `\"danger\"`, `\"primary\"`, `\"secondary\"`, `\"dark\"` and so on.\n       */\n      this.type = this._config.type;\n      /**\n       * The current value for the progress bar.\n       *\n       * Should be in the `[0, max]` range.\n       */\n      this.value = 0;\n      /**\n       * The height of the progress bar.\n       *\n       * Accepts any valid CSS height values, ex. `\"2rem\"`\n       */\n      this.height = this._config.height;\n      this.max = this._config.max;\n    }\n    getValue() {\n      return getValueInRange(this.value, this.max);\n    }\n    getPercentValue() {\n      return 100 * this.getValue() / this.max;\n    }\n    static #_ = this.ɵfac = function NgbProgressbar_Factory(t) {\n      return new (t || NgbProgressbar)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbProgressbar,\n      selectors: [[\"ngb-progressbar\"]],\n      hostAttrs: [\"role\", \"progressbar\", \"aria-valuemin\", \"0\", 1, \"progress\"],\n      hostVars: 7,\n      hostBindings: function NgbProgressbar_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-valuenow\", ctx.getValue())(\"aria-valuemax\", ctx.max)(\"aria-label\", ctx.ariaLabel);\n          i0.ɵɵstyleProp(\"width\", ctx.stacked ? ctx.getPercentValue() : null, \"%\")(\"height\", ctx.height);\n        }\n      },\n      inputs: {\n        max: \"max\",\n        animated: \"animated\",\n        ariaLabel: \"ariaLabel\",\n        striped: \"striped\",\n        showValue: \"showValue\",\n        textType: \"textType\",\n        type: \"type\",\n        value: \"value\",\n        height: \"height\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 3,\n      vars: 11,\n      consts: () => {\n        let i18n_20;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__11 = goog.getMsg(\"{$interpolation}\", {\n            \"interpolation\": \"\\uFFFD0\\uFFFD\"\n          }, {\n            original_code: {\n              \"interpolation\": \"{{ getValue() / max | percent }}\"\n            }\n          });\n          i18n_20 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__11;\n        } else {\n          i18n_20 = $localize`:@@ngb.progressbar.value:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n        }\n        return [i18n_20];\n      },\n      template: function NgbProgressbar_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelementStart(0, \"div\");\n          i0.ɵɵtemplate(1, NgbProgressbar_Conditional_1_Template, 3, 3, \"span\");\n          i0.ɵɵprojection(2);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵclassMapInterpolate2(\"progress-bar\", ctx.type ? ctx.textType ? \" bg-\" + ctx.type : \" text-bg-\" + ctx.type : \"\", \"\", ctx.textType ? \" text-\" + ctx.textType : \"\", \"\");\n          i0.ɵɵstyleProp(\"width\", !ctx.stacked ? ctx.getPercentValue() : null, \"%\");\n          i0.ɵɵclassProp(\"progress-bar-animated\", ctx.animated)(\"progress-bar-striped\", ctx.striped);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(1, ctx.showValue ? 1 : -1);\n        }\n      },\n      dependencies: [PercentPipe],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbProgressbar;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive that allow to stack progress bars.\n *\n * @since 16.0.0\n */\nlet NgbProgressbarStacked = /*#__PURE__*/(() => {\n  class NgbProgressbarStacked {\n    static #_ = this.ɵfac = function NgbProgressbarStacked_Factory(t) {\n      return new (t || NgbProgressbarStacked)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbProgressbarStacked,\n      selectors: [[\"ngb-progressbar-stacked\"]],\n      hostAttrs: [1, \"progress-stacked\"],\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function NgbProgressbarStacked_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbProgressbarStacked;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbProgressbarModule = /*#__PURE__*/(() => {\n  class NgbProgressbarModule {\n    static #_ = this.ɵfac = function NgbProgressbarModule_Factory(t) {\n      return new (t || NgbProgressbarModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbProgressbarModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbProgressbarModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbRating`](#/components/rating/api#NgbRating) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the ratings used in the application.\n */\nlet NgbRatingConfig = /*#__PURE__*/(() => {\n  class NgbRatingConfig {\n    constructor() {\n      this.max = 10;\n      this.readonly = false;\n      this.resettable = false;\n      this.tabindex = 0;\n    }\n    static #_ = this.ɵfac = function NgbRatingConfig_Factory(t) {\n      return new (t || NgbRatingConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbRatingConfig,\n      factory: NgbRatingConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbRatingConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A directive that helps visualising and interacting with a star rating bar.\n */\nlet NgbRating = /*#__PURE__*/(() => {\n  class NgbRating {\n    constructor() {\n      this.contexts = [];\n      this._config = inject(NgbRatingConfig);\n      this._changeDetectorRef = inject(ChangeDetectorRef);\n      /**\n       * If `true`, the rating can't be changed or focused.\n       */\n      this.disabled = false;\n      /**\n       * The maximal rating that can be given.\n       */\n      this.max = this._config.max;\n      /**\n       * If `true`, the rating can't be changed.\n       */\n      this.readonly = this._config.readonly;\n      /**\n       * If `true`, the rating can be reset to `0` by mouse clicking currently set rating.\n       */\n      this.resettable = this._config.resettable;\n      /**\n       * Allows setting a custom rating tabindex.\n       * If the component is disabled, `tabindex` will still be set to `-1`.\n       *\n       * @since 13.1.0\n       */\n      this.tabindex = this._config.tabindex;\n      /**\n       * An event emitted when the user is hovering over a given rating.\n       *\n       * Event payload equals to the rating being hovered over.\n       */\n      this.hover = new EventEmitter();\n      /**\n       * An event emitted when the user stops hovering over a given rating.\n       *\n       * Event payload equals to the rating of the last item being hovered over.\n       */\n      this.leave = new EventEmitter();\n      /**\n       * An event emitted when the rating is changed.\n       *\n       * Event payload equals to the newly selected rating.\n       */\n      this.rateChange = new EventEmitter(true);\n      this.onChange = _ => {};\n      this.onTouched = () => {};\n    }\n    /**\n     * Allows to provide a function to set a custom aria-valuetext\n     *\n     * @since 14.1.0\n     */\n    ariaValueText(current, max) {\n      return `${current} out of ${max}`;\n    }\n    isInteractive() {\n      return !this.readonly && !this.disabled;\n    }\n    enter(value) {\n      if (this.isInteractive()) {\n        this._updateState(value);\n      }\n      this.hover.emit(value);\n    }\n    handleBlur() {\n      this.onTouched();\n    }\n    handleClick(value) {\n      if (this.isInteractive()) {\n        this.update(this.resettable && this.rate === value ? 0 : value);\n      }\n    }\n    handleKeyDown(event) {\n      /* eslint-disable-next-line deprecation/deprecation */\n      switch (event.which) {\n        case Key.ArrowDown:\n        case Key.ArrowLeft:\n          this.update(this.rate - 1);\n          break;\n        case Key.ArrowUp:\n        case Key.ArrowRight:\n          this.update(this.rate + 1);\n          break;\n        case Key.Home:\n          this.update(0);\n          break;\n        case Key.End:\n          this.update(this.max);\n          break;\n        default:\n          return;\n      }\n      // note 'return' in default case\n      event.preventDefault();\n    }\n    ngOnChanges(changes) {\n      if (changes['rate']) {\n        this.update(this.rate);\n      }\n      if (changes['max']) {\n        this._updateMax();\n      }\n    }\n    ngOnInit() {\n      this._setupContexts();\n      this._updateState(this.rate);\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    reset() {\n      this.leave.emit(this.nextRate);\n      this._updateState(this.rate);\n    }\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    update(value, internalChange = true) {\n      const newRate = getValueInRange(value, this.max, 0);\n      if (this.isInteractive() && this.rate !== newRate) {\n        this.rate = newRate;\n        this.rateChange.emit(this.rate);\n      }\n      if (internalChange) {\n        this.onChange(this.rate);\n        this.onTouched();\n      }\n      this._updateState(this.rate);\n    }\n    writeValue(value) {\n      this.update(value, false);\n      this._changeDetectorRef.markForCheck();\n    }\n    _updateState(nextValue) {\n      this.nextRate = nextValue;\n      this.contexts.forEach((context, index) => context.fill = Math.round(getValueInRange(nextValue - index, 1, 0) * 100));\n    }\n    _updateMax() {\n      if (this.max > 0) {\n        this._setupContexts();\n        this.update(this.rate);\n      }\n    }\n    _setupContexts() {\n      this.contexts = Array.from({\n        length: this.max\n      }, (v, k) => ({\n        fill: 0,\n        index: k\n      }));\n    }\n    static #_ = this.ɵfac = function NgbRating_Factory(t) {\n      return new (t || NgbRating)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbRating,\n      selectors: [[\"ngb-rating\"]],\n      contentQueries: function NgbRating_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, TemplateRef, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.starTemplateFromContent = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"slider\", \"aria-valuemin\", \"0\", 1, \"d-inline-flex\"],\n      hostVars: 6,\n      hostBindings: function NgbRating_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"blur\", function NgbRating_blur_HostBindingHandler() {\n            return ctx.handleBlur();\n          })(\"keydown\", function NgbRating_keydown_HostBindingHandler($event) {\n            return ctx.handleKeyDown($event);\n          })(\"mouseleave\", function NgbRating_mouseleave_HostBindingHandler() {\n            return ctx.reset();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"tabindex\", ctx.disabled ? -1 : ctx.tabindex);\n          i0.ɵɵattribute(\"aria-valuemax\", ctx.max)(\"aria-valuenow\", ctx.nextRate)(\"aria-valuetext\", ctx.ariaValueText(ctx.nextRate, ctx.max))(\"aria-readonly\", ctx.readonly && !ctx.disabled ? true : null)(\"aria-disabled\", ctx.disabled ? true : null);\n        }\n      },\n      inputs: {\n        disabled: \"disabled\",\n        max: \"max\",\n        rate: \"rate\",\n        readonly: \"readonly\",\n        resettable: \"resettable\",\n        starTemplate: \"starTemplate\",\n        tabindex: \"tabindex\",\n        ariaValueText: \"ariaValueText\"\n      },\n      outputs: {\n        hover: \"hover\",\n        leave: \"leave\",\n        rateChange: \"rateChange\"\n      },\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => NgbRating),\n        multi: true\n      }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      decls: 4,\n      vars: 0,\n      consts: [[\"t\", \"\"], [1, \"visually-hidden\"], [3, \"mouseenter\", \"click\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"]],\n      template: function NgbRating_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, NgbRating_ng_template_0_Template, 1, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n          i0.ɵɵrepeaterCreate(2, NgbRating_For_3_Template, 4, 5, null, null, i0.ɵɵrepeaterTrackByIdentity);\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(2);\n          i0.ɵɵrepeater(ctx.contexts);\n        }\n      },\n      dependencies: [NgTemplateOutlet],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbRating;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbRatingModule = /*#__PURE__*/(() => {\n  class NgbRatingModule {\n    static #_ = this.ɵfac = function NgbRatingModule_Factory(t) {\n      return new (t || NgbRatingModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbRatingModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbRatingModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction toFragmentElement(container, id) {\n  if (!container || id == null) {\n    return null;\n  }\n  return isString(id) ? container.querySelector(`#${CSS.escape(id)}`) : id;\n}\nfunction getOrderedFragments(container, fragments) {\n  const selector = [...fragments].map(({\n    id\n  }) => `#${CSS.escape(id)}`).join(',');\n  return Array.from(container.querySelectorAll(selector));\n}\nconst defaultProcessChanges = (state, changeActive, ctx) => {\n  const {\n    rootElement,\n    fragments,\n    scrollSpy,\n    options,\n    entries\n  } = state;\n  const orderedFragments = getOrderedFragments(rootElement, fragments);\n  if (!ctx.initialized) {\n    ctx.initialized = true;\n    ctx.gapFragment = null;\n    ctx.visibleFragments = new Set();\n    // special case when one of the fragments was pre-selected\n    const preSelectedFragment = toFragmentElement(rootElement, options?.initialFragment);\n    if (preSelectedFragment) {\n      scrollSpy.scrollTo(preSelectedFragment);\n      return;\n    }\n  }\n  for (const entry of entries) {\n    const {\n      isIntersecting,\n      target: fragment\n    } = entry;\n    // 1. an entry became visible\n    if (isIntersecting) {\n      // if we were in-between two elements, we have to clear it up\n      if (ctx.gapFragment) {\n        ctx.visibleFragments.delete(ctx.gapFragment);\n        ctx.gapFragment = null;\n      }\n      ctx.visibleFragments.add(fragment);\n    }\n    // 2. an entry became invisible\n    else {\n      ctx.visibleFragments.delete(fragment);\n      // nothing is visible anymore, but something just was actually\n      if (ctx.visibleFragments.size === 0 && scrollSpy.active !== '') {\n        // 2.1 scrolling down - keeping the same element\n        if (entry.boundingClientRect.top < entry.rootBounds.top) {\n          ctx.gapFragment = fragment;\n          ctx.visibleFragments.add(ctx.gapFragment);\n        }\n        // 2.2 scrolling up - getting the previous element\n        else {\n          // scrolling up and no more fragments above\n          if (fragment === orderedFragments[0]) {\n            ctx.gapFragment = null;\n            ctx.visibleFragments.clear();\n            changeActive('');\n            return;\n          }\n          // getting previous fragment\n          else {\n            const fragmentIndex = orderedFragments.indexOf(fragment);\n            ctx.gapFragment = orderedFragments[fragmentIndex - 1] || null;\n            if (ctx.gapFragment) {\n              ctx.visibleFragments.add(ctx.gapFragment);\n            }\n          }\n        }\n      }\n    }\n  }\n  // getting the first visible element in the DOM order of the fragments\n  for (const fragment of orderedFragments) {\n    if (ctx.visibleFragments.has(fragment)) {\n      changeActive(fragment.id);\n      break;\n    }\n  }\n};\n\n/**\n * A configuration service for the [`NgbScrollSpyService`](#/components/scrollspy/api#NgbScrollSpyService).\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all scrollspies used in the application.\n *\n * @since 15.1.0\n */\nlet NgbScrollSpyConfig = /*#__PURE__*/(() => {\n  class NgbScrollSpyConfig {\n    constructor() {\n      this.scrollBehavior = 'smooth';\n      this.processChanges = defaultProcessChanges;\n    }\n    static #_ = this.ɵfac = function NgbScrollSpyConfig_Factory(t) {\n      return new (t || NgbScrollSpyConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbScrollSpyConfig,\n      factory: NgbScrollSpyConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbScrollSpyConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MATCH_THRESHOLD = 3;\n/**\n * A scrollspy service that allows tracking of elements scrolling in and out of view.\n *\n * It can be instantiated manually, or automatically by the `ngbScrollSpy` directive.\n *\n * @since 15.1.0\n */\nlet NgbScrollSpyService = /*#__PURE__*/(() => {\n  class NgbScrollSpyService {\n    constructor() {\n      this._observer = null;\n      this._containerElement = null;\n      this._fragments = new Set();\n      this._preRegisteredFragments = new Set();\n      this._active$ = new Subject();\n      this._distinctActive$ = this._active$.pipe(distinctUntilChanged());\n      this._active = '';\n      this._config = inject(NgbScrollSpyConfig);\n      this._document = inject(DOCUMENT);\n      this._platformId = inject(PLATFORM_ID);\n      this._scrollBehavior = this._config.scrollBehavior;\n      this._diChangeDetectorRef = inject(ChangeDetectorRef, {\n        optional: true\n      });\n      this._changeDetectorRef = this._diChangeDetectorRef;\n      this._zone = inject(NgZone);\n      this._distinctActive$.pipe(takeUntilDestroyed()).subscribe(active => {\n        this._active = active;\n        this._changeDetectorRef?.markForCheck();\n      });\n    }\n    /**\n     * Getter for the currently active fragment id. Returns empty string if none.\n     */\n    get active() {\n      return this._active;\n    }\n    /**\n     * An observable emitting the currently active fragment. Emits empty string if none.\n     */\n    get active$() {\n      return this._distinctActive$;\n    }\n    /**\n     * Starts the scrollspy service and observes specified fragments.\n     *\n     * You can specify a list of options to pass, like the root element, initial fragment, scroll behavior, etc.\n     * See the [`NgbScrollSpyOptions`](#/components/scrollspy/api#NgbScrollSpyOptions) interface for more details.\n     */\n    start(options) {\n      if (isPlatformBrowser(this._platformId)) {\n        this._cleanup();\n        const {\n          root,\n          rootMargin,\n          scrollBehavior,\n          threshold,\n          fragments,\n          changeDetectorRef,\n          processChanges\n        } = {\n          ...options\n        };\n        this._containerElement = root ?? this._document.documentElement;\n        this._changeDetectorRef = changeDetectorRef ?? this._diChangeDetectorRef;\n        this._scrollBehavior = scrollBehavior ?? this._config.scrollBehavior;\n        const processChangesFn = processChanges ?? this._config.processChanges;\n        const context = {};\n        this._observer = new IntersectionObserver(entries => processChangesFn({\n          entries,\n          rootElement: this._containerElement,\n          fragments: this._fragments,\n          scrollSpy: this,\n          options: {\n            ...options\n          }\n        }, active => this._active$.next(active), context), {\n          root: root ?? this._document,\n          ...(rootMargin && {\n            rootMargin\n          }),\n          ...(threshold && {\n            threshold\n          })\n        });\n        // merging fragments added before starting and the ones passed as options\n        for (const element of [...this._preRegisteredFragments, ...(fragments ?? [])]) {\n          this.observe(element);\n        }\n        this._preRegisteredFragments.clear();\n      }\n    }\n    /**\n     * Stops the service and unobserves all fragments.\n     */\n    stop() {\n      this._cleanup();\n      this._active$.next('');\n    }\n    /**\n     * Scrolls to a fragment, it must be known to the service and contained in the root element.\n     * An id or an element reference can be passed.\n     *\n     * [`NgbScrollToOptions`](#/components/scrollspy/api#NgbScrollToOptions) can be passed.\n     */\n    scrollTo(fragment, options) {\n      const {\n        behavior\n      } = {\n        behavior: this._scrollBehavior,\n        ...options\n      };\n      if (this._containerElement) {\n        const fragmentElement = toFragmentElement(this._containerElement, fragment);\n        if (fragmentElement) {\n          const heightPx = fragmentElement.offsetTop - this._containerElement.offsetTop;\n          this._containerElement.scrollTo({\n            top: heightPx,\n            behavior\n          });\n          let lastOffset = this._containerElement.scrollTop;\n          let matchCounter = 0;\n          // we should update the active section only after scrolling is finished\n          // and there is no clean way to do it at the moment\n          const containerElement = this._containerElement;\n          this._zone.runOutsideAngular(() => {\n            const updateActiveWhenScrollingIsFinished = () => {\n              const sameOffsetAsLastTime = lastOffset === containerElement.scrollTop;\n              if (sameOffsetAsLastTime) {\n                matchCounter++;\n              } else {\n                matchCounter = 0;\n              }\n              if (!sameOffsetAsLastTime || sameOffsetAsLastTime && matchCounter < MATCH_THRESHOLD) {\n                lastOffset = containerElement.scrollTop;\n                requestAnimationFrame(updateActiveWhenScrollingIsFinished);\n              } else {\n                this._zone.run(() => this._active$.next(fragmentElement.id));\n              }\n            };\n            requestAnimationFrame(updateActiveWhenScrollingIsFinished);\n          });\n        }\n      }\n    }\n    /**\n     * Adds a fragment to observe. It must be contained in the root element.\n     * An id or an element reference can be passed.\n     */\n    observe(fragment) {\n      if (!this._observer) {\n        this._preRegisteredFragments.add(fragment);\n        return;\n      }\n      const fragmentElement = toFragmentElement(this._containerElement, fragment);\n      if (fragmentElement && !this._fragments.has(fragmentElement)) {\n        this._fragments.add(fragmentElement);\n        this._observer.observe(fragmentElement);\n      }\n    }\n    /**\n     * Unobserves a fragment.\n     * An id or an element reference can be passed.\n     */\n    unobserve(fragment) {\n      if (!this._observer) {\n        this._preRegisteredFragments.delete(fragment);\n        return;\n      }\n      const fragmentElement = toFragmentElement(this._containerElement, fragment);\n      if (fragmentElement) {\n        this._fragments.delete(fragmentElement);\n        // we're removing and re-adding all current fragments to recompute active one\n        this._observer.disconnect();\n        for (const fragment of this._fragments) {\n          this._observer.observe(fragment);\n        }\n      }\n    }\n    ngOnDestroy() {\n      this._cleanup();\n    }\n    _cleanup() {\n      this._fragments.clear();\n      this._observer?.disconnect();\n      this._changeDetectorRef = this._diChangeDetectorRef;\n      this._scrollBehavior = this._config.scrollBehavior;\n      this._observer = null;\n      this._containerElement = null;\n    }\n    static #_ = this.ɵfac = function NgbScrollSpyService_Factory(t) {\n      return new (t || NgbScrollSpyService)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbScrollSpyService,\n      factory: NgbScrollSpyService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbScrollSpyService;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A helper directive to that links menu items and fragments together.\n *\n * It will automatically add the `.active` class to the menu item when the associated fragment becomes active.\n *\n * @since 15.1.0\n */\nlet NgbScrollSpyItem = /*#__PURE__*/(() => {\n  class NgbScrollSpyItem {\n    constructor() {\n      this._changeDetector = inject(ChangeDetectorRef);\n      this._scrollSpyMenu = inject(NgbScrollSpyMenu, {\n        optional: true\n      });\n      this._scrollSpyAPI = this._scrollSpyMenu ?? inject(NgbScrollSpyService);\n      this._destroyRef = inject(DestroyRef);\n      this._isActive = false;\n    }\n    /**\n     * References the scroll spy directive, the id of the associated fragment and the parent menu item.\n     *\n     * Can be used like:\n     *  - `ngbScrollSpyItem=\"fragmentId\"`\n     *  - `[ngbScrollSpyItem]=\"scrollSpy\" fragment=\"fragmentId\"\n     *  - `[ngbScrollSpyItem]=\"[scrollSpy, 'fragmentId']\"` parent=\"parentId\"`\n     *  - `[ngbScrollSpyItem]=\"[scrollSpy, 'fragmentId', 'parentId']\"`\n     *\n     *  As well as together with `[fragment]` and `[parent]` inputs.\n     */\n    set data(data) {\n      if (Array.isArray(data)) {\n        this._scrollSpyAPI = data[0];\n        this.fragment = data[1];\n        this.parent ??= data[2];\n      } else if (data instanceof NgbScrollSpy) {\n        this._scrollSpyAPI = data;\n      } else if (isString(data)) {\n        this.fragment = data;\n      }\n    }\n    ngOnInit() {\n      // if it is not a part of a bigger menu, it should handle activation itself\n      if (!this._scrollSpyMenu) {\n        this._scrollSpyAPI.active$.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(active => {\n          if (active === this.fragment) {\n            this._activate();\n          } else {\n            this._deactivate();\n          }\n          this._changeDetector.markForCheck();\n        });\n      }\n    }\n    /**\n     * @internal\n     */\n    _activate() {\n      this._isActive = true;\n      if (this._scrollSpyMenu) {\n        this._scrollSpyMenu.getItem(this.parent ?? '')?._activate();\n      }\n    }\n    /**\n     * @internal\n     */\n    _deactivate() {\n      this._isActive = false;\n      if (this._scrollSpyMenu) {\n        this._scrollSpyMenu.getItem(this.parent ?? '')?._deactivate();\n      }\n    }\n    /**\n     * Returns `true`, if the associated fragment is active.\n     */\n    isActive() {\n      return this._isActive;\n    }\n    /**\n     * Scrolls to the associated fragment.\n     */\n    scrollTo(options) {\n      this._scrollSpyAPI.scrollTo(this.fragment, options);\n    }\n    static #_ = this.ɵfac = function NgbScrollSpyItem_Factory(t) {\n      return new (t || NgbScrollSpyItem)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpyItem,\n      selectors: [[\"\", \"ngbScrollSpyItem\", \"\"]],\n      hostVars: 2,\n      hostBindings: function NgbScrollSpyItem_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"click\", function NgbScrollSpyItem_click_HostBindingHandler() {\n            return ctx.scrollTo();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"active\", ctx.isActive());\n        }\n      },\n      inputs: {\n        data: [i0.ɵɵInputFlags.None, \"ngbScrollSpyItem\", \"data\"],\n        fragment: \"fragment\",\n        parent: \"parent\"\n      },\n      exportAs: [\"ngbScrollSpyItem\"],\n      standalone: true\n    });\n  }\n  return NgbScrollSpyItem;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * An optional scroll spy menu directive to build hierarchical menus\n * and simplify the [`NgbScrollSpyItem`](#/components/scrollspy/api#NgbScrollSpyItem) configuration.\n *\n * @since 15.1.0\n */\nlet NgbScrollSpyMenu = /*#__PURE__*/(() => {\n  class NgbScrollSpyMenu {\n    constructor() {\n      this._scrollSpyRef = inject(NgbScrollSpyService);\n      this._destroyRef = inject(DestroyRef);\n      this._map = new Map();\n      this._lastActiveItem = null;\n    }\n    set scrollSpy(scrollSpy) {\n      this._scrollSpyRef = scrollSpy;\n    }\n    get active() {\n      return this._scrollSpyRef.active;\n    }\n    get active$() {\n      return this._scrollSpyRef.active$;\n    }\n    scrollTo(fragment, options) {\n      this._scrollSpyRef.scrollTo(fragment, options);\n    }\n    getItem(id) {\n      return this._map.get(id);\n    }\n    ngAfterViewInit() {\n      this._items.changes.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(() => this._rebuildMap());\n      this._rebuildMap();\n      this._scrollSpyRef.active$.pipe(takeUntilDestroyed(this._destroyRef)).subscribe(activeId => {\n        this._lastActiveItem?._deactivate();\n        const item = this._map.get(activeId);\n        if (item) {\n          item._activate();\n          this._lastActiveItem = item;\n        }\n      });\n    }\n    _rebuildMap() {\n      this._map.clear();\n      for (let item of this._items) {\n        this._map.set(item.fragment, item);\n      }\n    }\n    static #_ = this.ɵfac = function NgbScrollSpyMenu_Factory(t) {\n      return new (t || NgbScrollSpyMenu)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpyMenu,\n      selectors: [[\"\", \"ngbScrollSpyMenu\", \"\"]],\n      contentQueries: function NgbScrollSpyMenu_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbScrollSpyItem, 5);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._items = _t);\n        }\n      },\n      inputs: {\n        scrollSpy: [i0.ɵɵInputFlags.None, \"ngbScrollSpyMenu\", \"scrollSpy\"]\n      },\n      standalone: true\n    });\n  }\n  return NgbScrollSpyMenu;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to put on a scrollable container.\n *\n * It will instantiate a [`NgbScrollSpyService`](#/components/scrollspy/api#NgbScrollSpyService).\n *\n * @since 15.1.0\n */\nlet NgbScrollSpy = /*#__PURE__*/(() => {\n  class NgbScrollSpy {\n    constructor() {\n      this._initialFragment = null;\n      this._service = inject(NgbScrollSpyService);\n      this._nativeElement = inject(ElementRef).nativeElement;\n      /**\n       * An event raised when the active section changes.\n       *\n       * Payload is the id of the new active section, empty string if none.\n       */\n      this.activeChange = this._service.active$;\n    }\n    set active(fragment) {\n      this._initialFragment = fragment;\n      this.scrollTo(fragment);\n    }\n    /**\n     * Getter/setter for the currently active fragment id.\n     */\n    get active() {\n      return this._service.active;\n    }\n    /**\n     * Returns an observable that emits currently active section id.\n     */\n    get active$() {\n      return this._service.active$;\n    }\n    ngAfterViewInit() {\n      this._service.start({\n        processChanges: this.processChanges,\n        root: this._nativeElement,\n        rootMargin: this.rootMargin,\n        threshold: this.threshold,\n        ...(this._initialFragment && {\n          initialFragment: this._initialFragment\n        })\n      });\n    }\n    /**\n     * @internal\n     */\n    _registerFragment(fragment) {\n      this._service.observe(fragment.id);\n    }\n    /**\n     * @internal\n     */\n    _unregisterFragment(fragment) {\n      this._service.unobserve(fragment.id);\n    }\n    /**\n     * Scrolls to a fragment that is identified by the `ngbScrollSpyFragment` directive.\n     * An id or an element reference can be passed.\n     */\n    scrollTo(fragment, options) {\n      this._service.scrollTo(fragment, {\n        ...(this.scrollBehavior && {\n          behavior: this.scrollBehavior\n        }),\n        ...options\n      });\n    }\n    static #_ = this.ɵfac = function NgbScrollSpy_Factory(t) {\n      return new (t || NgbScrollSpy)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpy,\n      selectors: [[\"\", \"ngbScrollSpy\", \"\"]],\n      hostAttrs: [\"tabindex\", \"0\", 2, \"overflow-y\", \"auto\"],\n      inputs: {\n        processChanges: \"processChanges\",\n        rootMargin: \"rootMargin\",\n        scrollBehavior: \"scrollBehavior\",\n        threshold: \"threshold\",\n        active: \"active\"\n      },\n      outputs: {\n        activeChange: \"activeChange\"\n      },\n      exportAs: [\"ngbScrollSpy\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([NgbScrollSpyService])]\n    });\n  }\n  return NgbScrollSpy;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A directive to put on a fragment observed inside a scrollspy container.\n *\n * @since 15.1.0\n */\nlet NgbScrollSpyFragment = /*#__PURE__*/(() => {\n  class NgbScrollSpyFragment {\n    constructor() {\n      this._destroyRef = inject(DestroyRef);\n      this._scrollSpy = inject(NgbScrollSpy);\n    }\n    ngAfterViewInit() {\n      this._scrollSpy._registerFragment(this);\n      this._destroyRef.onDestroy(() => this._scrollSpy._unregisterFragment(this));\n    }\n    static #_ = this.ɵfac = function NgbScrollSpyFragment_Factory(t) {\n      return new (t || NgbScrollSpyFragment)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbScrollSpyFragment,\n      selectors: [[\"\", \"ngbScrollSpyFragment\", \"\"]],\n      hostVars: 1,\n      hostBindings: function NgbScrollSpyFragment_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.id);\n        }\n      },\n      inputs: {\n        id: [i0.ɵɵInputFlags.None, \"ngbScrollSpyFragment\", \"id\"]\n      },\n      standalone: true\n    });\n  }\n  return NgbScrollSpyFragment;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbScrollSpyModule = /*#__PURE__*/(() => {\n  class NgbScrollSpyModule {\n    static #_ = this.ɵfac = function NgbScrollSpyModule_Factory(t) {\n      return new (t || NgbScrollSpyModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbScrollSpyModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbScrollSpyModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass NgbTime {\n  constructor(hour, minute, second) {\n    this.hour = toInteger(hour);\n    this.minute = toInteger(minute);\n    this.second = toInteger(second);\n  }\n  changeHour(step = 1) {\n    this.updateHour((isNaN(this.hour) ? 0 : this.hour) + step);\n  }\n  updateHour(hour) {\n    if (isNumber(hour)) {\n      this.hour = (hour < 0 ? 24 + hour : hour) % 24;\n    } else {\n      this.hour = NaN;\n    }\n  }\n  changeMinute(step = 1) {\n    this.updateMinute((isNaN(this.minute) ? 0 : this.minute) + step);\n  }\n  updateMinute(minute) {\n    if (isNumber(minute)) {\n      this.minute = minute % 60 < 0 ? 60 + minute % 60 : minute % 60;\n      this.changeHour(Math.floor(minute / 60));\n    } else {\n      this.minute = NaN;\n    }\n  }\n  changeSecond(step = 1) {\n    this.updateSecond((isNaN(this.second) ? 0 : this.second) + step);\n  }\n  updateSecond(second) {\n    if (isNumber(second)) {\n      this.second = second < 0 ? 60 + second % 60 : second % 60;\n      this.changeMinute(Math.floor(second / 60));\n    } else {\n      this.second = NaN;\n    }\n  }\n  isValid(checkSecs = true) {\n    return isNumber(this.hour) && isNumber(this.minute) && (checkSecs ? isNumber(this.second) : true);\n  }\n  toString() {\n    return `${this.hour || 0}:${this.minute || 0}:${this.second || 0}`;\n  }\n}\n\n/**\n * A configuration service for the [`NgbTimepicker`](#/components/timepicker/api#NgbTimepicker) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the timepickers used in the application.\n */\nlet NgbTimepickerConfig = /*#__PURE__*/(() => {\n  class NgbTimepickerConfig {\n    constructor() {\n      this.meridian = false;\n      this.spinners = true;\n      this.seconds = false;\n      this.hourStep = 1;\n      this.minuteStep = 1;\n      this.secondStep = 1;\n      this.disabled = false;\n      this.readonlyInputs = false;\n      this.size = 'medium';\n    }\n    static #_ = this.ɵfac = function NgbTimepickerConfig_Factory(t) {\n      return new (t || NgbTimepickerConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbTimepickerConfig,\n      factory: NgbTimepickerConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbTimepickerConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction NGB_DATEPICKER_TIME_ADAPTER_FACTORY() {\n  return new NgbTimeStructAdapter();\n}\n/**\n * An abstract service that does the conversion between the internal timepicker `NgbTimeStruct` model and\n * any provided user time model `T`, ex. a string, a native date, etc.\n *\n * The adapter is used **only** for conversion when binding timepicker to a form control,\n * ex. `[(ngModel)]=\"userTimeModel\"`. Here `userTimeModel` can be of any type.\n *\n * The default timepicker implementation assumes we use `NgbTimeStruct` as a user model.\n *\n * See the [custom time adapter demo](#/components/timepicker/examples#adapter) for an example.\n *\n * @since 2.2.0\n */\nlet NgbTimeAdapter = /*#__PURE__*/(() => {\n  class NgbTimeAdapter {\n    static #_ = this.ɵfac = function NgbTimeAdapter_Factory(t) {\n      return new (t || NgbTimeAdapter)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbTimeAdapter,\n      factory: () => NGB_DATEPICKER_TIME_ADAPTER_FACTORY(),\n      providedIn: 'root'\n    });\n  }\n  return NgbTimeAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbTimeStructAdapter = /*#__PURE__*/(() => {\n  class NgbTimeStructAdapter extends NgbTimeAdapter {\n    /**\n     * Converts a NgbTimeStruct value into NgbTimeStruct value\n     */\n    fromModel(time) {\n      return time && isInteger(time.hour) && isInteger(time.minute) ? {\n        hour: time.hour,\n        minute: time.minute,\n        second: isInteger(time.second) ? time.second : null\n      } : null;\n    }\n    /**\n     * Converts a NgbTimeStruct value into NgbTimeStruct value\n     */\n    toModel(time) {\n      return time && isInteger(time.hour) && isInteger(time.minute) ? {\n        hour: time.hour,\n        minute: time.minute,\n        second: isInteger(time.second) ? time.second : null\n      } : null;\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbTimeStructAdapter_BaseFactory;\n      return function NgbTimeStructAdapter_Factory(t) {\n        return (ɵNgbTimeStructAdapter_BaseFactory || (ɵNgbTimeStructAdapter_BaseFactory = i0.ɵɵgetInheritedFactory(NgbTimeStructAdapter)))(t || NgbTimeStructAdapter);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbTimeStructAdapter,\n      factory: NgbTimeStructAdapter.ɵfac\n    });\n  }\n  return NgbTimeStructAdapter;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Type of the service supplying day periods (for example, 'AM' and 'PM') to NgbTimepicker component.\n * The default implementation of this service honors the Angular locale, and uses the registered locale data,\n * as explained in the Angular i18n guide.\n */\nlet NgbTimepickerI18n = /*#__PURE__*/(() => {\n  class NgbTimepickerI18n {\n    static #_ = this.ɵfac = function NgbTimepickerI18n_Factory(t) {\n      return new (t || NgbTimepickerI18n)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbTimepickerI18n,\n      factory: () => (() => new NgbTimepickerI18nDefault())(),\n      providedIn: 'root'\n    });\n  }\n  return NgbTimepickerI18n;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbTimepickerI18nDefault = /*#__PURE__*/(() => {\n  class NgbTimepickerI18nDefault extends NgbTimepickerI18n {\n    constructor() {\n      super(...arguments);\n      this._periods = getLocaleDayPeriods(inject(LOCALE_ID), FormStyle.Standalone, TranslationWidth.Narrow);\n    }\n    getMorningPeriod() {\n      return this._periods[0];\n    }\n    getAfternoonPeriod() {\n      return this._periods[1];\n    }\n    static #_ = this.ɵfac = /* @__PURE__ */(() => {\n      let ɵNgbTimepickerI18nDefault_BaseFactory;\n      return function NgbTimepickerI18nDefault_Factory(t) {\n        return (ɵNgbTimepickerI18nDefault_BaseFactory || (ɵNgbTimepickerI18nDefault_BaseFactory = i0.ɵɵgetInheritedFactory(NgbTimepickerI18nDefault)))(t || NgbTimepickerI18nDefault);\n      };\n    })();\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbTimepickerI18nDefault,\n      factory: NgbTimepickerI18nDefault.ɵfac\n    });\n  }\n  return NgbTimepickerI18nDefault;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FILTER_REGEX = /[^0-9]/g;\n/**\n * A directive that helps with wth picking hours, minutes and seconds.\n */\nlet NgbTimepicker = /*#__PURE__*/(() => {\n  class NgbTimepicker {\n    /**\n     * The number of hours to add/subtract when clicking hour spinners.\n     */\n    set hourStep(step) {\n      this._hourStep = isInteger(step) ? step : this._config.hourStep;\n    }\n    get hourStep() {\n      return this._hourStep;\n    }\n    /**\n     * The number of minutes to add/subtract when clicking minute spinners.\n     */\n    set minuteStep(step) {\n      this._minuteStep = isInteger(step) ? step : this._config.minuteStep;\n    }\n    get minuteStep() {\n      return this._minuteStep;\n    }\n    /**\n     * The number of seconds to add/subtract when clicking second spinners.\n     */\n    set secondStep(step) {\n      this._secondStep = isInteger(step) ? step : this._config.secondStep;\n    }\n    get secondStep() {\n      return this._secondStep;\n    }\n    constructor(_config, _ngbTimeAdapter, _cd, i18n) {\n      this._config = _config;\n      this._ngbTimeAdapter = _ngbTimeAdapter;\n      this._cd = _cd;\n      this.i18n = i18n;\n      this.onChange = _ => {};\n      this.onTouched = () => {};\n      this.meridian = _config.meridian;\n      this.spinners = _config.spinners;\n      this.seconds = _config.seconds;\n      this.hourStep = _config.hourStep;\n      this.minuteStep = _config.minuteStep;\n      this.secondStep = _config.secondStep;\n      this.disabled = _config.disabled;\n      this.readonlyInputs = _config.readonlyInputs;\n      this.size = _config.size;\n    }\n    writeValue(value) {\n      const structValue = this._ngbTimeAdapter.fromModel(value);\n      this.model = structValue ? new NgbTime(structValue.hour, structValue.minute, structValue.second) : new NgbTime();\n      if (!this.seconds && (!structValue || !isNumber(structValue.second))) {\n        this.model.second = 0;\n      }\n      this._cd.markForCheck();\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /**\n     * Increments the hours by the given step.\n     */\n    changeHour(step) {\n      this.model?.changeHour(step);\n      this.propagateModelChange();\n    }\n    /**\n     * Increments the minutes by the given step.\n     */\n    changeMinute(step) {\n      this.model?.changeMinute(step);\n      this.propagateModelChange();\n    }\n    /**\n     * Increments the seconds by the given step.\n     */\n    changeSecond(step) {\n      this.model?.changeSecond(step);\n      this.propagateModelChange();\n    }\n    /**\n     * Update hours with the new value.\n     */\n    updateHour(newVal) {\n      const isPM = this.model ? this.model.hour >= 12 : false;\n      const enteredHour = toInteger(newVal);\n      if (this.meridian && (isPM && enteredHour < 12 || !isPM && enteredHour === 12)) {\n        this.model?.updateHour(enteredHour + 12);\n      } else {\n        this.model?.updateHour(enteredHour);\n      }\n      this.propagateModelChange();\n    }\n    /**\n     * Update minutes with the new value.\n     */\n    updateMinute(newVal) {\n      this.model?.updateMinute(toInteger(newVal));\n      this.propagateModelChange();\n    }\n    /**\n     * Update seconds with the new value.\n     */\n    updateSecond(newVal) {\n      this.model?.updateSecond(toInteger(newVal));\n      this.propagateModelChange();\n    }\n    toggleMeridian() {\n      if (this.meridian) {\n        this.changeHour(12);\n      }\n    }\n    formatInput(input) {\n      input.value = input.value.replace(FILTER_REGEX, '');\n    }\n    formatHour(value) {\n      if (isNumber(value)) {\n        if (this.meridian) {\n          return padNumber(value % 12 === 0 ? 12 : value % 12);\n        } else {\n          return padNumber(value % 24);\n        }\n      } else {\n        return padNumber(NaN);\n      }\n    }\n    formatMinSec(value) {\n      return padNumber(isNumber(value) ? value : NaN);\n    }\n    handleBlur() {\n      this.onTouched();\n    }\n    get isSmallSize() {\n      return this.size === 'small';\n    }\n    get isLargeSize() {\n      return this.size === 'large';\n    }\n    ngOnChanges(changes) {\n      if (changes['seconds'] && !this.seconds && this.model && !isNumber(this.model.second)) {\n        this.model.second = 0;\n        this.propagateModelChange(false);\n      }\n    }\n    propagateModelChange(touched = true) {\n      if (touched) {\n        this.onTouched();\n      }\n      if (this.model?.isValid(this.seconds)) {\n        this.onChange(this._ngbTimeAdapter.toModel({\n          hour: this.model.hour,\n          minute: this.model.minute,\n          second: this.model.second\n        }));\n      } else {\n        this.onChange(this._ngbTimeAdapter.toModel(null));\n      }\n    }\n    static #_ = this.ɵfac = function NgbTimepicker_Factory(t) {\n      return new (t || NgbTimepicker)(i0.ɵɵdirectiveInject(NgbTimepickerConfig), i0.ɵɵdirectiveInject(NgbTimeAdapter), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(NgbTimepickerI18n));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbTimepicker,\n      selectors: [[\"ngb-timepicker\"]],\n      inputs: {\n        meridian: \"meridian\",\n        spinners: \"spinners\",\n        seconds: \"seconds\",\n        hourStep: \"hourStep\",\n        minuteStep: \"minuteStep\",\n        secondStep: \"secondStep\",\n        readonlyInputs: \"readonlyInputs\",\n        size: \"size\"\n      },\n      exportAs: [\"ngbTimepicker\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => NgbTimepicker),\n        multi: true\n      }]), i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      decls: 14,\n      vars: 23,\n      consts: () => {\n        let i18n_21;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_9 = goog.getMsg(\"HH\");\n          i18n_21 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_9;\n        } else {\n          i18n_21 = $localize`:@@ngb.timepicker.HH:HH`;\n        }\n        let i18n_22;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_10 = goog.getMsg(\"Hours\");\n          i18n_22 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_10;\n        } else {\n          i18n_22 = $localize`:@@ngb.timepicker.hours:Hours`;\n        }\n        let i18n_23;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_11 = goog.getMsg(\"MM\");\n          i18n_23 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_11;\n        } else {\n          i18n_23 = $localize`:@@ngb.timepicker.MM:MM`;\n        }\n        let i18n_24;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_12 = goog.getMsg(\"Minutes\");\n          i18n_24 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS_12;\n        } else {\n          i18n_24 = $localize`:@@ngb.timepicker.minutes:Minutes`;\n        }\n        let i18n_25;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__12 = goog.getMsg(\"Increment hours\");\n          i18n_25 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__12;\n        } else {\n          i18n_25 = $localize`:@@ngb.timepicker.increment-hours:Increment hours`;\n        }\n        let i18n_26;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__13 = goog.getMsg(\"Decrement hours\");\n          i18n_26 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__13;\n        } else {\n          i18n_26 = $localize`:@@ngb.timepicker.decrement-hours:Decrement hours`;\n        }\n        let i18n_27;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__14 = goog.getMsg(\"Increment minutes\");\n          i18n_27 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__14;\n        } else {\n          i18n_27 = $localize`:@@ngb.timepicker.increment-minutes:Increment minutes`;\n        }\n        let i18n_28;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__15 = goog.getMsg(\"Decrement minutes\");\n          i18n_28 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__15;\n        } else {\n          i18n_28 = $localize`:@@ngb.timepicker.decrement-minutes:Decrement minutes`;\n        }\n        let i18n_29;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__16 = goog.getMsg(\"SS\");\n          i18n_29 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__16;\n        } else {\n          i18n_29 = $localize`:@@ngb.timepicker.SS:SS`;\n        }\n        let i18n_30;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__17 = goog.getMsg(\"Seconds\");\n          i18n_30 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__17;\n        } else {\n          i18n_30 = $localize`:@@ngb.timepicker.seconds:Seconds`;\n        }\n        let i18n_31;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS___0 = goog.getMsg(\"Increment seconds\");\n          i18n_31 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS___0;\n        } else {\n          i18n_31 = $localize`:@@ngb.timepicker.increment-seconds:Increment seconds`;\n        }\n        let i18n_32;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS___1 = goog.getMsg(\"Decrement seconds\");\n          i18n_32 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS___1;\n        } else {\n          i18n_32 = $localize`:@@ngb.timepicker.decrement-seconds:Decrement seconds`;\n        }\n        let i18n_33;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS___2 = goog.getMsg(\"{$interpolation}\", {\n            \"interpolation\": \"\\uFFFD0\\uFFFD\"\n          }, {\n            original_code: {\n              \"interpolation\": \"{{ i18n.getAfternoonPeriod() }}\"\n            }\n          });\n          i18n_33 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS___2;\n        } else {\n          i18n_33 = $localize`:@@ngb.timepicker.PM:${\"\\uFFFD0\\uFFFD\"}:INTERPOLATION:`;\n        }\n        return [[3, \"disabled\"], [1, \"ngb-tp\"], [1, \"ngb-tp-input-container\", \"ngb-tp-hour\"], [\"tabindex\", \"-1\", \"type\", \"button\", \"class\", \"btn btn-link\", 3, \"btn-sm\", \"btn-lg\", \"disabled\"], [\"type\", \"text\", \"maxlength\", \"2\", \"inputmode\", \"numeric\", \"placeholder\", i18n_21, \"aria-label\", i18n_22, 1, \"ngb-tp-input\", \"form-control\", 3, \"value\", \"readOnly\", \"disabled\", \"change\", \"blur\", \"input\", \"keydown.ArrowUp\", \"keydown.ArrowDown\"], [1, \"ngb-tp-spacer\"], [1, \"ngb-tp-input-container\", \"ngb-tp-minute\"], [\"type\", \"text\", \"maxlength\", \"2\", \"inputmode\", \"numeric\", \"placeholder\", i18n_23, \"aria-label\", i18n_24, 1, \"ngb-tp-input\", \"form-control\", 3, \"value\", \"readOnly\", \"disabled\", \"change\", \"blur\", \"input\", \"keydown.ArrowUp\", \"keydown.ArrowDown\"], [\"tabindex\", \"-1\", \"type\", \"button\", 1, \"btn\", \"btn-link\", 3, \"disabled\", \"click\"], [1, \"chevron\", \"ngb-tp-chevron\"], [1, \"visually-hidden\"], i18n_25, [1, \"chevron\", \"ngb-tp-chevron\", \"bottom\"], i18n_26, i18n_27, i18n_28, [1, \"ngb-tp-input-container\", \"ngb-tp-second\"], [\"type\", \"text\", \"maxlength\", \"2\", \"inputmode\", \"numeric\", \"placeholder\", i18n_29, \"aria-label\", i18n_30, 1, \"ngb-tp-input\", \"form-control\", 3, \"value\", \"readOnly\", \"disabled\", \"change\", \"blur\", \"input\", \"keydown.ArrowUp\", \"keydown.ArrowDown\"], i18n_31, i18n_32, [1, \"ngb-tp-meridian\"], [\"type\", \"button\", 1, \"btn\", \"btn-outline-primary\", 3, \"disabled\", \"click\"], i18n_33];\n      },\n      template: function NgbTimepicker_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵelementStart(0, \"fieldset\", 0)(1, \"div\", 1)(2, \"div\", 2);\n          i0.ɵɵtemplate(3, NgbTimepicker_Conditional_3_Template, 4, 7, \"button\", 3);\n          i0.ɵɵelementStart(4, \"input\", 4);\n          i0.ɵɵlistener(\"change\", function NgbTimepicker_Template_input_change_4_listener($event) {\n            return ctx.updateHour($event.target.value);\n          })(\"blur\", function NgbTimepicker_Template_input_blur_4_listener() {\n            return ctx.handleBlur();\n          })(\"input\", function NgbTimepicker_Template_input_input_4_listener($event) {\n            return ctx.formatInput($event.target);\n          })(\"keydown.ArrowUp\", function NgbTimepicker_Template_input_keydown_ArrowUp_4_listener($event) {\n            ctx.changeHour(ctx.hourStep);\n            return $event.preventDefault();\n          })(\"keydown.ArrowDown\", function NgbTimepicker_Template_input_keydown_ArrowDown_4_listener($event) {\n            ctx.changeHour(-ctx.hourStep);\n            return $event.preventDefault();\n          });\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(5, NgbTimepicker_Conditional_5_Template, 4, 7, \"button\", 3);\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(6, \"div\", 5);\n          i0.ɵɵtext(7, \":\");\n          i0.ɵɵelementEnd();\n          i0.ɵɵelementStart(8, \"div\", 6);\n          i0.ɵɵtemplate(9, NgbTimepicker_Conditional_9_Template, 4, 7, \"button\", 3);\n          i0.ɵɵelementStart(10, \"input\", 7);\n          i0.ɵɵlistener(\"change\", function NgbTimepicker_Template_input_change_10_listener($event) {\n            return ctx.updateMinute($event.target.value);\n          })(\"blur\", function NgbTimepicker_Template_input_blur_10_listener() {\n            return ctx.handleBlur();\n          })(\"input\", function NgbTimepicker_Template_input_input_10_listener($event) {\n            return ctx.formatInput($event.target);\n          })(\"keydown.ArrowUp\", function NgbTimepicker_Template_input_keydown_ArrowUp_10_listener($event) {\n            ctx.changeMinute(ctx.minuteStep);\n            return $event.preventDefault();\n          })(\"keydown.ArrowDown\", function NgbTimepicker_Template_input_keydown_ArrowDown_10_listener($event) {\n            ctx.changeMinute(-ctx.minuteStep);\n            return $event.preventDefault();\n          });\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(11, NgbTimepicker_Conditional_11_Template, 4, 7, \"button\", 3);\n          i0.ɵɵelementEnd();\n          i0.ɵɵtemplate(12, NgbTimepicker_Conditional_12_Template, 6, 9)(13, NgbTimepicker_Conditional_13_Template, 5, 8);\n          i0.ɵɵelementEnd()();\n        }\n        if (rf & 2) {\n          i0.ɵɵclassProp(\"disabled\", ctx.disabled);\n          i0.ɵɵproperty(\"disabled\", ctx.disabled);\n          i0.ɵɵadvance(3);\n          i0.ɵɵconditional(3, ctx.spinners ? 3 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵclassProp(\"form-control-sm\", ctx.isSmallSize)(\"form-control-lg\", ctx.isLargeSize);\n          i0.ɵɵproperty(\"value\", ctx.formatHour(ctx.model == null ? null : ctx.model.hour))(\"readOnly\", ctx.readonlyInputs)(\"disabled\", ctx.disabled);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(5, ctx.spinners ? 5 : -1);\n          i0.ɵɵadvance(4);\n          i0.ɵɵconditional(9, ctx.spinners ? 9 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵclassProp(\"form-control-sm\", ctx.isSmallSize)(\"form-control-lg\", ctx.isLargeSize);\n          i0.ɵɵproperty(\"value\", ctx.formatMinSec(ctx.model == null ? null : ctx.model.minute))(\"readOnly\", ctx.readonlyInputs)(\"disabled\", ctx.disabled);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(11, ctx.spinners ? 11 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(12, ctx.seconds ? 12 : -1);\n          i0.ɵɵadvance();\n          i0.ɵɵconditional(13, ctx.meridian ? 13 : -1);\n        }\n      },\n      styles: [\"ngb-timepicker{font-size:1rem}.ngb-tp{display:flex;align-items:center}.ngb-tp-input-container{width:4em}.ngb-tp-chevron:before{border-style:solid;border-width:.29em .29em 0 0;content:\\\"\\\";display:inline-block;height:.69em;left:.05em;position:relative;top:.15em;transform:rotate(-45deg);vertical-align:middle;width:.69em}.ngb-tp-chevron.bottom:before{top:-.3em;transform:rotate(135deg)}.ngb-tp-input{text-align:center}.ngb-tp-hour,.ngb-tp-minute,.ngb-tp-second,.ngb-tp-meridian{display:flex;flex-direction:column;align-items:center;justify-content:space-around}.ngb-tp-spacer{width:1em;text-align:center}\\n\"],\n      encapsulation: 2\n    });\n  }\n  return NgbTimepicker;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbTimepickerModule = /*#__PURE__*/(() => {\n  class NgbTimepickerModule {\n    static #_ = this.ɵfac = function NgbTimepickerModule_Factory(t) {\n      return new (t || NgbTimepickerModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbTimepickerModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbTimepickerModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Configuration service for the NgbToast component. You can inject this service, typically in your root component,\n * and customize the values of its properties in order to provide default values for all the toasts used in the\n * application.\n *\n * @since 5.0.0\n */\nlet NgbToastConfig = /*#__PURE__*/(() => {\n  class NgbToastConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.autohide = true;\n      this.delay = 5000;\n      this.ariaLive = 'polite';\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbToastConfig_Factory(t) {\n      return new (t || NgbToastConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbToastConfig,\n      factory: NgbToastConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbToastConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ngbToastFadeInTransition = (element, animation) => {\n  const {\n    classList\n  } = element;\n  if (animation) {\n    classList.add('fade');\n  } else {\n    classList.add('show');\n    return;\n  }\n  reflow(element);\n  classList.add('show', 'showing');\n  return () => {\n    classList.remove('showing');\n  };\n};\nconst ngbToastFadeOutTransition = ({\n  classList\n}) => {\n  classList.add('showing');\n  return () => {\n    classList.remove('show', 'showing');\n  };\n};\n\n/**\n * This directive allows the usage of HTML markup or other directives\n * inside of the toast's header.\n *\n * @since 5.0.0\n */\nlet NgbToastHeader = /*#__PURE__*/(() => {\n  class NgbToastHeader {\n    static #_ = this.ɵfac = function NgbToastHeader_Factory(t) {\n      return new (t || NgbToastHeader)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbToastHeader,\n      selectors: [[\"\", \"ngbToastHeader\", \"\"]],\n      standalone: true\n    });\n  }\n  return NgbToastHeader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Toasts provide feedback messages as notifications to the user.\n * Goal is to mimic the push notifications available both on mobile and desktop operating systems.\n *\n * @since 5.0.0\n */\nlet NgbToast = /*#__PURE__*/(() => {\n  class NgbToast {\n    constructor(ariaLive) {\n      this.ariaLive = ariaLive;\n      this._config = inject(NgbToastConfig);\n      this._zone = inject(NgZone);\n      this._element = inject(ElementRef);\n      /**\n       * If `true`, toast opening and closing will be animated.\n       *\n       * Animation is triggered only when the `.hide()` or `.show()` functions are called\n       *\n       * @since 8.0.0\n       */\n      this.animation = this._config.animation;\n      /**\n       * Delay after which the toast will hide (ms).\n       * default: `500` (ms) (inherited from NgbToastConfig)\n       */\n      this.delay = this._config.delay;\n      /**\n       * Auto hide the toast after a delay in ms.\n       * default: `true` (inherited from NgbToastConfig)\n       */\n      this.autohide = this._config.autohide;\n      /**\n       * A template like `<ng-template ngbToastHeader></ng-template>` can be\n       * used in the projected content to allow markup usage.\n       */\n      this.contentHeaderTpl = null;\n      /**\n       * An event fired after the animation triggered by calling `.show()` method has finished.\n       *\n       * @since 8.0.0\n       */\n      this.shown = new EventEmitter();\n      /**\n       * An event fired after the animation triggered by calling `.hide()` method has finished.\n       *\n       * It can only occur in 2 different scenarios:\n       * - `autohide` timeout fires\n       * - user clicks on a closing cross\n       *\n       * Additionally this output is purely informative. The toast won't be removed from DOM automatically, it's up\n       * to the user to take care of that.\n       *\n       * @since 8.0.0\n       */\n      this.hidden = new EventEmitter();\n      this.ariaLive ??= this._config.ariaLive;\n    }\n    ngAfterContentInit() {\n      this._zone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        this._init();\n        this.show();\n      });\n    }\n    ngOnChanges(changes) {\n      if ('autohide' in changes) {\n        this._clearTimeout();\n        this._init();\n      }\n    }\n    /**\n     * Triggers toast closing programmatically.\n     *\n     * The returned observable will emit and be completed once the closing transition has finished.\n     * If the animations are turned off this happens synchronously.\n     *\n     * Alternatively you could listen or subscribe to the `(hidden)` output\n     *\n     * @since 8.0.0\n     */\n    hide() {\n      this._clearTimeout();\n      const transition = ngbRunTransition(this._zone, this._element.nativeElement, ngbToastFadeOutTransition, {\n        animation: this.animation,\n        runningTransition: 'stop'\n      });\n      transition.subscribe(() => {\n        this.hidden.emit();\n      });\n      return transition;\n    }\n    /**\n     * Triggers toast opening programmatically.\n     *\n     * The returned observable will emit and be completed once the opening transition has finished.\n     * If the animations are turned off this happens synchronously.\n     *\n     * Alternatively you could listen or subscribe to the `(shown)` output\n     *\n     * @since 8.0.0\n     */\n    show() {\n      const transition = ngbRunTransition(this._zone, this._element.nativeElement, ngbToastFadeInTransition, {\n        animation: this.animation,\n        runningTransition: 'continue'\n      });\n      transition.subscribe(() => {\n        this.shown.emit();\n      });\n      return transition;\n    }\n    _init() {\n      if (this.autohide && !this._timeoutID) {\n        this._timeoutID = setTimeout(() => this.hide(), this.delay);\n      }\n    }\n    _clearTimeout() {\n      if (this._timeoutID) {\n        clearTimeout(this._timeoutID);\n        this._timeoutID = null;\n      }\n    }\n    static #_ = this.ɵfac = function NgbToast_Factory(t) {\n      return new (t || NgbToast)(i0.ɵɵinjectAttribute('aria-live'));\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbToast,\n      selectors: [[\"ngb-toast\"]],\n      contentQueries: function NgbToast_ContentQueries(rf, ctx, dirIndex) {\n        if (rf & 1) {\n          i0.ɵɵcontentQuery(dirIndex, NgbToastHeader, 7, TemplateRef);\n        }\n        if (rf & 2) {\n          let _t;\n          i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentHeaderTpl = _t.first);\n        }\n      },\n      hostAttrs: [\"role\", \"alert\", \"aria-atomic\", \"true\", 1, \"toast\"],\n      hostVars: 3,\n      hostBindings: function NgbToast_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-live\", ctx.ariaLive);\n          i0.ɵɵclassProp(\"fade\", ctx.animation);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        delay: \"delay\",\n        autohide: \"autohide\",\n        header: \"header\"\n      },\n      outputs: {\n        shown: \"shown\",\n        hidden: \"hidden\"\n      },\n      exportAs: [\"ngbToast\"],\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 5,\n      vars: 1,\n      consts: () => {\n        let i18n_34;\n        if (typeof ngI18nClosureMode !== \"undefined\" && ngI18nClosureMode) {\n          /**\n           * @suppress {msgDescriptions}\n           */\n          const MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__18 = goog.getMsg(\"Close\");\n          i18n_34 = MSG__HOME_GAETAN_WORKSPACE_SPOUD_TOEGGELOMAT_FRONTEND_NODE_MODULES__NG_BOOTSTRAP_NG_BOOTSTRAP_FESM2022_NG_BOOTSTRAP_MJS__18;\n        } else {\n          i18n_34 = $localize`:@@ngb.toast.close-aria:Close`;\n        }\n        return [[\"headerTpl\", \"\"], [\"class\", \"toast-header\"], [1, \"toast-body\"], [1, \"me-auto\"], [1, \"toast-header\"], [3, \"ngTemplateOutlet\"], [\"type\", \"button\", \"aria-label\", i18n_34, 1, \"btn-close\", 3, \"click\"]];\n      },\n      template: function NgbToast_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵtemplate(0, NgbToast_ng_template_0_Template, 2, 1, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor)(2, NgbToast_Conditional_2_Template, 3, 1, \"div\", 1);\n          i0.ɵɵelementStart(3, \"div\", 2);\n          i0.ɵɵprojection(4);\n          i0.ɵɵelementEnd();\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(2);\n          i0.ɵɵconditional(2, ctx.contentHeaderTpl || ctx.header ? 2 : -1);\n        }\n      },\n      dependencies: [NgTemplateOutlet],\n      styles: [\"ngb-toast{display:block}ngb-toast .toast-header .close{margin-left:auto;margin-bottom:.25rem}\\n\"],\n      encapsulation: 2\n    });\n  }\n  return NgbToast;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbToastModule = /*#__PURE__*/(() => {\n  class NgbToastModule {\n    static #_ = this.ɵfac = function NgbToastModule_Factory(t) {\n      return new (t || NgbToastModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbToastModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbToastModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbTooltip`](#/components/tooltip/api#NgbTooltip) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the tooltips used in the application.\n */\nlet NgbTooltipConfig = /*#__PURE__*/(() => {\n  class NgbTooltipConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.autoClose = true;\n      this.placement = 'auto';\n      this.popperOptions = options => options;\n      this.triggers = 'hover focus';\n      this.disableTooltip = false;\n      this.openDelay = 0;\n      this.closeDelay = 0;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbTooltipConfig_Factory(t) {\n      return new (t || NgbTooltipConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbTooltipConfig,\n      factory: NgbTooltipConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbTooltipConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextId = 0;\nlet NgbTooltipWindow = /*#__PURE__*/(() => {\n  class NgbTooltipWindow {\n    static #_ = this.ɵfac = function NgbTooltipWindow_Factory(t) {\n      return new (t || NgbTooltipWindow)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbTooltipWindow,\n      selectors: [[\"ngb-tooltip-window\"]],\n      hostAttrs: [\"role\", \"tooltip\"],\n      hostVars: 5,\n      hostBindings: function NgbTooltipWindow_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.id);\n          i0.ɵɵclassMap(\"tooltip\" + (ctx.tooltipClass ? \" \" + ctx.tooltipClass : \"\"));\n          i0.ɵɵclassProp(\"fade\", ctx.animation);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        id: \"id\",\n        tooltipClass: \"tooltipClass\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 3,\n      vars: 0,\n      consts: [[\"data-popper-arrow\", \"\", 1, \"tooltip-arrow\"], [1, \"tooltip-inner\"]],\n      template: function NgbTooltipWindow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵelement(0, \"div\", 0);\n          i0.ɵɵelementStart(1, \"div\", 1);\n          i0.ɵɵprojection(2);\n          i0.ɵɵelementEnd();\n        }\n      },\n      styles: [\"ngb-tooltip-window{pointer-events:none;position:absolute}ngb-tooltip-window .tooltip-inner{pointer-events:auto}ngb-tooltip-window.bs-tooltip-top,ngb-tooltip-window.bs-tooltip-bottom{padding-left:0;padding-right:0}ngb-tooltip-window.bs-tooltip-start,ngb-tooltip-window.bs-tooltip-end{padding-top:0;padding-bottom:0}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbTooltipWindow;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * A lightweight and extensible directive for fancy tooltip creation.\n */\nlet NgbTooltip = /*#__PURE__*/(() => {\n  class NgbTooltip {\n    constructor() {\n      this._config = inject(NgbTooltipConfig);\n      /**\n       * If `true`, tooltip opening and closing will be animated.\n       *\n       * @since 8.0.0\n       */\n      this.animation = this._config.animation;\n      /**\n       * Indicates whether the tooltip should be closed on `Escape` key and inside/outside clicks:\n       *\n       * * `true` - closes on both outside and inside clicks as well as `Escape` presses\n       * * `false` - disables the autoClose feature (NB: triggers still apply)\n       * * `\"inside\"` - closes on inside clicks as well as Escape presses\n       * * `\"outside\"` - closes on outside clicks (sometimes also achievable through triggers)\n       * as well as `Escape` presses\n       *\n       * @since 3.0.0\n       */\n      this.autoClose = this._config.autoClose;\n      /**\n       * The preferred placement of the tooltip, among the [possible values](#/guides/positioning#api).\n       *\n       * The default order of preference is `\"auto\"`.\n       *\n       * Please see the [positioning overview](#/positioning) for more details.\n       */\n      this.placement = this._config.placement;\n      /**\n       * Allows to change default Popper options when positioning the tooltip.\n       * Receives current popper options and returns modified ones.\n       *\n       * @since 13.1.0\n       */\n      this.popperOptions = this._config.popperOptions;\n      /**\n       * Specifies events that should trigger the tooltip.\n       *\n       * Supports a space separated list of event names.\n       * For more details see the [triggers demo](#/components/tooltip/examples#triggers).\n       */\n      this.triggers = this._config.triggers;\n      /**\n       * A selector specifying the element the tooltip should be appended to.\n       *\n       * Currently only supports `\"body\"`.\n       */\n      this.container = this._config.container;\n      /**\n       * If `true`, tooltip is disabled and won't be displayed.\n       *\n       * @since 1.1.0\n       */\n      this.disableTooltip = this._config.disableTooltip;\n      /**\n       * An optional class applied to the tooltip window element.\n       *\n       * @since 3.2.0\n       */\n      this.tooltipClass = this._config.tooltipClass;\n      /**\n       * The opening delay in ms. Works only for \"non-manual\" opening triggers defined by the `triggers` input.\n       *\n       * @since 4.1.0\n       */\n      this.openDelay = this._config.openDelay;\n      /**\n       * The closing delay in ms. Works only for \"non-manual\" opening triggers defined by the `triggers` input.\n       *\n       * @since 4.1.0\n       */\n      this.closeDelay = this._config.closeDelay;\n      /**\n       * An event emitted when the tooltip opening animation has finished. Contains no payload.\n       */\n      this.shown = new EventEmitter();\n      /**\n       * An event emitted when the tooltip closing animation has finished. Contains no payload.\n       */\n      this.hidden = new EventEmitter();\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this._ngZone = inject(NgZone);\n      this._document = inject(DOCUMENT);\n      this._changeDetector = inject(ChangeDetectorRef);\n      this._ngbTooltipWindowId = `ngb-tooltip-${nextId++}`;\n      this._popupService = new PopupService(NgbTooltipWindow);\n      this._windowRef = null;\n      this._positioning = ngbPositioning();\n    }\n    /**\n     * The string content or a `TemplateRef` for the content to be displayed in the tooltip.\n     *\n     * If the content if falsy, the tooltip won't open.\n     */\n    set ngbTooltip(value) {\n      this._ngbTooltip = value;\n      if (!value && this._windowRef) {\n        this.close();\n      }\n    }\n    get ngbTooltip() {\n      return this._ngbTooltip;\n    }\n    /**\n     * Opens the tooltip.\n     *\n     * This is considered to be a \"manual\" triggering.\n     * The `context` is an optional value to be injected into the tooltip template when it is created.\n     */\n    open(context) {\n      if (!this._windowRef && this._ngbTooltip && !this.disableTooltip) {\n        const {\n          windowRef,\n          transition$\n        } = this._popupService.open(this._ngbTooltip, context ?? this.tooltipContext, this.animation);\n        this._windowRef = windowRef;\n        this._windowRef.setInput('animation', this.animation);\n        this._windowRef.setInput('tooltipClass', this.tooltipClass);\n        this._windowRef.setInput('id', this._ngbTooltipWindowId);\n        this._getPositionTargetElement().setAttribute('aria-describedby', this._ngbTooltipWindowId);\n        if (this.container === 'body') {\n          this._document.body.appendChild(this._windowRef.location.nativeElement);\n        }\n        // We need to detect changes, because we don't know where .open() might be called from.\n        // Ex. opening tooltip from one of lifecycle hooks that run after the CD\n        // (say from ngAfterViewInit) will result in 'ExpressionHasChanged' exception\n        this._windowRef.changeDetectorRef.detectChanges();\n        // We need to mark for check, because tooltip won't work inside the OnPush component.\n        // Ex. when we use expression like `{{ tooltip.isOpen() : 'opened' : 'closed' }}`\n        // inside the template of an OnPush component and we change the tooltip from\n        // open -> closed, the expression in question won't be updated unless we explicitly\n        // mark the parent component to be checked.\n        this._windowRef.changeDetectorRef.markForCheck();\n        // Setting up popper and scheduling updates when zone is stable\n        this._ngZone.runOutsideAngular(() => {\n          this._positioning.createPopper({\n            hostElement: this._getPositionTargetElement(),\n            targetElement: this._windowRef.location.nativeElement,\n            placement: this.placement,\n            appendToBody: this.container === 'body',\n            baseClass: 'bs-tooltip',\n            updatePopperOptions: options => this.popperOptions(addPopperOffset([0, 6])(options))\n          });\n          Promise.resolve().then(() => {\n            // This update is required for correct arrow placement\n            this._positioning.update();\n            this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positioning.update());\n          });\n        });\n        ngbAutoClose(this._ngZone, this._document, this.autoClose, () => this.close(), this.hidden, [this._windowRef.location.nativeElement], [this._nativeElement]);\n        transition$.subscribe(() => this.shown.emit());\n      }\n    }\n    /**\n     * Closes the tooltip.\n     *\n     * This is considered to be a \"manual\" triggering of the tooltip.\n     */\n    close(animation = this.animation) {\n      if (this._windowRef != null) {\n        this._getPositionTargetElement().removeAttribute('aria-describedby');\n        this._popupService.close(animation).subscribe(() => {\n          this._windowRef = null;\n          this._positioning.destroy();\n          this._zoneSubscription?.unsubscribe();\n          this.hidden.emit();\n          this._changeDetector.markForCheck();\n        });\n      }\n    }\n    /**\n     * Toggles the tooltip.\n     *\n     * This is considered to be a \"manual\" triggering of the tooltip.\n     */\n    toggle() {\n      if (this._windowRef) {\n        this.close();\n      } else {\n        this.open();\n      }\n    }\n    /**\n     * Returns `true`, if the popover is currently shown.\n     */\n    isOpen() {\n      return this._windowRef != null;\n    }\n    ngOnInit() {\n      this._unregisterListenersFn = listenToTriggers(this._nativeElement, this.triggers, this.isOpen.bind(this), this.open.bind(this), this.close.bind(this), +this.openDelay, +this.closeDelay);\n    }\n    ngOnChanges({\n      tooltipClass\n    }) {\n      if (tooltipClass && this.isOpen()) {\n        this._windowRef.setInput('tooltipClass', tooltipClass.currentValue);\n      }\n    }\n    ngOnDestroy() {\n      this.close(false);\n      // This check is needed as it might happen that ngOnDestroy is called before ngOnInit\n      // under certain conditions, see: https://github.com/ng-bootstrap/ng-bootstrap/issues/2199\n      this._unregisterListenersFn?.();\n    }\n    _getPositionTargetElement() {\n      return (isString(this.positionTarget) ? this._document.querySelector(this.positionTarget) : this.positionTarget) || this._nativeElement;\n    }\n    static #_ = this.ɵfac = function NgbTooltip_Factory(t) {\n      return new (t || NgbTooltip)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbTooltip,\n      selectors: [[\"\", \"ngbTooltip\", \"\"]],\n      inputs: {\n        animation: \"animation\",\n        autoClose: \"autoClose\",\n        placement: \"placement\",\n        popperOptions: \"popperOptions\",\n        triggers: \"triggers\",\n        positionTarget: \"positionTarget\",\n        container: \"container\",\n        disableTooltip: \"disableTooltip\",\n        tooltipClass: \"tooltipClass\",\n        tooltipContext: \"tooltipContext\",\n        openDelay: \"openDelay\",\n        closeDelay: \"closeDelay\",\n        ngbTooltip: \"ngbTooltip\"\n      },\n      outputs: {\n        shown: \"shown\",\n        hidden: \"hidden\"\n      },\n      exportAs: [\"ngbTooltip\"],\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgbTooltip;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbTooltipModule = /*#__PURE__*/(() => {\n  class NgbTooltipModule {\n    static #_ = this.ɵfac = function NgbTooltipModule_Factory(t) {\n      return new (t || NgbTooltipModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbTooltipModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbTooltipModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A component that helps with text highlighting.\n *\n * It splits the `result` text into parts that contain the searched `term` and generates the HTML markup to simplify\n * highlighting:\n *\n * Ex. `result=\"Alaska\"` and `term=\"as\"` will produce `Al<span class=\"ngb-highlight\">as</span>ka`.\n */\nlet NgbHighlight = /*#__PURE__*/(() => {\n  class NgbHighlight {\n    constructor() {\n      /**\n       * The CSS class for `<span>` elements wrapping the `term` inside the `result`.\n       */\n      this.highlightClass = 'ngb-highlight';\n      /**\n       * Boolean option to determine if the highlighting should be sensitive to accents or not.\n       *\n       * This feature is only available for browsers that implement the `String.normalize` function\n       * (typically not Internet Explorer).\n       * If you want to use this feature in a browser that does not implement `String.normalize`,\n       * you will have to include a polyfill in your application (`unorm` for example).\n       *\n       * @since 9.1.0\n       */\n      this.accentSensitive = true;\n    }\n    ngOnChanges(changes) {\n      if (!this.accentSensitive && !String.prototype.normalize) {\n        console.warn('The `accentSensitive` input in `ngb-highlight` cannot be set to `false` in a browser ' + 'that does not implement the `String.normalize` function. ' + 'You will have to include a polyfill in your application to use this feature in the current browser.');\n        this.accentSensitive = true;\n      }\n      const result = toString(this.result);\n      const terms = Array.isArray(this.term) ? this.term : [this.term];\n      const prepareTerm = term => this.accentSensitive ? term : removeAccents(term);\n      const escapedTerms = terms.map(term => regExpEscape(prepareTerm(toString(term)))).filter(term => term);\n      const toSplit = this.accentSensitive ? result : removeAccents(result);\n      const parts = escapedTerms.length ? toSplit.split(new RegExp(`(${escapedTerms.join('|')})`, 'gmi')) : [result];\n      if (this.accentSensitive) {\n        this.parts = parts;\n      } else {\n        let offset = 0;\n        this.parts = parts.map(part => result.substring(offset, offset += part.length));\n      }\n    }\n    static #_ = this.ɵfac = function NgbHighlight_Factory(t) {\n      return new (t || NgbHighlight)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbHighlight,\n      selectors: [[\"ngb-highlight\"]],\n      inputs: {\n        highlightClass: \"highlightClass\",\n        result: \"result\",\n        term: \"term\",\n        accentSensitive: \"accentSensitive\"\n      },\n      standalone: true,\n      features: [i0.ɵɵNgOnChangesFeature, i0.ɵɵStandaloneFeature],\n      decls: 2,\n      vars: 0,\n      consts: [[3, \"class\"]],\n      template: function NgbHighlight_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵrepeaterCreate(0, NgbHighlight_For_1_Template, 2, 1, null, null, i0.ɵɵrepeaterTrackByIdentity);\n        }\n        if (rf & 2) {\n          i0.ɵɵrepeater(ctx.parts);\n        }\n      },\n      styles: [\".ngb-highlight{font-weight:700}\\n\"],\n      encapsulation: 2,\n      changeDetection: 0\n    });\n  }\n  return NgbHighlight;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ARIA_LIVE_DELAY = new InjectionToken('live announcer delay', {\n  providedIn: 'root',\n  factory: () => 100\n});\nfunction getLiveElement(document, lazyCreate = false) {\n  let element = document.body.querySelector('#ngb-live');\n  if (element == null && lazyCreate) {\n    element = document.createElement('div');\n    element.setAttribute('id', 'ngb-live');\n    element.setAttribute('aria-live', 'polite');\n    element.setAttribute('aria-atomic', 'true');\n    element.classList.add('visually-hidden');\n    document.body.appendChild(element);\n  }\n  return element;\n}\nlet Live = /*#__PURE__*/(() => {\n  class Live {\n    constructor() {\n      this._document = inject(DOCUMENT);\n      this._delay = inject(ARIA_LIVE_DELAY);\n    }\n    ngOnDestroy() {\n      const element = getLiveElement(this._document);\n      if (element) {\n        // if exists, it will always be attached to the <body>\n        element.parentElement.removeChild(element);\n      }\n    }\n    say(message) {\n      const element = getLiveElement(this._document, true);\n      const delay = this._delay;\n      if (element != null) {\n        element.textContent = '';\n        const setText = () => element.textContent = message;\n        if (delay === null) {\n          setText();\n        } else {\n          setTimeout(setText, delay);\n        }\n      }\n    }\n    static #_ = this.ɵfac = function Live_Factory(t) {\n      return new (t || Live)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: Live,\n      factory: Live.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return Live;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbTypeahead`](#/components/typeahead/api#NgbTypeahead) component.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all the typeaheads used in the application.\n */\nlet NgbTypeaheadConfig = /*#__PURE__*/(() => {\n  class NgbTypeaheadConfig {\n    constructor() {\n      this.editable = true;\n      this.focusFirst = true;\n      this.selectOnExact = false;\n      this.showHint = false;\n      this.placement = ['bottom-start', 'bottom-end', 'top-start', 'top-end'];\n      this.popperOptions = options => options;\n    }\n    static #_ = this.ɵfac = function NgbTypeaheadConfig_Factory(t) {\n      return new (t || NgbTypeaheadConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbTypeaheadConfig,\n      factory: NgbTypeaheadConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbTypeaheadConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbTypeaheadWindow = /*#__PURE__*/(() => {\n  class NgbTypeaheadWindow {\n    constructor() {\n      this.activeIdx = 0;\n      /**\n       * Flag indicating if the first row should be active initially\n       */\n      this.focusFirst = true;\n      /**\n       * A function used to format a given result before display. This function should return a formatted string without any\n       * HTML markup\n       */\n      this.formatter = toString;\n      /**\n       * Event raised when user selects a particular result row\n       */\n      this.selectEvent = new EventEmitter();\n      this.activeChangeEvent = new EventEmitter();\n    }\n    hasActive() {\n      return this.activeIdx > -1 && this.activeIdx < this.results.length;\n    }\n    getActive() {\n      return this.results[this.activeIdx];\n    }\n    markActive(activeIdx) {\n      this.activeIdx = activeIdx;\n      this._activeChanged();\n    }\n    next() {\n      if (this.activeIdx === this.results.length - 1) {\n        this.activeIdx = this.focusFirst ? (this.activeIdx + 1) % this.results.length : -1;\n      } else {\n        this.activeIdx++;\n      }\n      this._activeChanged();\n    }\n    prev() {\n      if (this.activeIdx < 0) {\n        this.activeIdx = this.results.length - 1;\n      } else if (this.activeIdx === 0) {\n        this.activeIdx = this.focusFirst ? this.results.length - 1 : -1;\n      } else {\n        this.activeIdx--;\n      }\n      this._activeChanged();\n    }\n    resetActive() {\n      this.activeIdx = this.focusFirst ? 0 : -1;\n      this._activeChanged();\n    }\n    select(item) {\n      this.selectEvent.emit(item);\n    }\n    ngOnInit() {\n      this.resetActive();\n    }\n    _activeChanged() {\n      this.activeChangeEvent.emit(this.activeIdx >= 0 ? this.id + '-' + this.activeIdx : undefined);\n    }\n    static #_ = this.ɵfac = function NgbTypeaheadWindow_Factory(t) {\n      return new (t || NgbTypeaheadWindow)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbTypeaheadWindow,\n      selectors: [[\"ngb-typeahead-window\"]],\n      hostAttrs: [\"role\", \"listbox\"],\n      hostVars: 3,\n      hostBindings: function NgbTypeaheadWindow_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"mousedown\", function NgbTypeaheadWindow_mousedown_HostBindingHandler($event) {\n            return $event.preventDefault();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"id\", ctx.id);\n          i0.ɵɵclassMap(\"dropdown-menu show\" + (ctx.popupClass ? \" \" + ctx.popupClass : \"\"));\n        }\n      },\n      inputs: {\n        id: \"id\",\n        focusFirst: \"focusFirst\",\n        results: \"results\",\n        term: \"term\",\n        formatter: \"formatter\",\n        resultTemplate: \"resultTemplate\",\n        popupClass: \"popupClass\"\n      },\n      outputs: {\n        selectEvent: \"select\",\n        activeChangeEvent: \"activeChange\"\n      },\n      exportAs: [\"ngbTypeaheadWindow\"],\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 4,\n      vars: 0,\n      consts: [[\"rt\", \"\"], [3, \"result\", \"term\"], [\"type\", \"button\", \"role\", \"option\", 1, \"dropdown-item\", 3, \"id\", \"mouseenter\", \"click\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"type\", \"button\", \"class\", \"dropdown-item\", \"role\", \"option\", 3, \"id\", \"active\"]],\n      template: function NgbTypeaheadWindow_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵtemplate(0, NgbTypeaheadWindow_ng_template_0_Template, 1, 2, \"ng-template\", null, 0, i0.ɵɵtemplateRefExtractor);\n          i0.ɵɵrepeaterCreate(2, NgbTypeaheadWindow_For_3_Template, 2, 9, \"button\", 4, i0.ɵɵrepeaterTrackByIdentity);\n        }\n        if (rf & 2) {\n          i0.ɵɵadvance(2);\n          i0.ɵɵrepeater(ctx.results);\n        }\n      },\n      dependencies: [NgbHighlight, NgTemplateOutlet],\n      encapsulation: 2\n    });\n  }\n  return NgbTypeaheadWindow;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet nextWindowId = 0;\n/**\n * A directive providing a simple way of creating powerful typeaheads from any text input.\n */\nlet NgbTypeahead = /*#__PURE__*/(() => {\n  class NgbTypeahead {\n    constructor() {\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this._config = inject(NgbTypeaheadConfig);\n      this._live = inject(Live);\n      this._document = inject(DOCUMENT);\n      this._ngZone = inject(NgZone);\n      this._changeDetector = inject(ChangeDetectorRef);\n      this._popupService = new PopupService(NgbTypeaheadWindow);\n      this._positioning = ngbPositioning();\n      this._subscription = null;\n      this._closed$ = new Subject();\n      this._inputValueBackup = null;\n      this._inputValueForSelectOnExact = null;\n      this._valueChanges$ = fromEvent(this._nativeElement, 'input').pipe(map($event => $event.target.value));\n      this._resubscribeTypeahead$ = new BehaviorSubject(null);\n      this._windowRef = null;\n      /**\n       * The value for the `autocomplete` attribute for the `<input>` element.\n       *\n       * Defaults to `\"off\"` to disable the native browser autocomplete, but you can override it if necessary.\n       *\n       * @since 2.1.0\n       */\n      this.autocomplete = 'off';\n      /**\n       * A selector specifying the element the typeahead popup will be appended to.\n       *\n       * Currently only supports `\"body\"`.\n       */\n      this.container = this._config.container;\n      /**\n       * If `true`, model values will not be restricted only to items selected from the popup.\n       */\n      this.editable = this._config.editable;\n      /**\n       * If `true`, the first item in the result list will always stay focused while typing.\n       */\n      this.focusFirst = this._config.focusFirst;\n      /**\n       * If `true`, automatically selects the item when it is the only one that exactly matches the user input\n       *\n       * @since 14.2.0\n       */\n      this.selectOnExact = this._config.selectOnExact;\n      /**\n       * If `true`, will show the hint in the `<input>` when an item in the result list matches.\n       */\n      this.showHint = this._config.showHint;\n      /**\n       * The preferred placement of the typeahead, among the [possible values](#/guides/positioning#api).\n       *\n       * The default order of preference is `\"bottom-start bottom-end top-start top-end\"`\n       *\n       * Please see the [positioning overview](#/positioning) for more details.\n       */\n      this.placement = this._config.placement;\n      /**\n       * Allows to change default Popper options when positioning the typeahead.\n       * Receives current popper options and returns modified ones.\n       *\n       * @since 13.1.0\n       */\n      this.popperOptions = this._config.popperOptions;\n      /**\n       * An event emitted right before an item is selected from the result list.\n       *\n       * Event payload is of type [`NgbTypeaheadSelectItemEvent`](#/components/typeahead/api#NgbTypeaheadSelectItemEvent).\n       */\n      this.selectItem = new EventEmitter();\n      this.activeDescendant = null;\n      this.popupId = `ngb-typeahead-${nextWindowId++}`;\n      this._onTouched = () => {};\n      this._onChange = _ => {};\n    }\n    ngOnInit() {\n      this._subscribeToUserInput();\n    }\n    ngOnChanges({\n      ngbTypeahead\n    }) {\n      if (ngbTypeahead && !ngbTypeahead.firstChange) {\n        this._unsubscribeFromUserInput();\n        this._subscribeToUserInput();\n      }\n    }\n    ngOnDestroy() {\n      this._closePopup();\n      this._unsubscribeFromUserInput();\n    }\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    writeValue(value) {\n      this._writeInputValue(this._formatItemForInput(value));\n      if (this.showHint) {\n        this._inputValueBackup = value;\n      }\n    }\n    setDisabledState(isDisabled) {\n      this._nativeElement.disabled = isDisabled;\n    }\n    /**\n     * Dismisses typeahead popup window\n     */\n    dismissPopup() {\n      if (this.isPopupOpen()) {\n        this._resubscribeTypeahead$.next(null);\n        this._closePopup();\n        if (this.showHint && this._inputValueBackup !== null) {\n          this._writeInputValue(this._inputValueBackup);\n        }\n        this._changeDetector.markForCheck();\n      }\n    }\n    /**\n     * Returns true if the typeahead popup window is displayed\n     */\n    isPopupOpen() {\n      return this._windowRef != null;\n    }\n    handleBlur() {\n      this._resubscribeTypeahead$.next(null);\n      this._onTouched();\n    }\n    handleKeyDown(event) {\n      if (!this.isPopupOpen()) {\n        return;\n      }\n      /* eslint-disable-next-line deprecation/deprecation */\n      switch (event.which) {\n        case Key.ArrowDown:\n          event.preventDefault();\n          this._windowRef.instance.next();\n          this._showHint();\n          break;\n        case Key.ArrowUp:\n          event.preventDefault();\n          this._windowRef.instance.prev();\n          this._showHint();\n          break;\n        case Key.Enter:\n        case Key.Tab:\n          {\n            const result = this._windowRef.instance.getActive();\n            if (isDefined(result)) {\n              event.preventDefault();\n              event.stopPropagation();\n              this._selectResult(result);\n            }\n            this._closePopup();\n            break;\n          }\n      }\n    }\n    _openPopup() {\n      if (!this.isPopupOpen()) {\n        this._inputValueBackup = this._nativeElement.value;\n        const {\n          windowRef\n        } = this._popupService.open();\n        this._windowRef = windowRef;\n        this._windowRef.setInput('id', this.popupId);\n        this._windowRef.setInput('popupClass', this.popupClass);\n        this._windowRef.instance.selectEvent.subscribe(result => this._selectResultClosePopup(result));\n        this._windowRef.instance.activeChangeEvent.subscribe(activeId => this.activeDescendant = activeId);\n        if (this.container === 'body') {\n          this._windowRef.location.nativeElement.style.zIndex = '1055';\n          this._document.body.appendChild(this._windowRef.location.nativeElement);\n        }\n        this._changeDetector.markForCheck();\n        // Setting up popper and scheduling updates when zone is stable\n        this._ngZone.runOutsideAngular(() => {\n          if (this._windowRef) {\n            this._positioning.createPopper({\n              hostElement: this._nativeElement,\n              targetElement: this._windowRef.location.nativeElement,\n              placement: this.placement,\n              appendToBody: this.container === 'body',\n              updatePopperOptions: options => this.popperOptions(addPopperOffset([0, 2])(options))\n            });\n            this._zoneSubscription = this._ngZone.onStable.subscribe(() => this._positioning.update());\n          }\n        });\n        ngbAutoClose(this._ngZone, this._document, 'outside', () => this.dismissPopup(), this._closed$, [this._nativeElement, this._windowRef.location.nativeElement]);\n      }\n    }\n    _closePopup() {\n      this._popupService.close().subscribe(() => {\n        this._positioning.destroy();\n        this._zoneSubscription?.unsubscribe();\n        this._closed$.next();\n        this._windowRef = null;\n        this.activeDescendant = null;\n      });\n    }\n    _selectResult(result) {\n      let defaultPrevented = false;\n      this.selectItem.emit({\n        item: result,\n        preventDefault: () => {\n          defaultPrevented = true;\n        }\n      });\n      this._resubscribeTypeahead$.next(null);\n      if (!defaultPrevented) {\n        this.writeValue(result);\n        this._onChange(result);\n      }\n    }\n    _selectResultClosePopup(result) {\n      this._selectResult(result);\n      this._closePopup();\n    }\n    _showHint() {\n      if (this.showHint && this._windowRef?.instance.hasActive() && this._inputValueBackup != null) {\n        const userInputLowerCase = this._inputValueBackup.toLowerCase();\n        const formattedVal = this._formatItemForInput(this._windowRef.instance.getActive());\n        if (userInputLowerCase === formattedVal.substring(0, this._inputValueBackup.length).toLowerCase()) {\n          this._writeInputValue(this._inputValueBackup + formattedVal.substring(this._inputValueBackup.length));\n          this._nativeElement['setSelectionRange'].apply(this._nativeElement, [this._inputValueBackup.length, formattedVal.length]);\n        } else {\n          this._writeInputValue(formattedVal);\n        }\n      }\n    }\n    _formatItemForInput(item) {\n      return item != null && this.inputFormatter ? this.inputFormatter(item) : toString(item);\n    }\n    _writeInputValue(value) {\n      this._nativeElement.value = toString(value);\n    }\n    _subscribeToUserInput() {\n      const results$ = this._valueChanges$.pipe(tap(value => {\n        this._inputValueBackup = this.showHint ? value : null;\n        this._inputValueForSelectOnExact = this.selectOnExact ? value : null;\n        this._onChange(this.editable ? value : undefined);\n      }), this.ngbTypeahead ? this.ngbTypeahead : () => of([]));\n      this._subscription = this._resubscribeTypeahead$.pipe(switchMap(() => results$)).subscribe(results => {\n        if (!results || results.length === 0) {\n          this._closePopup();\n        } else {\n          // when there is only one result and this matches the input value\n          if (this.selectOnExact && results.length === 1 && this._formatItemForInput(results[0]) === this._inputValueForSelectOnExact) {\n            this._selectResult(results[0]);\n            this._closePopup();\n          } else {\n            this._openPopup();\n            this._windowRef.setInput('focusFirst', this.focusFirst);\n            this._windowRef.setInput('results', results);\n            this._windowRef.setInput('term', this._nativeElement.value);\n            if (this.resultFormatter) {\n              this._windowRef.setInput('formatter', this.resultFormatter);\n            }\n            if (this.resultTemplate) {\n              this._windowRef.setInput('resultTemplate', this.resultTemplate);\n            }\n            this._windowRef.instance.resetActive();\n            // The observable stream we are subscribing to might have async steps\n            // and if a component containing typeahead is using the OnPush strategy\n            // the change detection turn wouldn't be invoked automatically.\n            this._windowRef.changeDetectorRef.detectChanges();\n            this._showHint();\n          }\n        }\n        // live announcer\n        const count = results ? results.length : 0;\n        this._live.say(count === 0 ? 'No results available' : `${count} result${count === 1 ? '' : 's'} available`);\n      });\n    }\n    _unsubscribeFromUserInput() {\n      if (this._subscription) {\n        this._subscription.unsubscribe();\n      }\n      this._subscription = null;\n    }\n    static #_ = this.ɵfac = function NgbTypeahead_Factory(t) {\n      return new (t || NgbTypeahead)();\n    };\n    static #_2 = this.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n      type: NgbTypeahead,\n      selectors: [[\"input\", \"ngbTypeahead\", \"\"]],\n      hostAttrs: [\"autocapitalize\", \"off\", \"autocorrect\", \"off\", \"role\", \"combobox\"],\n      hostVars: 7,\n      hostBindings: function NgbTypeahead_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"blur\", function NgbTypeahead_blur_HostBindingHandler() {\n            return ctx.handleBlur();\n          })(\"keydown\", function NgbTypeahead_keydown_HostBindingHandler($event) {\n            return ctx.handleKeyDown($event);\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵhostProperty(\"autocomplete\", ctx.autocomplete);\n          i0.ɵɵattribute(\"aria-autocomplete\", ctx.showHint ? \"both\" : \"list\")(\"aria-activedescendant\", ctx.activeDescendant)(\"aria-owns\", ctx.isPopupOpen() ? ctx.popupId : null)(\"aria-expanded\", ctx.isPopupOpen());\n          i0.ɵɵclassProp(\"open\", ctx.isPopupOpen());\n        }\n      },\n      inputs: {\n        autocomplete: \"autocomplete\",\n        container: \"container\",\n        editable: \"editable\",\n        focusFirst: \"focusFirst\",\n        inputFormatter: \"inputFormatter\",\n        ngbTypeahead: \"ngbTypeahead\",\n        resultFormatter: \"resultFormatter\",\n        resultTemplate: \"resultTemplate\",\n        selectOnExact: \"selectOnExact\",\n        showHint: \"showHint\",\n        placement: \"placement\",\n        popperOptions: \"popperOptions\",\n        popupClass: \"popupClass\"\n      },\n      outputs: {\n        selectItem: \"selectItem\"\n      },\n      exportAs: [\"ngbTypeahead\"],\n      standalone: true,\n      features: [i0.ɵɵProvidersFeature([{\n        provide: NG_VALUE_ACCESSOR,\n        useExisting: forwardRef(() => NgbTypeahead),\n        multi: true\n      }]), i0.ɵɵNgOnChangesFeature]\n    });\n  }\n  return NgbTypeahead;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbTypeaheadModule = /*#__PURE__*/(() => {\n  class NgbTypeaheadModule {\n    static #_ = this.ɵfac = function NgbTypeaheadModule_Factory(t) {\n      return new (t || NgbTypeaheadModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbTypeaheadModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbTypeaheadModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A configuration service for the [`NgbOffcanvas`](#/components/offcanvas/api#NgbOffcanvas) service.\n *\n * You can inject this service, typically in your root component, and customize the values of its properties in\n * order to provide default values for all offcanvases used in the application.\n *\n * @since 12.1.0\n */\nlet NgbOffcanvasConfig = /*#__PURE__*/(() => {\n  class NgbOffcanvasConfig {\n    constructor() {\n      this._ngbConfig = inject(NgbConfig);\n      this.backdrop = true;\n      this.keyboard = true;\n      this.position = 'start';\n      this.scroll = false;\n    }\n    get animation() {\n      return this._animation ?? this._ngbConfig.animation;\n    }\n    set animation(animation) {\n      this._animation = animation;\n    }\n    static #_ = this.ɵfac = function NgbOffcanvasConfig_Factory(t) {\n      return new (t || NgbOffcanvasConfig)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbOffcanvasConfig,\n      factory: NgbOffcanvasConfig.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbOffcanvasConfig;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A reference to the currently opened (active) offcanvas.\n *\n * Instances of this class can be injected into your component passed as offcanvas content.\n * So you can `.close()` or `.dismiss()` the offcanvas window from your component.\n *\n * @since 12.1.0\n */\nclass NgbActiveOffcanvas {\n  /**\n   * Closes the offcanvas with an optional `result` value.\n   *\n   * The `NgbOffcanvasRef.result` promise will be resolved with the provided value.\n   */\n  close(result) {}\n  /**\n   * Dismisses the offcanvas with an optional `reason` value.\n   *\n   * The `NgbOffcanvasRef.result` promise will be rejected with the provided value.\n   */\n  dismiss(reason) {}\n}\n/**\n * A reference to the newly opened offcanvas returned by the `NgbOffcanvas.open()` method.\n *\n * @since 12.1.0\n */\nclass NgbOffcanvasRef {\n  /**\n   * The instance of a component used for the offcanvas content.\n   *\n   * When a `TemplateRef` is used as the content or when the offcanvas is closed, will return `undefined`.\n   */\n  get componentInstance() {\n    if (this._contentRef && this._contentRef.componentRef) {\n      return this._contentRef.componentRef.instance;\n    }\n  }\n  /**\n   * The observable that emits when the offcanvas is closed via the `.close()` method.\n   *\n   * It will emit the result passed to the `.close()` method.\n   */\n  get closed() {\n    return this._closed.asObservable().pipe(takeUntil(this._hidden));\n  }\n  /**\n   * The observable that emits when the offcanvas is dismissed via the `.dismiss()` method.\n   *\n   * It will emit the reason passed to the `.dismissed()` method by the user, or one of the internal\n   * reasons like backdrop click or ESC key press.\n   */\n  get dismissed() {\n    return this._dismissed.asObservable().pipe(takeUntil(this._hidden));\n  }\n  /**\n   * The observable that emits when both offcanvas window and backdrop are closed and animations were finished.\n   * At this point offcanvas and backdrop elements will be removed from the DOM tree.\n   *\n   * This observable will be completed after emitting.\n   */\n  get hidden() {\n    return this._hidden.asObservable();\n  }\n  /**\n   * The observable that emits when offcanvas is fully visible and animation was finished.\n   * The offcanvas DOM element is always available synchronously after calling 'offcanvas.open()' service.\n   *\n   * This observable will be completed after emitting.\n   * It will not emit, if offcanvas is closed before open animation is finished.\n   */\n  get shown() {\n    return this._panelCmptRef.instance.shown.asObservable();\n  }\n  constructor(_panelCmptRef, _contentRef, _backdropCmptRef, _beforeDismiss) {\n    this._panelCmptRef = _panelCmptRef;\n    this._contentRef = _contentRef;\n    this._backdropCmptRef = _backdropCmptRef;\n    this._beforeDismiss = _beforeDismiss;\n    this._closed = new Subject();\n    this._dismissed = new Subject();\n    this._hidden = new Subject();\n    _panelCmptRef.instance.dismissEvent.subscribe(reason => {\n      this.dismiss(reason);\n    });\n    if (_backdropCmptRef) {\n      _backdropCmptRef.instance.dismissEvent.subscribe(reason => {\n        this.dismiss(reason);\n      });\n    }\n    this.result = new Promise((resolve, reject) => {\n      this._resolve = resolve;\n      this._reject = reject;\n    });\n    this.result.then(null, () => {});\n  }\n  /**\n   * Closes the offcanvas with an optional `result` value.\n   *\n   * The `NgbMobalRef.result` promise will be resolved with the provided value.\n   */\n  close(result) {\n    if (this._panelCmptRef) {\n      this._closed.next(result);\n      this._resolve(result);\n      this._removeOffcanvasElements();\n    }\n  }\n  _dismiss(reason) {\n    this._dismissed.next(reason);\n    this._reject(reason);\n    this._removeOffcanvasElements();\n  }\n  /**\n   * Dismisses the offcanvas with an optional `reason` value.\n   *\n   * The `NgbOffcanvasRef.result` promise will be rejected with the provided value.\n   */\n  dismiss(reason) {\n    if (this._panelCmptRef) {\n      if (!this._beforeDismiss) {\n        this._dismiss(reason);\n      } else {\n        const dismiss = this._beforeDismiss();\n        if (isPromise(dismiss)) {\n          dismiss.then(result => {\n            if (result !== false) {\n              this._dismiss(reason);\n            }\n          }, () => {});\n        } else if (dismiss !== false) {\n          this._dismiss(reason);\n        }\n      }\n    }\n  }\n  _removeOffcanvasElements() {\n    const panelTransition$ = this._panelCmptRef.instance.hide();\n    const backdropTransition$ = this._backdropCmptRef ? this._backdropCmptRef.instance.hide() : of(undefined);\n    // hiding panel\n    panelTransition$.subscribe(() => {\n      const {\n        nativeElement\n      } = this._panelCmptRef.location;\n      nativeElement.parentNode.removeChild(nativeElement);\n      this._panelCmptRef.destroy();\n      if (this._contentRef && this._contentRef.viewRef) {\n        this._contentRef.viewRef.destroy();\n      }\n      this._panelCmptRef = null;\n      this._contentRef = null;\n    });\n    // hiding backdrop\n    backdropTransition$.subscribe(() => {\n      if (this._backdropCmptRef) {\n        const {\n          nativeElement\n        } = this._backdropCmptRef.location;\n        nativeElement.parentNode.removeChild(nativeElement);\n        this._backdropCmptRef.destroy();\n        this._backdropCmptRef = null;\n      }\n    });\n    // all done\n    zip(panelTransition$, backdropTransition$).subscribe(() => {\n      this._hidden.next();\n      this._hidden.complete();\n    });\n  }\n}\nvar OffcanvasDismissReasons = /*#__PURE__*/function (OffcanvasDismissReasons) {\n  OffcanvasDismissReasons[OffcanvasDismissReasons[\"BACKDROP_CLICK\"] = 0] = \"BACKDROP_CLICK\";\n  OffcanvasDismissReasons[OffcanvasDismissReasons[\"ESC\"] = 1] = \"ESC\";\n  return OffcanvasDismissReasons;\n}(OffcanvasDismissReasons || {});\nlet NgbOffcanvasBackdrop = /*#__PURE__*/(() => {\n  class NgbOffcanvasBackdrop {\n    constructor() {\n      this._nativeElement = inject(ElementRef).nativeElement;\n      this._zone = inject(NgZone);\n      this.dismissEvent = new EventEmitter();\n    }\n    ngOnInit() {\n      this._zone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        ngbRunTransition(this._zone, this._nativeElement, (element, animation) => {\n          if (animation) {\n            reflow(element);\n          }\n          element.classList.add('show');\n        }, {\n          animation: this.animation,\n          runningTransition: 'continue'\n        });\n      });\n    }\n    hide() {\n      return ngbRunTransition(this._zone, this._nativeElement, ({\n        classList\n      }) => classList.remove('show'), {\n        animation: this.animation,\n        runningTransition: 'stop'\n      });\n    }\n    dismiss() {\n      if (!this.static) {\n        this.dismissEvent.emit(OffcanvasDismissReasons.BACKDROP_CLICK);\n      }\n    }\n    static #_ = this.ɵfac = function NgbOffcanvasBackdrop_Factory(t) {\n      return new (t || NgbOffcanvasBackdrop)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbOffcanvasBackdrop,\n      selectors: [[\"ngb-offcanvas-backdrop\"]],\n      hostVars: 6,\n      hostBindings: function NgbOffcanvasBackdrop_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵlistener(\"mousedown\", function NgbOffcanvasBackdrop_mousedown_HostBindingHandler() {\n            return ctx.dismiss();\n          });\n        }\n        if (rf & 2) {\n          i0.ɵɵclassMap(\"offcanvas-backdrop\" + (ctx.backdropClass ? \" \" + ctx.backdropClass : \"\"));\n          i0.ɵɵclassProp(\"show\", !ctx.animation)(\"fade\", ctx.animation);\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        backdropClass: \"backdropClass\",\n        static: \"static\"\n      },\n      outputs: {\n        dismissEvent: \"dismiss\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      decls: 0,\n      vars: 0,\n      template: function NgbOffcanvasBackdrop_Template(rf, ctx) {},\n      encapsulation: 2\n    });\n  }\n  return NgbOffcanvasBackdrop;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbOffcanvasPanel = /*#__PURE__*/(() => {\n  class NgbOffcanvasPanel {\n    constructor() {\n      this._document = inject(DOCUMENT);\n      this._elRef = inject(ElementRef);\n      this._zone = inject(NgZone);\n      this._closed$ = new Subject();\n      this._elWithFocus = null; // element that is focused prior to offcanvas opening\n      this.keyboard = true;\n      this.position = 'start';\n      this.dismissEvent = new EventEmitter();\n      this.shown = new Subject();\n      this.hidden = new Subject();\n    }\n    dismiss(reason) {\n      this.dismissEvent.emit(reason);\n    }\n    ngOnInit() {\n      this._elWithFocus = this._document.activeElement;\n      this._zone.onStable.asObservable().pipe(take(1)).subscribe(() => {\n        this._show();\n      });\n    }\n    ngOnDestroy() {\n      this._disableEventHandling();\n    }\n    hide() {\n      const context = {\n        animation: this.animation,\n        runningTransition: 'stop'\n      };\n      const offcanvasTransition$ = ngbRunTransition(this._zone, this._elRef.nativeElement, element => {\n        element.classList.remove('showing');\n        element.classList.add('hiding');\n        return () => element.classList.remove('show', 'hiding');\n      }, context);\n      offcanvasTransition$.subscribe(() => {\n        this.hidden.next();\n        this.hidden.complete();\n      });\n      this._disableEventHandling();\n      this._restoreFocus();\n      return offcanvasTransition$;\n    }\n    _show() {\n      const context = {\n        animation: this.animation,\n        runningTransition: 'continue'\n      };\n      const offcanvasTransition$ = ngbRunTransition(this._zone, this._elRef.nativeElement, (element, animation) => {\n        if (animation) {\n          reflow(element);\n        }\n        element.classList.add('show', 'showing');\n        return () => element.classList.remove('showing');\n      }, context);\n      offcanvasTransition$.subscribe(() => {\n        this.shown.next();\n        this.shown.complete();\n      });\n      this._enableEventHandling();\n      this._setFocus();\n    }\n    _enableEventHandling() {\n      const {\n        nativeElement\n      } = this._elRef;\n      this._zone.runOutsideAngular(() => {\n        fromEvent(nativeElement, 'keydown').pipe(takeUntil(this._closed$), /* eslint-disable-next-line deprecation/deprecation */\n        filter(e => e.which === Key.Escape)).subscribe(event => {\n          if (this.keyboard) {\n            requestAnimationFrame(() => {\n              if (!event.defaultPrevented) {\n                this._zone.run(() => this.dismiss(OffcanvasDismissReasons.ESC));\n              }\n            });\n          }\n        });\n      });\n    }\n    _disableEventHandling() {\n      this._closed$.next();\n    }\n    _setFocus() {\n      const {\n        nativeElement\n      } = this._elRef;\n      if (!nativeElement.contains(document.activeElement)) {\n        const autoFocusable = nativeElement.querySelector(`[ngbAutofocus]`);\n        const firstFocusable = getFocusableBoundaryElements(nativeElement)[0];\n        const elementToFocus = autoFocusable || firstFocusable || nativeElement;\n        elementToFocus.focus();\n      }\n    }\n    _restoreFocus() {\n      const body = this._document.body;\n      const elWithFocus = this._elWithFocus;\n      let elementToFocus;\n      if (elWithFocus && elWithFocus['focus'] && body.contains(elWithFocus)) {\n        elementToFocus = elWithFocus;\n      } else {\n        elementToFocus = body;\n      }\n      this._zone.runOutsideAngular(() => {\n        setTimeout(() => elementToFocus.focus());\n        this._elWithFocus = null;\n      });\n    }\n    static #_ = this.ɵfac = function NgbOffcanvasPanel_Factory(t) {\n      return new (t || NgbOffcanvasPanel)();\n    };\n    static #_2 = this.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n      type: NgbOffcanvasPanel,\n      selectors: [[\"ngb-offcanvas-panel\"]],\n      hostAttrs: [\"role\", \"dialog\", \"tabindex\", \"-1\"],\n      hostVars: 5,\n      hostBindings: function NgbOffcanvasPanel_HostBindings(rf, ctx) {\n        if (rf & 2) {\n          i0.ɵɵattribute(\"aria-modal\", true)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-describedby\", ctx.ariaDescribedBy);\n          i0.ɵɵclassMap(\"offcanvas offcanvas-\" + ctx.position + (ctx.panelClass ? \" \" + ctx.panelClass : \"\"));\n        }\n      },\n      inputs: {\n        animation: \"animation\",\n        ariaLabelledBy: \"ariaLabelledBy\",\n        ariaDescribedBy: \"ariaDescribedBy\",\n        keyboard: \"keyboard\",\n        panelClass: \"panelClass\",\n        position: \"position\"\n      },\n      outputs: {\n        dismissEvent: \"dismiss\"\n      },\n      standalone: true,\n      features: [i0.ɵɵStandaloneFeature],\n      ngContentSelectors: _c0,\n      decls: 1,\n      vars: 0,\n      template: function NgbOffcanvasPanel_Template(rf, ctx) {\n        if (rf & 1) {\n          i0.ɵɵprojectionDef();\n          i0.ɵɵprojection(0);\n        }\n      },\n      encapsulation: 2\n    });\n  }\n  return NgbOffcanvasPanel;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbOffcanvasStack = /*#__PURE__*/(() => {\n  class NgbOffcanvasStack {\n    constructor() {\n      this._applicationRef = inject(ApplicationRef);\n      this._injector = inject(Injector);\n      this._document = inject(DOCUMENT);\n      this._scrollBar = inject(ScrollBar);\n      this._activePanelCmptHasChanged = new Subject();\n      this._scrollBarRestoreFn = null;\n      this._backdropAttributes = ['animation', 'backdropClass'];\n      this._panelAttributes = ['animation', 'ariaDescribedBy', 'ariaLabelledBy', 'keyboard', 'panelClass', 'position'];\n      this._activeInstance = new EventEmitter();\n      const ngZone = inject(NgZone);\n      // Trap focus on active PanelCmpt\n      this._activePanelCmptHasChanged.subscribe(() => {\n        if (this._panelCmpt) {\n          ngbFocusTrap(ngZone, this._panelCmpt.location.nativeElement, this._activePanelCmptHasChanged);\n        }\n      });\n    }\n    _restoreScrollBar() {\n      const scrollBarRestoreFn = this._scrollBarRestoreFn;\n      if (scrollBarRestoreFn) {\n        this._scrollBarRestoreFn = null;\n        scrollBarRestoreFn();\n      }\n    }\n    _hideScrollBar() {\n      if (!this._scrollBarRestoreFn) {\n        this._scrollBarRestoreFn = this._scrollBar.hide();\n      }\n    }\n    open(contentInjector, content, options) {\n      const containerEl = options.container instanceof HTMLElement ? options.container : isDefined(options.container) ? this._document.querySelector(options.container) : this._document.body;\n      if (!containerEl) {\n        throw new Error(`The specified offcanvas container \"${options.container || 'body'}\" was not found in the DOM.`);\n      }\n      if (!options.scroll) {\n        this._hideScrollBar();\n      }\n      const activeOffcanvas = new NgbActiveOffcanvas();\n      const contentRef = this._getContentRef(options.injector || contentInjector, content, activeOffcanvas);\n      let backdropCmptRef = options.backdrop !== false ? this._attachBackdrop(containerEl) : undefined;\n      let panelCmptRef = this._attachWindowComponent(containerEl, contentRef.nodes);\n      let ngbOffcanvasRef = new NgbOffcanvasRef(panelCmptRef, contentRef, backdropCmptRef, options.beforeDismiss);\n      this._registerOffcanvasRef(ngbOffcanvasRef);\n      this._registerPanelCmpt(panelCmptRef);\n      ngbOffcanvasRef.hidden.pipe(finalize(() => this._restoreScrollBar())).subscribe();\n      activeOffcanvas.close = result => {\n        ngbOffcanvasRef.close(result);\n      };\n      activeOffcanvas.dismiss = reason => {\n        ngbOffcanvasRef.dismiss(reason);\n      };\n      this._applyPanelOptions(panelCmptRef.instance, options);\n      if (backdropCmptRef && backdropCmptRef.instance) {\n        this._applyBackdropOptions(backdropCmptRef.instance, options);\n        backdropCmptRef.changeDetectorRef.detectChanges();\n      }\n      panelCmptRef.changeDetectorRef.detectChanges();\n      return ngbOffcanvasRef;\n    }\n    get activeInstance() {\n      return this._activeInstance;\n    }\n    dismiss(reason) {\n      this._offcanvasRef?.dismiss(reason);\n    }\n    hasOpenOffcanvas() {\n      return !!this._offcanvasRef;\n    }\n    _attachBackdrop(containerEl) {\n      let backdropCmptRef = createComponent(NgbOffcanvasBackdrop, {\n        environmentInjector: this._applicationRef.injector,\n        elementInjector: this._injector\n      });\n      this._applicationRef.attachView(backdropCmptRef.hostView);\n      containerEl.appendChild(backdropCmptRef.location.nativeElement);\n      return backdropCmptRef;\n    }\n    _attachWindowComponent(containerEl, projectableNodes) {\n      let panelCmptRef = createComponent(NgbOffcanvasPanel, {\n        environmentInjector: this._applicationRef.injector,\n        elementInjector: this._injector,\n        projectableNodes\n      });\n      this._applicationRef.attachView(panelCmptRef.hostView);\n      containerEl.appendChild(panelCmptRef.location.nativeElement);\n      return panelCmptRef;\n    }\n    _applyPanelOptions(windowInstance, options) {\n      this._panelAttributes.forEach(optionName => {\n        if (isDefined(options[optionName])) {\n          windowInstance[optionName] = options[optionName];\n        }\n      });\n    }\n    _applyBackdropOptions(backdropInstance, options) {\n      this._backdropAttributes.forEach(optionName => {\n        if (isDefined(options[optionName])) {\n          backdropInstance[optionName] = options[optionName];\n        }\n      });\n      backdropInstance.static = options.backdrop === 'static';\n    }\n    _getContentRef(contentInjector, content, activeOffcanvas) {\n      if (!content) {\n        return new ContentRef([]);\n      } else if (content instanceof TemplateRef) {\n        return this._createFromTemplateRef(content, activeOffcanvas);\n      } else if (isString(content)) {\n        return this._createFromString(content);\n      } else {\n        return this._createFromComponent(contentInjector, content, activeOffcanvas);\n      }\n    }\n    _createFromTemplateRef(templateRef, activeOffcanvas) {\n      const context = {\n        $implicit: activeOffcanvas,\n        close(result) {\n          activeOffcanvas.close(result);\n        },\n        dismiss(reason) {\n          activeOffcanvas.dismiss(reason);\n        }\n      };\n      const viewRef = templateRef.createEmbeddedView(context);\n      this._applicationRef.attachView(viewRef);\n      return new ContentRef([viewRef.rootNodes], viewRef);\n    }\n    _createFromString(content) {\n      const component = this._document.createTextNode(`${content}`);\n      return new ContentRef([[component]]);\n    }\n    _createFromComponent(contentInjector, componentType, context) {\n      const elementInjector = Injector.create({\n        providers: [{\n          provide: NgbActiveOffcanvas,\n          useValue: context\n        }],\n        parent: contentInjector\n      });\n      const componentRef = createComponent(componentType, {\n        environmentInjector: this._applicationRef.injector,\n        elementInjector\n      });\n      const componentNativeEl = componentRef.location.nativeElement;\n      this._applicationRef.attachView(componentRef.hostView);\n      return new ContentRef([[componentNativeEl]], componentRef.hostView, componentRef);\n    }\n    _registerOffcanvasRef(ngbOffcanvasRef) {\n      const unregisterOffcanvasRef = () => {\n        this._offcanvasRef = undefined;\n        this._activeInstance.emit(this._offcanvasRef);\n      };\n      this._offcanvasRef = ngbOffcanvasRef;\n      this._activeInstance.emit(this._offcanvasRef);\n      ngbOffcanvasRef.result.then(unregisterOffcanvasRef, unregisterOffcanvasRef);\n    }\n    _registerPanelCmpt(ngbPanelCmpt) {\n      this._panelCmpt = ngbPanelCmpt;\n      this._activePanelCmptHasChanged.next();\n      ngbPanelCmpt.onDestroy(() => {\n        this._panelCmpt = undefined;\n        this._activePanelCmptHasChanged.next();\n      });\n    }\n    static #_ = this.ɵfac = function NgbOffcanvasStack_Factory(t) {\n      return new (t || NgbOffcanvasStack)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbOffcanvasStack,\n      factory: NgbOffcanvasStack.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbOffcanvasStack;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * A service for opening an offcanvas.\n *\n * Creating an offcanvas is straightforward: create a component or a template and pass it as an argument to\n * the `.open()` method.\n *\n * @since 12.1.0\n */\nlet NgbOffcanvas = /*#__PURE__*/(() => {\n  class NgbOffcanvas {\n    constructor() {\n      this._injector = inject(Injector);\n      this._offcanvasStack = inject(NgbOffcanvasStack);\n      this._config = inject(NgbOffcanvasConfig);\n    }\n    /**\n     * Opens a new offcanvas panel with the specified content and supplied options.\n     *\n     * Content can be provided as a `TemplateRef` or a component type. If you pass a component type as content,\n     * then instances of those components can be injected with an instance of the `NgbActiveOffcanvas` class. You can then\n     * use `NgbActiveOffcanvas` methods to close / dismiss offcanvas from \"inside\" of your component.\n     *\n     * Also see the [`NgbOffcanvasOptions`](#/components/offcanvas/api#NgbOffcanvasOptions) for the list of supported\n     * options.\n     */\n    open(content, options = {}) {\n      const combinedOptions = {\n        ...this._config,\n        animation: this._config.animation,\n        ...options\n      };\n      return this._offcanvasStack.open(this._injector, content, combinedOptions);\n    }\n    /**\n     * Returns an observable that holds the active offcanvas instance.\n     */\n    get activeInstance() {\n      return this._offcanvasStack.activeInstance;\n    }\n    /**\n     * Dismisses the currently displayed offcanvas with the supplied reason.\n     */\n    dismiss(reason) {\n      this._offcanvasStack.dismiss(reason);\n    }\n    /**\n     * Indicates if there is currently an open offcanvas in the application.\n     */\n    hasOpenOffcanvas() {\n      return this._offcanvasStack.hasOpenOffcanvas();\n    }\n    static #_ = this.ɵfac = function NgbOffcanvas_Factory(t) {\n      return new (t || NgbOffcanvas)();\n    };\n    static #_2 = this.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n      token: NgbOffcanvas,\n      factory: NgbOffcanvas.ɵfac,\n      providedIn: 'root'\n    });\n  }\n  return NgbOffcanvas;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NgbOffcanvasModule = /*#__PURE__*/(() => {\n  class NgbOffcanvasModule {\n    static #_ = this.ɵfac = function NgbOffcanvasModule_Factory(t) {\n      return new (t || NgbOffcanvasModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbOffcanvasModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  }\n  return NgbOffcanvasModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NGB_MODULES = [NgbAccordionModule, NgbAlertModule, NgbCarouselModule, NgbCollapseModule, NgbDatepickerModule, NgbDropdownModule, NgbModalModule, NgbNavModule, NgbOffcanvasModule, NgbPaginationModule, NgbPopoverModule, NgbProgressbarModule, NgbRatingModule, NgbScrollSpyModule, NgbTimepickerModule, NgbToastModule, NgbTooltipModule, NgbTypeaheadModule];\nlet NgbModule = /*#__PURE__*/(() => {\n  class NgbModule {\n    static #_ = this.ɵfac = function NgbModule_Factory(t) {\n      return new (t || NgbModule)();\n    };\n    static #_2 = this.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n      type: NgbModule\n    });\n    static #_3 = this.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n      imports: [NGB_MODULES, NgbAccordionModule, NgbAlertModule, NgbCarouselModule, NgbCollapseModule, NgbDatepickerModule, NgbDropdownModule, NgbModalModule, NgbNavModule, NgbOffcanvasModule, NgbPaginationModule, NgbPopoverModule, NgbProgressbarModule, NgbRatingModule, NgbScrollSpyModule, NgbTimepickerModule, NgbToastModule, NgbTooltipModule, NgbTypeaheadModule]\n    });\n  }\n  return NgbModule;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ModalDismissReasons, NgbAccordionBody, NgbAccordionButton, NgbAccordionCollapse, NgbAccordionConfig, NgbAccordionDirective, NgbAccordionHeader, NgbAccordionItem, NgbAccordionModule, NgbAccordionToggle, NgbActiveModal, NgbActiveOffcanvas, NgbAlert, NgbAlertConfig, NgbAlertModule, NgbCalendar, NgbCalendarBuddhist, NgbCalendarEthiopian, NgbCalendarGregorian, NgbCalendarHebrew, NgbCalendarIslamicCivil, NgbCalendarIslamicUmalqura, NgbCalendarPersian, NgbCarousel, NgbCarouselConfig, NgbCarouselModule, NgbCollapse, NgbCollapseConfig, NgbCollapseModule, NgbConfig, NgbDate, NgbDateAdapter, NgbDateNativeAdapter, NgbDateNativeUTCAdapter, NgbDateParserFormatter, NgbDateStructAdapter, NgbDatepicker, NgbDatepickerConfig, NgbDatepickerContent, NgbDatepickerI18n, NgbDatepickerI18nAmharic, NgbDatepickerI18nDefault, NgbDatepickerI18nHebrew, NgbDatepickerKeyboardService, NgbDatepickerModule, NgbDatepickerMonth, NgbDropdown, NgbDropdownAnchor, NgbDropdownButtonItem, NgbDropdownConfig, NgbDropdownItem, NgbDropdownMenu, NgbDropdownModule, NgbDropdownToggle, NgbHighlight, NgbInputDatepicker, NgbInputDatepickerConfig, NgbModal, NgbModalConfig, NgbModalModule, NgbModalRef, NgbModule, NgbNav, NgbNavConfig, NgbNavContent, NgbNavItem, NgbNavItemRole, NgbNavLink, NgbNavLinkBase, NgbNavLinkButton, NgbNavModule, NgbNavOutlet, NgbNavPane, NgbOffcanvas, NgbOffcanvasConfig, NgbOffcanvasModule, NgbOffcanvasRef, NgbPagination, NgbPaginationConfig, NgbPaginationEllipsis, NgbPaginationFirst, NgbPaginationLast, NgbPaginationModule, NgbPaginationNext, NgbPaginationNumber, NgbPaginationPages, NgbPaginationPrevious, NgbPopover, NgbPopoverConfig, NgbPopoverModule, NgbProgressbar, NgbProgressbarConfig, NgbProgressbarModule, NgbProgressbarStacked, NgbRating, NgbRatingConfig, NgbRatingModule, NgbScrollSpy, NgbScrollSpyConfig, NgbScrollSpyFragment, NgbScrollSpyItem, NgbScrollSpyMenu, NgbScrollSpyModule, NgbScrollSpyService, NgbSlide, NgbSlideEventDirection, NgbSlideEventSource, NgbTimeAdapter, NgbTimepicker, NgbTimepickerConfig, NgbTimepickerI18n, NgbTimepickerModule, NgbToast, NgbToastConfig, NgbToastHeader, NgbToastModule, NgbTooltip, NgbTooltipConfig, NgbTooltipModule, NgbTypeahead, NgbTypeaheadConfig, NgbTypeaheadModule, OffcanvasDismissReasons };\n//# sourceMappingURL=ng-bootstrap.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}